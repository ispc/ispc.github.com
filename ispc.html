<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Intel® ISPC User's Guide - Complete documentation for the high-performance SIMD compiler">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="stylesheet" href="css/style.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Intel® ISPC User's Guide</title>
</head>
<body>
<div class="container">
  <header class="site-header">
    <nav class="main-nav">
      <div class="nav-brand">
        <h1>Intel® ISPC</h1>
      </div>
      <ul class="nav-menu">
        <li class="nav-item"><a href="index.html">Overview</a></li>
        <li class="nav-item"><a href="features.html">Features</a></li>
        <li class="nav-item"><a href="downloads.html">Downloads</a></li>
        <li class="nav-item active"><a href="documentation.html">Documentation</a></li>
        <li class="nav-item"><a href="perf.html">Performance</a></li>
        <li class="nav-item"><a href="contrib.html">Contributors</a></li>
      </ul>
    </nav>
  </header>

  <main class="main-content">
    <div class="content-grid">
      <article class="content-main">
<h1 class="title">Intel® ISPC User's Guide</h1>

<p>The Intel® Implicit SPMD Program Compiler (Intel® ISPC) is a compiler for
writing SPMD (single program multiple data) programs to run on the CPU and GPU.
The SPMD
programming approach is widely known to graphics and GPGPU programmers; it
is used for GPU shaders and CUDA* and OpenCL* kernels, for example.  The
main idea behind SPMD is that one writes programs as if they were operating
on a single data element (a pixel for a pixel shader, for example), but
then the underlying hardware and runtime system executes multiple
invocations of the program in parallel with different inputs (the values
for different pixels, for example).</p>
<p>The main goals behind <tt class="docutils literal">ispc</tt> are to:</p>
<ul class="simple">
<li>Build a variant of the C programming language that delivers good
performance to performance-oriented programmers who want to run SPMD
programs on CPUs and GPUs.</li>
<li>Provide a thin abstraction layer between the programmer and the
hardware--in particular, to follow the lesson from C for serial programs
of having an execution and data model where the programmer can cleanly
reason about the mapping of their source program to compiled assembly
language and the underlying hardware.</li>
<li>Harness the computational power of Single Program, Multiple Data (SIMD) vector
units without the extremely low-productivity task of directly writing
intrinsics.</li>
<li>Explore opportunities enabled by tight coupling between C/C++ application code
and SPMD <tt class="docutils literal">ispc</tt> code running on the same processor—lightweight function
calls between the two languages, direct data sharing via pointers without
copying or reformatting, etc.</li>
</ul>
<p><strong>We are very interested in your feedback and comments about ispc and
in hearing your experiences using the system.  We are especially interested
in hearing if you try using ispc but see results that are not as you
were expecting or hoping for.</strong> We encourage you to send a note with your
experiences or comments to the <a class="reference external" href="https://github.com/ispc/ispc/discussions">GitHub Discussions</a> forum or to file bug or
feature requests with the <tt class="docutils literal">ispc</tt> <a class="reference external" href="https://github.com/ispc/ispc/issues?state=open">bug tracker</a>. (Thanks!)</p>
<p>Contents:</p>
<ul class="simple">
<li><a class="reference internal" href="#recent-changes-to-ispc">Recent Changes to ISPC</a><ul>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-1">Updating ISPC Programs For Changes In ISPC 1.1</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-2">Updating ISPC Programs For Changes In ISPC 1.2</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-3">Updating ISPC Programs For Changes In ISPC 1.3</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-5-0">Updating ISPC Programs For Changes In ISPC 1.5.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-6-0">Updating ISPC Programs For Changes In ISPC 1.6.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-7-0">Updating ISPC Programs For Changes In ISPC 1.7.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-8-2">Updating ISPC Programs For Changes In ISPC 1.8.2</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-9-0">Updating ISPC Programs For Changes In ISPC 1.9.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-9-1">Updating ISPC Programs For Changes In ISPC 1.9.1</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-9-2">Updating ISPC Programs For Changes In ISPC 1.9.2</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-10-0">Updating ISPC Programs For Changes In ISPC 1.10.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-11-0">Updating ISPC Programs For Changes In ISPC 1.11.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-12-0">Updating ISPC Programs For Changes In ISPC 1.12.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-13-0">Updating ISPC Programs For Changes In ISPC 1.13.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-14-0">Updating ISPC Programs For Changes In ISPC 1.14.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-14-1">Updating ISPC Programs For Changes In ISPC 1.14.1</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-15-0">Updating ISPC Programs For Changes In ISPC 1.15.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-16-0">Updating ISPC Programs For Changes In ISPC 1.16.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-17-0">Updating ISPC Programs For Changes In ISPC 1.17.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-18-0">Updating ISPC Programs For Changes In ISPC 1.18.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-19-0">Updating ISPC Programs For Changes In ISPC 1.19.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-20-0">Updating ISPC Programs For Changes In ISPC 1.20.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-21-0">Updating ISPC Programs For Changes In ISPC 1.21.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-22-0">Updating ISPC Programs For Changes In ISPC 1.22.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-23-0">Updating ISPC Programs For Changes In ISPC 1.23.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-24-0">Updating ISPC Programs For Changes In ISPC 1.24.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-25-0">Updating ISPC Programs For Changes In ISPC 1.25.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-26-0">Updating ISPC Programs For Changes In ISPC 1.26.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-27-0">Updating ISPC Programs For Changes In ISPC 1.27.0</a></li>
<li><a class="reference internal" href="#updating-ispc-programs-for-changes-in-ispc-1-28-0">Updating ISPC Programs For Changes In ISPC 1.28.0</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getting-started-with-ispc">Getting Started with ISPC</a><ul>
<li><a class="reference internal" href="#installing-ispc">Installing ISPC</a></li>
<li><a class="reference internal" href="#compiling-and-running-a-simple-ispc-program">Compiling and Running a Simple ISPC Program</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-ispc-compiler">Using The ISPC Compiler</a><ul>
<li><a class="reference internal" href="#basic-command-line-options">Basic Command-line Options</a></li>
<li><a class="reference internal" href="#selecting-the-compilation-target">Selecting The Compilation Target</a></li>
<li><a class="reference internal" href="#selecting-32-or-64-bit-addressing">Selecting 32 or 64 Bit Addressing</a></li>
<li><a class="reference internal" href="#the-preprocessor">The Preprocessor</a></li>
<li><a class="reference internal" href="#pragma-directives">Pragma Directives</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#optimization-settings">Optimization Settings</a></li>
<li><a class="reference internal" href="#other-ways-of-passing-arguments-to-ispc">Other ways of passing arguments to ISPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-ispc-as-a-library">Using ISPC as a Library</a><ul>
<li><a class="reference internal" href="#library-initialization">Library Initialization</a></li>
<li><a class="reference internal" href="#simple-compilation-interface">Simple Compilation Interface</a></li>
<li><a class="reference internal" href="#advanced-interface-with-ispcengine">Advanced Interface with ISPCEngine</a></li>
<li><a class="reference internal" href="#just-in-time-jit-compilation-interface">Just-In-Time (JIT) Compilation Interface</a></li>
<li><a class="reference internal" href="#compatibility">Compatibility</a></li>
<li><a class="reference internal" href="#cmake-integration">CMake Integration</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic Usage</a></li>
<li><a class="reference internal" href="#cmake-variables">CMake Variables</a></li>
<li><a class="reference internal" href="#cmake-example">CMake Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-ispc-parallel-execution-model">The ISPC Parallel Execution Model</a><ul>
<li><a class="reference internal" href="#basic-concepts-program-instances-and-gangs-of-program-instances">Basic Concepts: Program Instances and Gangs of Program Instances</a></li>
<li><a class="reference internal" href="#control-flow-within-a-gang">Control Flow Within A Gang</a><ul>
<li><a class="reference internal" href="#control-flow-example-if-statements">Control Flow Example: If Statements</a></li>
<li><a class="reference internal" href="#control-flow-example-loops">Control Flow Example: Loops</a></li>
<li><a class="reference internal" href="#gang-convergence-guarantees">Gang Convergence Guarantees</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uniform-data">Uniform Data</a><ul>
<li><a class="reference internal" href="#uniform-control-flow">Uniform Control Flow</a></li>
<li><a class="reference internal" href="#uniform-variables-and-varying-control-flow">Uniform Variables and Varying Control Flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-races-within-a-gang">Data Races Within a Gang</a></li>
<li><a class="reference internal" href="#tasking-model">Tasking Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-ispc-language">The ISPC Language</a><ul>
<li><a class="reference internal" href="#relationship-to-the-c-programming-language">Relationship To The C Programming Language</a></li>
<li><a class="reference internal" href="#lexical-structure">Lexical Structure</a><ul>
<li><a class="reference internal" href="#integer-literals">Integer Literals</a></li>
<li><a class="reference internal" href="#floating-point-literals">Floating Point Literals</a></li>
<li><a class="reference internal" href="#string-literals">String Literals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#types">Types</a><ul>
<li><a class="reference internal" href="#basic-types-and-type-qualifiers">Basic Types and Type Qualifiers</a></li>
<li><a class="reference internal" href="#signed-and-unsigned-integer-types">Signed and Unsigned Integer Types</a></li>
<li><a class="reference internal" href="#uniform-and-varying-qualifiers">&quot;uniform&quot; and &quot;varying&quot; Qualifiers</a></li>
<li><a class="reference internal" href="#defining-new-names-for-types">Defining New Names For Types</a></li>
<li><a class="reference internal" href="#pointer-types">Pointer Types</a></li>
<li><a class="reference internal" href="#function-pointer-types">Function Pointer Types</a></li>
<li><a class="reference internal" href="#reference-types">Reference Types</a></li>
<li><a class="reference internal" href="#enumeration-types">Enumeration Types</a></li>
<li><a class="reference internal" href="#short-vector-types">Short Vector Types</a></li>
<li><a class="reference internal" href="#array-types">Array Types</a></li>
<li><a class="reference internal" href="#struct-types">Struct Types</a><ul>
<li><a class="reference internal" href="#operators-overloading">Operators Overloading</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure-of-array-types">Structure of Array Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations-and-initializers">Declarations and Initializers</a></li>
<li><a class="reference internal" href="#attributes">Attributes</a><ul>
<li><a class="reference internal" href="#noescape">noescape</a></li>
<li><a class="reference internal" href="#address-space">address_space</a></li>
<li><a class="reference internal" href="#unmangled">unmangled</a></li>
<li><a class="reference internal" href="#external-only">external_only</a></li>
<li><a class="reference internal" href="#deprecated">deprecated</a></li>
<li><a class="reference internal" href="#aligned">aligned</a></li>
</ul>
</li>
<li><a class="reference internal" href="#expressions">Expressions</a><ul>
<li><a class="reference internal" href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
<li><a class="reference internal" href="#type-casting">Type Casting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-flow">Control Flow</a><ul>
<li><a class="reference internal" href="#conditional-statements-if">Conditional Statements: &quot;if&quot;</a></li>
<li><a class="reference internal" href="#conditional-statements-switch">Conditional Statements: &quot;switch&quot;</a></li>
<li><a class="reference internal" href="#iteration-statements">Iteration Statements</a><ul>
<li><a class="reference internal" href="#basic-iteration-statements-for-while-and-do">Basic Iteration Statements: &quot;for&quot;, &quot;while&quot;, and &quot;do&quot;</a></li>
<li><a class="reference internal" href="#iteration-over-active-program-instances-foreach-active">Iteration over active program instances: &quot;foreach_active&quot;</a></li>
<li><a class="reference internal" href="#iteration-over-unique-elements-foreach-unique">Iteration over unique elements: &quot;foreach_unique&quot;</a></li>
<li><a class="reference internal" href="#parallel-iteration-statements-foreach-and-foreach-tiled">Parallel Iteration Statements: &quot;foreach&quot; and &quot;foreach_tiled&quot;</a></li>
<li><a class="reference internal" href="#parallel-iteration-with-programindex-and-programcount">Parallel Iteration with &quot;programIndex&quot; and &quot;programCount&quot;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unstructured-control-flow-goto">Unstructured Control Flow: &quot;goto&quot;</a></li>
<li><a class="reference internal" href="#coherent-control-flow-statements-cif-and-friends">&quot;Coherent&quot; Control Flow Statements: &quot;cif&quot; and Friends</a></li>
<li><a class="reference internal" href="#functions-and-function-calls">Functions and Function Calls</a><ul>
<li><a class="reference internal" href="#function-overloading">Function Overloading</a></li>
</ul>
</li>
<li><a class="reference internal" href="#re-establishing-the-execution-mask">Re-establishing The Execution Mask</a></li>
<li><a class="reference internal" href="#task-parallel-execution">Task Parallel Execution</a><ul>
<li><a class="reference internal" href="#task-parallelism-launch-and-sync-statements">Task Parallelism: &quot;launch&quot; and &quot;sync&quot; Statements</a></li>
<li><a class="reference internal" href="#task-parallelism-runtime-requirements">Task Parallelism: Runtime Requirements</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-intrinsic-functions">LLVM Intrinsic Functions</a></li>
<li><a class="reference internal" href="#function-templates">Function Templates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-ispc-standard-library">The ISPC Standard Library</a><ul>
<li><a class="reference internal" href="#basic-operations-on-data">Basic Operations On Data</a><ul>
<li><a class="reference internal" href="#logical-and-selection-operations">Logical and Selection Operations</a></li>
<li><a class="reference internal" href="#bit-operations">Bit Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#math-functions">Math Functions</a><ul>
<li><a class="reference internal" href="#basic-math-functions">Basic Math Functions</a></li>
<li><a class="reference internal" href="#transcendental-functions">Transcendental Functions</a></li>
<li><a class="reference internal" href="#saturating-arithmetic">Saturating Arithmetic</a></li>
<li><a class="reference internal" href="#dot-product">Dot product</a></li>
<li><a class="reference internal" href="#pseudo-random-numbers">Pseudo-Random Numbers</a></li>
<li><a class="reference internal" href="#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#output-functions">Output Functions</a></li>
<li><a class="reference internal" href="#assertions">Assertions</a></li>
<li><a class="reference internal" href="#compiler-optimization-hints">Compiler Optimization Hints</a></li>
<li><a class="reference internal" href="#cross-program-instance-operations">Cross-Program Instance Operations</a><ul>
<li><a class="reference internal" href="#reductions">Reductions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stack-memory-allocation">Stack Memory Allocation</a></li>
<li><a class="reference internal" href="#data-movement">Data Movement</a><ul>
<li><a class="reference internal" href="#setting-and-copying-values-in-memory">Setting and Copying Values In Memory</a></li>
<li><a class="reference internal" href="#packed-load-and-store-operations">Packed Load and Store Operations</a></li>
<li><a class="reference internal" href="#streaming-load-and-store-operations">Streaming Load and Store Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-conversions">Data Conversions</a><ul>
<li><a class="reference internal" href="#converting-between-array-of-structures-and-structure-of-arrays-layout">Converting Between Array-of-Structures and Structure-of-Arrays Layout</a></li>
<li><a class="reference internal" href="#conversions-to-and-from-half-precision-floats">Conversions To and From Half-Precision Floats</a></li>
<li><a class="reference internal" href="#converting-from-to-srgb8">Converting from/to sRGB8</a></li>
</ul>
</li>
<li><a class="reference internal" href="#systems-programming-support">Systems Programming Support</a><ul>
<li><a class="reference internal" href="#atomic-operations-and-memory-fences">Atomic Operations and Memory Fences</a></li>
<li><a class="reference internal" href="#prefetches">Prefetches</a></li>
<li><a class="reference internal" href="#system-information">System Information</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#interoperability-with-the-application">Interoperability with the Application</a><ul>
<li><a class="reference internal" href="#interoperability-overview">Interoperability Overview</a></li>
<li><a class="reference internal" href="#data-layout">Data Layout</a></li>
<li><a class="reference internal" href="#data-alignment-and-aliasing">Data Alignment and Aliasing</a></li>
<li><a class="reference internal" href="#restructuring-existing-programs-to-use-ispc">Restructuring Existing Programs to Use ISPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notices-disclaimers">Notices &amp; Disclaimers</a></li>
</ul>
<div class="section" id="recent-changes-to-ispc">
<h1>Recent Changes to ISPC</h1>
<p>See the file <a class="reference external" href="https://raw.github.com/ispc/ispc/main/docs/ReleaseNotes.txt">ReleaseNotes.txt</a> in the <tt class="docutils literal">ispc</tt> distribution for a list
of recent changes to the compiler.</p>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-1">
<h2>Updating ISPC Programs For Changes In ISPC 1.1</h2>
<p>The major changes introduced in the 1.1 release of <tt class="docutils literal">ispc</tt> are first-class
support for pointers in the language and new parallel loop constructs.
Adding this functionality required a number of syntactic changes to the
language.  These changes should generally lead to straightforward minor
modifications of existing <tt class="docutils literal">ispc</tt> programs.</p>
<p>These are the relevant changes to the language:</p>
<ul class="simple">
<li>The syntax for reference types has been changed to match C++'s syntax for
references and the <tt class="docutils literal">reference</tt> keyword has been removed.  (A diagnostic
message is issued if <tt class="docutils literal">reference</tt> is used.)<ul>
<li>Declarations like <tt class="docutils literal">reference float foo</tt> should be changed to <tt class="docutils literal">float &amp;foo</tt>.</li>
<li>Any array parameters in function declaration with a <tt class="docutils literal">reference</tt>
qualifier should just have <tt class="docutils literal">reference</tt> removed: <tt class="docutils literal">void foo(reference
float <span class="pre">bar[])</span></tt> can just be <tt class="docutils literal">void foo(float <span class="pre">bar[])</span></tt>.</li>
</ul>
</li>
<li>It is now a compile-time error to assign an entire array to another
array.</li>
<li>A number of standard library routines have been updated to take
pointer-typed parameters, rather than references or arrays an index
offsets, as appropriate.  For example, the <tt class="docutils literal">atomic_add_global()</tt>
function previously took a reference to the variable to be updated
atomically but now takes a pointer.  In a similar fashion,
<tt class="docutils literal">packed_store_active()</tt> takes a pointer to a <tt class="docutils literal">uniform unsigned int</tt>
as its first parameter rather than taking a <tt class="docutils literal">uniform unsigned int[]</tt> as
its first parameter and a <tt class="docutils literal">uniform int</tt> offset as its second parameter.</li>
<li>It is no longer legal to pass a varying lvalue to a function that takes a
reference parameter; references can only be to uniform lvalue types.  In
this case, the function should be rewritten to take a varying pointer
parameter.</li>
<li>There are new iteration constructs for looping over computation domains,
<tt class="docutils literal">foreach</tt> and <tt class="docutils literal">foreach_tiled</tt>.  In addition to being syntactically
cleaner than regular <tt class="docutils literal">for</tt> loops, these can provide performance
benefits in many cases when iterating over data and mapping it to program
instances.  See the Section <a class="reference internal" href="#parallel-iteration-statements-foreach-and-foreach-tiled">Parallel Iteration Statements: &quot;foreach&quot; and
&quot;foreach_tiled&quot;</a> for more information about these.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-2">
<h2>Updating ISPC Programs For Changes In ISPC 1.2</h2>
<p>The following changes were made to the language syntax and semantics for
the <tt class="docutils literal">ispc</tt> 1.2 release:</p>
<ul class="simple">
<li>Syntax for the &quot;launch&quot; keyword has been cleaned up; it's now no longer
necessary to bracket the launched function call with angle brackets. (In
other words, now use <tt class="docutils literal">launch <span class="pre">foo();</span></tt>, rather than <tt class="docutils literal">launch &lt; foo() &gt;;</tt>.)</li>
<li>When using pointers, the pointed-to data type is now &quot;uniform&quot; by
default.  Use the varying keyword to specify varying pointed-to types
when needed.  (i.e. <tt class="docutils literal">float *ptr</tt> is a varying pointer to uniform float
data, whereas previously it was a varying pointer to varying float
values.) Use <tt class="docutils literal">varying float *</tt> to specify a varying pointer to varying
float data, and so forth.</li>
<li>The details of &quot;uniform&quot; and &quot;varying&quot; and how they interact with struct
types have been cleaned up.  Now, when a struct type is declared, if the
struct elements don't have explicit &quot;uniform&quot; or &quot;varying&quot; qualifiers,
they are said to have &quot;unbound&quot; variability.  When a struct type is
instantiated, any unbound variability elements inherit the variability of
the parent struct type. See <a class="reference internal" href="#struct-types">Struct Types</a> for more details.</li>
<li><tt class="docutils literal">ispc</tt> has a new language feature that makes it much easier to use the
efficient &quot;(array of) structure of arrays&quot; (AoSoA, or SoA) memory layout
of data.  A new <tt class="docutils literal">soa&lt;n&gt;</tt> qualifier can be applied to structure types to
specify an n-wide SoA version of the corresponding type.  Array indexing
and pointer operations with arrays SoA types automatically handles the
two-stage indexing calculation to access the data.  See <a class="reference internal" href="#structure-of-array-types">Structure of
Array Types</a> for more details.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-3">
<h2>Updating ISPC Programs For Changes In ISPC 1.3</h2>
<p>This release adds a number of new iteration constructs, which in turn use
new reserved words: <tt class="docutils literal">unmasked</tt>, <tt class="docutils literal">foreach_unique</tt>, <tt class="docutils literal">foreach_active</tt>,
and <tt class="docutils literal">in</tt>.  Any program that happens to have a variable or function with
one of these names must be modified to rename that symbol.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-5-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.5.0</h2>
<p>This release adds support for double precision floating point constants.
Double precision floating point constants are floating point number with
<tt class="docutils literal">d</tt> suffix and optional exponent part. Here are some examples: 3.14d,
31.4d-1, 1.d, 1.0d, 1d-2. Note that floating point number without suffix is
treated as single precision constant.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-6-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.6.0</h2>
<p>This release adds support for <a class="reference internal" href="#operators-overloading">Operators Overloading</a>, so a word <tt class="docutils literal">operator</tt>
becomes a keyword and it potentially creates a conflict with existing user
function. Also a new library function packed_store_active2() was introduced,
which also may create a conflict with existing user functions.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-7-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.7.0</h2>
<p>This release contains several changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li>The algorithm for selecting overloaded functions was extended to cover more
types of overloading, and handling of reference types was fixed. At the same
time the old scheme, which blindly used the function with &quot;the best score&quot;
summed for all arguments, was switched to the C++ approach, which requires
&quot;the best score&quot; for each argument. If the best function doesn't exist, a
warning is issued in this version. It will be turned into an error in the
next version. A simple example: Suppose we have two functions: max(int, int)
and max(unsigned int, unsigned int). The new rules lead to an error when
calling max(int, unsigned int), as the best choice is ambiguous.</li>
<li>Implicit cast of pointer to const type to void* was disallowed. Use explicit
cast if needed.</li>
<li>A bug which prevented &quot;const&quot; qualifiers from appearing in emitted .h files
was fixed. Consequently, &quot;const&quot; qualifiers now properly appearing in emitted
.h files may cause compile errors in pre-existing codes.</li>
<li>get_ProgramCount() was moved from stdlib to examples/util/util.isph file. You
need to include this file to be able to use this function.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-8-2">
<h2>Updating ISPC Programs For Changes In ISPC 1.8.2</h2>
<p>The release doesn't contain language changes, which may affect compatibility with
older versions. Though you may want to be aware of the following:</p>
<ul class="simple">
<li>Mangling of uniform types was changed to not include varying width, so now you
may use uniform structures and pointers to uniform types as return types in
export functions in multi-target compilation.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-9-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.9.0</h2>
<p>The release doesn't contain language changes, which may affect compatibility with
older versions. It introduces new AVX-512 target: avx512knl-i32x16.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-9-1">
<h2>Updating ISPC Programs For Changes In ISPC 1.9.1</h2>
<p>The release doesn't contain language changes, which may affect compatibility with
older versions. It introduces new AVX-512 target: avx512skx-i32x16.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-9-2">
<h2>Updating ISPC Programs For Changes In ISPC 1.9.2</h2>
<p>The release doesn't contain language changes, which may affect compatibility with
older versions.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-10-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.10.0</h2>
<p>The release has several new language features, which do not affect compatibility.
Namely, new streaming stores, aos_to_soa/soa_to_aos intrinsics for 64 bit types,
and a &quot;#pragma ignore&quot;.</p>
<p>One change that may potentially affect compatibility is the changed size of short vector
types. If you use short vector types for data passed between C/C++ and ISPC, you
may want to pay attention to it.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-11-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.11.0</h2>
<p>This release redefined the -O1 compiler option to optimize for size, so it may require
adjusting your build system accordingly.</p>
<p>Starting with version 1.11.0, auto-generated headers use <tt class="docutils literal">#pragma once</tt>. In the unlikely
case that your C/C++ compiler does not support that, please use the <tt class="docutils literal"><span class="pre">--no-pragma-once</span></tt>
<tt class="docutils literal">ispc</tt> switch.</p>
<p>This release also introduces a new AVX-512 target avx512skx-i32x8. It produces code,
which doesn't use ZMM registers.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-12-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.12.0</h2>
<p>This release contains the following changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li><tt class="docutils literal">noinline</tt> keyword was added.</li>
<li>Standard library functions <tt class="docutils literal">rsqrt_fast()</tt> and <tt class="docutils literal">rcp_fast()</tt> were added.</li>
<li>AVX1.1 (IvyBridge) targets and generic KNC and KNL targets were removed.
Note that KNL is still supported through avx512knl-i32x16.</li>
</ul>
<p>The release also introduces static initialization for varying variables, which
should not affect compatibility.</p>
<p>This release introduces experimental cross OS compilation support and ARM/AARCH64
support. It also contains a new 128-bit AVX2 target (avx2-i32x4) and a CPU
definition for Ice Lake client (--device=icl).</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-13-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.13.0</h2>
<p>This release contains the following changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li>Representation of <tt class="docutils literal">bool</tt> type in storage was changed from target-specific to
one byte per boolean value.  So size of <tt class="docutils literal">varying bool</tt> is target width (in
bytes), and size of <tt class="docutils literal">uniform bool</tt> is one.  This definition is compatible
with C/C++, hence improves interoperability.</li>
<li>type aliases for unsigned types were added: <tt class="docutils literal">uint8</tt>, <tt class="docutils literal">uint16</tt>, <tt class="docutils literal">uint32</tt>,
<tt class="docutils literal">uint64</tt>, and <tt class="docutils literal">uint</tt>.  To detect if these types are supported you can
check if ISPC_UINT_IS_DEFINED macro is defined, this is handy for writing code
which works with older versions of <tt class="docutils literal">ispc</tt>.</li>
<li><tt class="docutils literal">extract()</tt>/<tt class="docutils literal">insert()</tt> for boolean arguments, and <tt class="docutils literal">abs()</tt> for all integer and
FP types were added to standard library.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-14-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.14.0</h2>
<p>This release contains the following changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li>&quot;generic&quot; targets were removed. Please use native targets instead.</li>
</ul>
<p>New i8 and i16 targets were introduced: avx2-i8x32, avx2-i16x16, avx512skx-i8x64,
and avx512skx-i16x32.</p>
<p>Windows x86_64 target now supports <tt class="docutils literal">__vectorcall</tt> calling convention.
It's off by default, can be enabled by <tt class="docutils literal"><span class="pre">--vectorcall</span></tt> command line switch.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-14-1">
<h2>Updating ISPC Programs For Changes In ISPC 1.14.1</h2>
<p>The release doesn't contain language changes, which may affect compatibility with
older versions.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-15-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.15.0</h2>
<p>The release has several new language features, which do not affect compatibility.
Namely, packed_[load|store]_active() stdlib functions for 64 bit types, and loop
unroll pragmas: &quot;#pragma unroll&quot; and &quot;#pragma nounroll&quot;.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-16-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.16.0</h2>
<p>The release has several new functions in the standard library that may
affect compatibility:</p>
<ul class="simple">
<li><tt class="docutils literal">alloca()</tt> - refer to <a class="reference internal" href="#stack-memory-allocation">Stack Memory Allocation</a> for more details.</li>
<li><tt class="docutils literal">assume()</tt> - refer to <a class="reference internal" href="#compiler-optimization-hints">Compiler Optimization Hints</a> for more details.</li>
<li><tt class="docutils literal">trunc()</tt> - refer to <a class="reference internal" href="#basic-math-functions">Basic Math Functions</a> for more details.</li>
</ul>
<p>The language got experimental feature for calling LLVM intrinsics. This
should not affect compatibility with existing programs.
See <a class="reference internal" href="#llvm-intrinsic-functions">LLVM Intrinsic Functions</a> for more details.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-17-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.17.0</h2>
<p>The release introduces new data type <tt class="docutils literal">float16</tt> and floating point literals
with <tt class="docutils literal">f16</tt> suffix.</p>
<p>For the sake of unification with C/C++, capital letter X may be used in
hexadecimal prefix (<tt class="docutils literal">0X</tt>) and capital letter P as a separator for exponent in
hexadecimal floating point. For example: <tt class="docutils literal">0X1P16</tt>.</p>
<p>The naming of Xe targets, architectures, device names has changed.</p>
<p>The standard library got new <tt class="docutils literal"><span class="pre">prefetchw_{l1,l2,l3}()</span></tt> intrinsics for
prefetching in anticipation of a write.</p>
<p>The algorithms used for implementation of <tt class="docutils literal">rsqrt(double)</tt> and <tt class="docutils literal">rcp(double)</tt>
standard library functions have changed on AVX-512 and may affect the existing
code.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-18-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.18.0</h2>
<p>AVX-512 targets were renamed to drop &quot;base type&quot; (or &quot;mask size&quot;), old naming is accepted for
compatibility. New names are avx512skx-x4, avx512skx-x8, avx512skx-x16,
avx512skx-x32, avx512skx-x64, and avx512knl-x16.</p>
<p>Standard library gained full support for <tt class="docutils literal">float16</tt> type.  Note that it is
fully supported only on the targets with native hardware support.
On the other targets emulation is still not guaranteed, but may work in some cases.</p>
<p>The compiler gained support for <tt class="docutils literal"><span class="pre">-E</span></tt> switch for running preprocessor only,
which is similar to the switch of C/C++ compilers.  Also, as a result of bug fix,
in case of preprocessor error, the compiler will crash now.  It used not to crash and
produced some output (sometimes correct!).  As it was a convenient feature for some
users running experiments in isolated environment (like ignoring missing includes
when compiling on <a class="reference external" href="https://godbolt.org/">Compiler Explorer</a>), the <tt class="docutils literal"><span class="pre">--ignore-preprocessor-errors</span></tt> switch
was added to preserve this behavior.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-19-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.19.0</h2>
<p>New targets were added:</p>
<ul class="simple">
<li>avx512spr-x4, avx512spr-x8, avx512spr-x16, avx512spr-x32, avx512spr-x64 for
4th generation Intel® Xeon® Scalable (codename Sapphire Rapids) CPUs. A macro
<tt class="docutils literal">ISPC_TARGET_AVX512SPR</tt> was added.</li>
<li>xehpc-x16 and xehpc-x32 for Intel® Data Center GPU Max (codename Ponte Vecchio).</li>
</ul>
<p>Function templates were introduced to the language, please refer to the <a class="reference internal" href="#function-templates">Function
Templates</a> section for more details. Two new keywords were introduced: <tt class="docutils literal">template</tt>
and <tt class="docutils literal">typename</tt>.</p>
<p><tt class="docutils literal">ISPC_FP16_SUPPORTED</tt> macro was introduced for the targets supporting FP16.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-20-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.20.0</h2>
<p>New version of <cite>sse4</cite> targets were added, now you can specify either <cite>sse4.1</cite>
or <cite>sse4.2</cite>, for example <cite>sse4.2-i32x4</cite>. The changes are fully backward
compatible, meaning that <cite>sse4</cite> versions are still accepted and aliased to
<cite>sse4.2</cite>. Multi-target compilation accepts only one of <cite>sse4</cite>/<cite>sse4.1</cite>/<cite>sse4.2</cite>
targets. All of these targets will produce an object file with <cite>sse4</cite> suffix in
multi-target compilation.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-21-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.21.0</h2>
<p>Now, in case of signed integer overflow, <cite>ispc</cite> will assume undefined behavior similar to
C and C++. This change may cause compatibility issues. You can manage this behavior by
using the <cite>--[no-]wrap-signed-int</cite> compiler switch. The default behavior (before version
1.21.0) can be preserved by using <cite>--wrap-signed-int</cite>, which maintains defined wraparound
behavior for signed integers, though it may limit some compiler optimizations.</p>
<p>Template function specializations with explicit template arguments were introduced to the
language, please refer to <a class="reference internal" href="#function-templates">Function Templates</a> section for more details.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-22-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.22.0</h2>
<p>Template operators with explicit specializations and instantiations were introduced to
the language. The usage of different function specifiers with templates were fixed and
aligned, please refer to <a class="reference internal" href="#function-templates">Function Templates</a> section for more details.</p>
<p>Now, command-line switch <cite>--dwarf-version=&lt;n&gt;</cite> forces DWARF format debug info generation
on Windows. It allows to debug ISPC code linked with MinGW generated code.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-23-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.23.0</h2>
<p>This release contains the following changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li><cite>true</cite> <cite>bool</cite> values in storage were changed from <cite>-1</cite> to <cite>1</cite> to match C/C++ ABI.
Previously, ISPC treated <cite>bool</cite> values similarly to C/C++ in terms of size, but
incorrectly interpreted their actual values. This meant that <cite>true</cite> in ISPC
might not have translated correctly to true in C/C++. This issue was introduced
in version 1.13.0. Starting now, ISPC correctly stores and interprets <cite>true</cite>
values in a way that aligns with C/C++ expectations.</li>
</ul>
<p>A couple of improvements have been made to variables initialization:</p>
<ul class="simple">
<li>Variables with const qualifiers can be initialized using the values of
previously initialized const variables including arithmetic operations above
them. It now works also with varying types.</li>
<li>Enumeration type values can be used as constants.</li>
</ul>
<p>The result of selection operator can now be used as lvalue if it has suitable
type.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-24-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.24.0</h2>
<p>This release extends the standard library with new functions performing dot
product operations. These functions utilize specific hardware instructions from
AVX-VNNI and AVX512-VNNI. The ISPC targets that support native VNNI
instructions are <tt class="docutils literal"><span class="pre">avx2vnni-i32x*</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-*</span></tt> and <tt class="docutils literal"><span class="pre">avx512spr-*</span></tt>. The
first two targets (<tt class="docutils literal"><span class="pre">avx2vnni-*</span></tt> and <tt class="docutils literal"><span class="pre">avx512icl-*</span></tt>) were introduced in this
release. Please refer to <a class="reference internal" href="#dot-product">Dot product</a> for more details.</p>
<p>Now, uniform integers and enums can be used as non-type template parameters.
Please refer to <a class="reference internal" href="#function-templates">Function Templates</a> for more details.</p>
<p>The release contains the following changes that may affect compatibility with
older versions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">--pic</span></tt> command line flag now corresponds to the <tt class="docutils literal"><span class="pre">-fpic</span></tt> flag of Clang
and GCC, whereas the newly introduced <tt class="docutils literal"><span class="pre">--PIC</span></tt> corresponds to <tt class="docutils literal"><span class="pre">-fPIC</span></tt>.
The previous behavior of <tt class="docutils literal"><span class="pre">--pic</span></tt> flag corresponded to <tt class="docutils literal"><span class="pre">-fPIC</span></tt> flag. In
some cases, to preserve previous behavior, users may need to switch to
<tt class="docutils literal"><span class="pre">--PIC</span></tt>.</li>
<li>Newly introduced macro definitions for numeric limits can cause conflicts
with user-defined macros with same names. When this happens, ISPC emits
warnings about macro redefinition. Please, refer to <a class="reference internal" href="#the-preprocessor">The Preprocessor</a> for
the full list of macro definitions.</li>
<li>The implementation of <tt class="docutils literal">round</tt> standard library function was aligned across
all targets. It may potentially affect the results of the code that uses this
function for the following targets: <tt class="docutils literal"><span class="pre">avx2-i16x16</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i8x32</span></tt> and all
AVX-512 targets. Please, refer to <a class="reference internal" href="#basic-math-functions">Basic Math Functions</a> for more details.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-25-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.25.0</h2>
<p>The ISPC language has been extended to support the <tt class="docutils literal"><span class="pre">__attribute__(())</span></tt> syntax
for variable and function declarations. The following attributes are now
supported: <tt class="docutils literal">noescape</tt>, <tt class="docutils literal">address_space(N)</tt>, <tt class="docutils literal">external_only</tt>, and
<tt class="docutils literal">unmangled</tt>. The macro <tt class="docutils literal">ISPC_ATTRIBUTE_SUPPORTED</tt> is defined if the ISPC
compiler supports attribute syntax. Please refer to the <a class="reference internal" href="#attributes">Attributes</a> section
for more details and the full list of supported attributes.</p>
<p>This release introduces support for the <tt class="docutils literal"><span class="pre">-ffunction-sections</span></tt> command-line
flag, which generates each function in a separate section. This flag is useful
for reducing the size of the final executable by removing unused functions.
Please refer to the <a class="reference internal" href="#basic-command-line-options">Basic Command-line Options</a> section for more details.</p>
<p>In some cases, such as shared libraries, the <tt class="docutils literal"><span class="pre">-ffunction-sections</span></tt> flag alone
may not be sufficient to remove unused ISPC copies of exported functions.  To
address this, you can use the <tt class="docutils literal">external_only</tt> function attribute.  This
attribute can only be applied to exported functions and instructs the compiler
to remove the ISPC version of the function.  For more information, please refer
to the <a class="reference internal" href="#attributes">Attributes</a> and <a class="reference internal" href="#functions-and-function-calls">Functions and Function Calls</a> sections.</p>
<p>Template support for short vectors and array declarations has been extended.
You can now use both type and non-type parameters to specify the type and
dimensions of these types.</p>
<p>For ARM targets, IEEE 754-compliant instructions (<tt class="docutils literal">fminnm</tt> and <tt class="docutils literal">vminnm</tt>) are
now generated for min/max operations, replacing the previous use of <tt class="docutils literal">fmin</tt> and
<tt class="docutils literal">vmin</tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">avx512knl-x16</span></tt>, <tt class="docutils literal"><span class="pre">gen9-x8</span></tt>, and <tt class="docutils literal"><span class="pre">gen9-x16</span></tt> targets are deprecated and
will be removed in future releases.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-26-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.26.0</h2>
<p>There are breaking changes to ARM support:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">--arch=arm</span></tt> flag, which previously mapped to ARMv7 (32-bit), now maps
to ARMv8 (32-bit). There are no changes to <tt class="docutils literal"><span class="pre">--arch=aarch64</span></tt>, which continues
to map to ARMv8 (64-bit).</li>
<li>The CPU definitions for the ARMv7 architecture have been removed:
<tt class="docutils literal"><span class="pre">cortex-a9</span></tt> and <tt class="docutils literal"><span class="pre">cortex-a15</span></tt>.</li>
<li>New CPU definitions have been introduced, including <tt class="docutils literal"><span class="pre">cortex-a55</span></tt>,
<tt class="docutils literal"><span class="pre">cortex-a78</span></tt>, <tt class="docutils literal"><span class="pre">cortex-a510</span></tt>, and <tt class="docutils literal"><span class="pre">cortex-a520</span></tt>, along with support for
new Apple devices.</li>
<li>New double-pumped targets have been introduced: <tt class="docutils literal"><span class="pre">neon-i16x16</span></tt> and
<tt class="docutils literal"><span class="pre">neon-i8x32</span></tt>.</li>
</ul>
<p>Language Updates:</p>
<ul class="simple">
<li>Macro definitions for the LLVM version that ISPC is based on have been added.
Please refer to <a class="reference internal" href="#the-preprocessor">The Preprocessor</a> for more details.</li>
<li>The <tt class="docutils literal"><span class="pre">__attribute__((deprecated))</span></tt> attribute can now be applied to a function
to mark it as deprecated, generating a warning when the function is called.</li>
</ul>
<p>Compiler flags changes:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">--nocpp</span></tt> command-line flag is deprecated and will be removed in a
future release.</li>
<li>The target <tt class="docutils literal"><span class="pre">avx512knl-x16</span></tt> has been removed.</li>
<li>The <tt class="docutils literal"><span class="pre">--darwin-version-min</span></tt> option has been added to specify the minimum
deployment target version for macOS and iOS applications. This addresses a new
linker behavior introduced in Xcode 15.0, which issues a warning when no
version is provided.</li>
</ul>
<p>The behavior of user programs when no supported ISA is detected in the
auto-dispatch code has changed. Instead of raising the <tt class="docutils literal">SIGABRT</tt> signal, the
system will now raise <tt class="docutils literal">SIGILL</tt>.  This affects users who rely on <tt class="docutils literal">SIGABRT</tt> in
their signal handlers for error handling or recovery.  Such users must update
their code to handle <tt class="docutils literal">SIGILL</tt> instead. This change improves predictability and
removes the dispatcher's reliance on the C standard library.</p>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-27-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.27.0</h2>
<p>New targets:</p>
<p>New targets have been added for platforms supporting Intel® Advanced Vector
Extensions 10.2: <tt class="docutils literal"><span class="pre">avx10.2-x4</span></tt>, <tt class="docutils literal"><span class="pre">avx10.2-x8</span></tt>, <tt class="docutils literal"><span class="pre">avx10.2-x16</span></tt>,
<tt class="docutils literal"><span class="pre">avx10.2-x32</span></tt>, and <tt class="docutils literal"><span class="pre">avx10.2-x64</span></tt>.  Additionally, a new macro
<tt class="docutils literal">ISPC_TARGET_AVX10_2</tt> has been introduced.</p>
<p>Standard library:</p>
<ul class="simple">
<li>Cross-lane operations - <tt class="docutils literal">broadcast</tt>, <tt class="docutils literal">rotate</tt>, <tt class="docutils literal">shift</tt>, and
<tt class="docutils literal">shuffle</tt> - are now supported for unsigned types.</li>
<li>ISPC's data handling capabilities have been extended to include signed and
unsigned <tt class="docutils literal">int8</tt> and <tt class="docutils literal">int16</tt> types in the reduction functions.</li>
<li>Support for <tt class="docutils literal">packed_load</tt> and <tt class="docutils literal">packed_store</tt> operations has also been
expanded to include: <tt class="docutils literal">int8</tt>, <tt class="docutils literal">int16</tt> (signed/unsigned), <tt class="docutils literal">float16</tt>,
<tt class="docutils literal">float</tt>, and <tt class="docutils literal">double</tt>.</li>
<li>The cube root function <tt class="docutils literal">cbrt</tt> has been added to the standard library for
<tt class="docutils literal">float</tt> and <tt class="docutils literal">double</tt> types.</li>
<li>Dot product functionality has been enhanced with mixed signedness support for
16-bit integers. The following input combinations are now supported: u16 x u16
(unsigned x unsigned), i16 x i16 (signed x signed), u16 x i16 (mixed
signedness). For consistency with other naming conventions, the function
<tt class="docutils literal">dot2add_i16_packed</tt> has been renamed to <tt class="docutils literal">dot2add_i16i16_packed</tt>.</li>
</ul>
<p>New standard library functions for short vectors:</p>
<p>The <tt class="docutils literal">max</tt>, <tt class="docutils literal">min</tt> and <tt class="docutils literal">abs</tt> functions for short vectors of basic types
have been added to the standard library. They support both uniform and varying
short vector types for all basic types supported by the corresponding standard
functions, i.e., signed and unsigned integer types and floating-point types.</p>
<p>It makes it possible, for example, to find the maximum value between two short
vectors:</p>
<pre class="literal-block">
uniform int&lt;3&gt; a = {1, 2, 3};
uniform int&lt;3&gt; b = {3, -2, 1};
uniform int&lt;3&gt; c = max(a, b); // c = {3, 2, 3}

varying float&lt;4&gt; x, y;
varying float&lt;4&gt; z = max(x, y);
</pre>
<p>Support for short vector types has also been added for the following
floating-point element-wise functions: <tt class="docutils literal">round</tt>, <tt class="docutils literal">floor</tt>, <tt class="docutils literal">ceil</tt>,
<tt class="docutils literal">trunc</tt>, <tt class="docutils literal">rcp</tt>, <tt class="docutils literal">rcp_fast</tt>, <tt class="docutils literal">sqrt</tt>, <tt class="docutils literal">rsqrt</tt>, <tt class="docutils literal">sin</tt>, <tt class="docutils literal">asin</tt>,
<tt class="docutils literal">cos</tt>, <tt class="docutils literal">acos</tt>, <tt class="docutils literal">tan</tt>, <tt class="docutils literal">atan</tt>, <tt class="docutils literal">exp</tt>, <tt class="docutils literal">log</tt>, <tt class="docutils literal">atan2</tt>, <tt class="docutils literal">pow</tt> and
<tt class="docutils literal">cbrt</tt>.</p>
<p>Language changes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">aligned(N)</tt> attribute is now available to specify the alignment of
variables and struct types.</li>
<li>A bug was fixed where unsigned array indices or pointer arithmetic with
unsigned offsets could result in overflow due to sign extension when promoting
to pointer size. This issue is now resolved, and the compiler correctly
handles unsigned integer indexing and pointer arithmetic.</li>
</ul>
<p>Compiler flags changes:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">-dD</span></tt> and <tt class="docutils literal"><span class="pre">-dM</span></tt> flags are now supported. They are useful for debugging the
preprocessor and checking the macros defined by the compiler.</li>
</ul>
</div>
<div class="section" id="updating-ispc-programs-for-changes-in-ispc-1-28-0">
<h2>Updating ISPC Programs For Changes In ISPC 1.28.0</h2>
<p>New Features:</p>
<ul class="simple">
<li>Added a new command-line option <tt class="docutils literal"><span class="pre">--include-float16-conversions</span></tt>. This
option makes the compiler include float16 conversion functions in the
compiled module. This is useful for targets that do not have native
instructions for float16 conversions, such as x86 targets prior to AVX2.
This option is disabled by default.</li>
<li>ISPC can now generate nanobind wrappers for ISPC modules, allowing easy
and lightweight integration of ISPC code with Python. The generated wrappers
can be built into native Python modules and imported into Python code. The
<tt class="docutils literal"><span class="pre">--nanobind-wrapper=&lt;filename&gt;</span></tt> command-line option enables this feature.</li>
<li>Struct operator overloading has been extended. Extended support for
overloading unary (<tt class="docutils literal">++</tt>, <tt class="docutils literal"><span class="pre">--</span></tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">!</tt>, <tt class="docutils literal">~</tt>), binary (<tt class="docutils literal">*</tt>,
<tt class="docutils literal">/</tt>, <tt class="docutils literal">%</tt>, <tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">&gt;&gt;</tt>, <tt class="docutils literal">&lt;&lt;</tt>, <tt class="docutils literal">==</tt>, <tt class="docutils literal">!=</tt>, <tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&gt;</tt>,
<tt class="docutils literal">&lt;=</tt>, <tt class="docutils literal">&gt;=</tt>, <tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt>), and assignment
(<tt class="docutils literal">=</tt>, <tt class="docutils literal">+=</tt>, <tt class="docutils literal"><span class="pre">-=</span></tt> , <tt class="docutils literal">*=</tt>, <tt class="docutils literal">/=</tt>, <tt class="docutils literal">%=</tt>, <tt class="docutils literal">&lt;&lt;=</tt>, <tt class="docutils literal">&gt;&gt;=</tt>, <tt class="docutils literal">&amp;=</tt>,
<tt class="docutils literal">|=</tt>, <tt class="docutils literal">^=</tt>) operators for struct types.</li>
<li>ISPC can now be used as a C++ library (<tt class="docutils literal">libispc</tt>) for embedding ISPC
compilation directly into applications. It now also provides CMake
configuration files for easy integration into other CMake projects. The
library includes experimental Just-In-Time (JIT) compilation capabilities
for runtime code generation and execution. See the section
<a class="reference internal" href="#using-ispc-as-a-library">Using ISPC as a Library</a> for more details.</li>
<li>Added a new <tt class="docutils literal">include/intrinsics</tt> directory containing header files that
implement selected SSE intrinsics in ISPC. If you're porting existing code
from intrinsics to ISPC, you can use these headers as a reference.</li>
</ul>
<p>Language and Syntax Changes:</p>
<ul class="simple">
<li>Integer literals are now stricter:<ul>
<li>Limits the number of occurrences of <tt class="docutils literal">[uUlL]</tt> symbols (e.g., <tt class="docutils literal">ulll</tt>,
<tt class="docutils literal">uul</tt>, and <tt class="docutils literal">lulu</tt> are not valid anymore).</li>
<li>The value modification suffix (i.e., <tt class="docutils literal">[kMG]</tt>) must precede the type
modification suffix (i.e., <tt class="docutils literal">[uUlL]</tt> symbols).</li>
<li>Like C/C++, <tt class="docutils literal">lL</tt> and <tt class="docutils literal">Ll</tt> suffixes are no longer allowed (i.e., mixing
lower- and upper-case <tt class="docutils literal">L</tt> to form a <tt class="docutils literal">LL</tt> suffix).</li>
</ul>
</li>
</ul>
<p>Standard Library Changes:</p>
<ul>
<li><p class="first"><tt class="docutils literal">select</tt> functions now support unsigned integer types <tt class="docutils literal">uint8</tt>,
<tt class="docutils literal">uint16</tt>, <tt class="docutils literal">uint32</tt>, and <tt class="docutils literal">uint64</tt> as well as uniform short vectors.</p>
</li>
<li><p class="first">Added new functions: <tt class="docutils literal">isinf</tt>, <tt class="docutils literal">isfinite</tt>, and <tt class="docutils literal">srgb8_to_float</tt>.</p>
</li>
<li><p class="first">Standard library functions for short vectors have been moved to a separate
header file <tt class="docutils literal">short_vec.isph</tt>. They are no longer defined implicitly for
every file compiled with ISPC. Code using such functions should now include
this file with:</p>
<pre class="literal-block">
#include &quot;short_vec.isph&quot;
</pre>
</li>
<li><p class="first">Support for short vector types has been added to the following element-wise
functions: <tt class="docutils literal">fmod</tt>, <tt class="docutils literal">isnan</tt>, <tt class="docutils literal">rsqrt_fast</tt>, and <tt class="docutils literal">clamp</tt>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="getting-started-with-ispc">
<h1>Getting Started with ISPC</h1>
<div class="section" id="installing-ispc">
<h2>Installing ISPC</h2>
<p>The <a class="reference external" href="http://ispc.github.io/downloads.html">ispc downloads web page</a> has prebuilt executables for Windows*,
Linux* and macOS* available for download.  Alternatively, you can
download the source code from that page and build it yourself; see the
<a class="reference external" href="http://github.com/ispc/ispc/wiki">ispc wiki</a> for instructions about building <tt class="docutils literal">ispc</tt> from source.</p>
<p>Once you have an executable for your system, copy it into a directory
that's in your <tt class="docutils literal">PATH</tt>.  Congratulations--you've now installed <tt class="docutils literal">ispc</tt>.</p>
</div>
<div class="section" id="compiling-and-running-a-simple-ispc-program">
<h2>Compiling and Running a Simple ISPC Program</h2>
<p>The directory <tt class="docutils literal">examples/simple</tt> in the <tt class="docutils literal">ispc</tt> distribution includes a
simple example of how to use <tt class="docutils literal">ispc</tt> with a short C++ program.  See the
file <tt class="docutils literal">simple.ispc</tt> in that directory (also reproduced here.)</p>
<pre class="literal-block">
export void simple(uniform float vin[], uniform float vout[],
                   uniform int count) {
    foreach (index = 0 ... count) {
        float v = vin[index];
        if (v &lt; 3.)
            v = v * v;
        else
            v = sqrt(v);
        vout[index] = v;
    }
}
</pre>
<p>This program loops over an array of values in <tt class="docutils literal">vin</tt> and computes an
output value for each one.  For each value in <tt class="docutils literal">vin</tt>, if its value is less
than three, the output is the value squared, otherwise it's the square root
of the value.</p>
<p>The first thing to notice in this program is the presence of the <tt class="docutils literal">export</tt>
keyword in the function definition; this indicates that the function should
be made available to be called from application code.  The <tt class="docutils literal">uniform</tt>
qualifiers on the parameters to <tt class="docutils literal">simple</tt> indicate that the corresponding
variables are non-vector quantities--this concept is discussed in detail in the
<a class="reference internal" href="#uniform-and-varying-qualifiers">&quot;uniform&quot; and &quot;varying&quot; Qualifiers</a> section.</p>
<p>Each iteration of the <tt class="docutils literal">foreach</tt> loop works on a number of input values in
parallel--depending on the compilation target chosen, it may be 4, 8, 16, 32, or
even 64 elements of the <tt class="docutils literal">vin</tt> array, processed efficiently with the CPU's or
GPU's SIMD hardware.  Here, the variable <tt class="docutils literal">index</tt> takes all values from 0 to
<tt class="docutils literal"><span class="pre">count-1</span></tt>.  After the load from the array to the variable <tt class="docutils literal">v</tt>, the
program can then proceed, doing computation and control flow based on the
values loaded.  The result from the running program instances is written to
the <tt class="docutils literal">vout</tt> array before the next iteration of the <tt class="docutils literal">foreach</tt> loop runs.</p>
<p>To build and run examples, go to the <tt class="docutils literal">examples</tt> directory and create a <tt class="docutils literal">build</tt> folder.
Run <tt class="docutils literal">cmake <span class="pre">-DISPC_EXECUTABLE=&lt;path_to_ispc_binary&gt;</span> ../</tt>. On Linux* and
macOS*, the makefile will be generated in that directory. On Windows*,
Microsoft Visual Studio solution <tt class="docutils literal">ispc_examples.sln</tt> will be created. In
either case, build it now! We'll walk through the details of the compilation
steps in the following section, <a class="reference internal" href="#using-the-ispc-compiler">Using The ISPC Compiler</a>.)  In addition to
compiling the <tt class="docutils literal">ispc</tt> program, in this case the <tt class="docutils literal">ispc</tt> compiler also
generates a small header file, <tt class="docutils literal">simple.h</tt>.  This header file includes the
declaration for the C-callable function that the above <tt class="docutils literal">ispc</tt> program is
compiled to.  The relevant parts of this file are:</p>
<pre class="literal-block">
#ifdef __cplusplus
extern &quot;C&quot; {
#endif // __cplusplus
    extern void simple(float vin[], float vout[], int32_t count);
#ifdef __cplusplus
}
#endif // __cplusplus
</pre>
<p>It's not mandatory to <tt class="docutils literal">#include</tt> the generated header file in your C/C++
code (you can alternatively use a manually-written <tt class="docutils literal">extern</tt> declaration
of the <tt class="docutils literal">ispc</tt> functions you use), but it's a helpful check to ensure that
the function signatures are as expected on both sides.</p>
<p>Here is the main program, <tt class="docutils literal">simple.cpp</tt>, which calls the <tt class="docutils literal">ispc</tt> function
above.</p>
<pre class="literal-block">
#include &lt;stdio.h&gt;
#include &quot;simple.h&quot;

int main() {
    float vin[16], vout[16];
    for (int i = 0; i &lt; 16; ++i)
        vin[i] = i;

    simple(vin, vout, 16);

    for (int i = 0; i &lt; 16; ++i)
        printf(&quot;%d: simple(%f) = %f\n&quot;, i, vin[i], vout[i]);
}
</pre>
<p>Note that the call to the <tt class="docutils literal">ispc</tt> function in the middle of <tt class="docutils literal">main()</tt> is
a regular function call.  (And it has the same overhead as a C/C++ function
call, for that matter.)</p>
<p>When the executable <tt class="docutils literal">simple</tt> runs, it generates the expected output:</p>
<pre class="literal-block">
0: simple(0.000000) = 0.000000
1: simple(1.000000) = 1.000000
2: simple(2.000000) = 4.000000
3: simple(3.000000) = 1.732051
...
</pre>
<p>For a slightly more complex example of using <tt class="docutils literal">ispc</tt>, see the <a class="reference external" href="http://ispc.github.io/example.html">Mandelbrot
set example</a> page on the <tt class="docutils literal">ispc</tt> website for a walk-through of an <tt class="docutils literal">ispc</tt>
implementation of that algorithm.  After reading through that example, you
may want to examine the source code of the various examples in the
<tt class="docutils literal">examples/</tt> directory of the <tt class="docutils literal">ispc</tt> distribution.</p>
</div>
</div>
<div class="section" id="using-the-ispc-compiler">
<h1>Using The ISPC Compiler</h1>
<p>To go from an <tt class="docutils literal">ispc</tt> source file to an object file that can be linked
with application code, enter the following command</p>
<pre class="literal-block">
ispc foo.ispc -o foo.o
</pre>
<p>(On Windows, you may want to specify <tt class="docutils literal">foo.obj</tt> as the output filename.)</p>
<div class="section" id="basic-command-line-options">
<h2>Basic Command-line Options</h2>
<p>The <tt class="docutils literal">ispc</tt> executable can be run with <tt class="docutils literal"><span class="pre">--help</span></tt> to print a list of
accepted command-line arguments.  By default, the compiler compiles the
provided program (and issues warnings and errors), but doesn't
generate any output.</p>
<p>If the <tt class="docutils literal"><span class="pre">-o</span></tt> flag is given, it will generate an output file (a native
object file by default).</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj
</pre>
<p>To generate a text assembly file, pass <tt class="docutils literal"><span class="pre">--emit-asm</span></tt>:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.s --emit-asm
</pre>
<p>To generate LLVM bitcode, use the <tt class="docutils literal"><span class="pre">--emit-llvm</span></tt> flag.
To generate LLVM bitcode in textual form, use the <tt class="docutils literal"><span class="pre">--emit-llvm-text</span></tt> flag.</p>
<p>To run only the preprocessor, use the <tt class="docutils literal"><span class="pre">-E</span></tt> flag.</p>
<pre class="literal-block">
ispc foo.ispc -E -o foo.i
ispc foo.ispc -E -o foo.ispi
</pre>
<p>In this mode, the output will be directed to <tt class="docutils literal">stdout</tt> if no output file is
specified.  The standard suffixes <tt class="docutils literal">.i</tt> or <tt class="docutils literal">.ispi</tt> are assumed for preprocessor output.</p>
<p>By default, the compilation will fail if the preprocessor encounters an error.
To ignore the preprocessor errors and proceed with normal compilation flow,
<tt class="docutils literal"><span class="pre">--ignore-preprocessor-errors</span></tt> switch may be used.</p>
<p>To debug preprocessor, use <tt class="docutils literal"><span class="pre">-dD</span></tt> or <tt class="docutils literal"><span class="pre">-dM</span></tt> flags. The <tt class="docutils literal"><span class="pre">-dM</span></tt> flag lists
<tt class="docutils literal">#define</tt> directives for all the macros during the execution of the
preprocessor, including predefined macros, instead of the normal output. The
<tt class="docutils literal"><span class="pre">-dD</span></tt> flag lists both the <tt class="docutils literal">#define</tt> directives and the result of
preprocessing.</p>
<p>Optimizations are on by default; they can be turned off with <tt class="docutils literal"><span class="pre">-O0</span></tt>:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj -O0
</pre>
<p>There is support for generating debugging symbols; this is enabled with the
<tt class="docutils literal"><span class="pre">-g</span></tt> command-line flag.  Using <tt class="docutils literal"><span class="pre">-g</span></tt> doesn't affect optimization level;
to debug unoptimized code pass <tt class="docutils literal"><span class="pre">-O0</span></tt> flag.</p>
<p>The <tt class="docutils literal"><span class="pre">-h</span></tt> flag can also be used to direct <tt class="docutils literal">ispc</tt> to generate a C/C++
header file that includes C/C++ declarations of the C-callable <tt class="docutils literal">ispc</tt>
functions and the types passed to it.</p>
<p>The <tt class="docutils literal"><span class="pre">-D</span></tt> option can be used to specify definitions to be passed along to
the pre-processor, which runs over the program input before it's compiled.
For example, including <tt class="docutils literal"><span class="pre">-DTEST=1</span></tt> defines the pre-processor symbol
<tt class="docutils literal">TEST</tt> to have the value <tt class="docutils literal">1</tt> when the program is compiled.</p>
<p>The compiler issues a number of performance warnings for code constructs
that compile to relatively inefficient code.  These warnings can be
silenced with the <tt class="docutils literal"><span class="pre">--wno-perf</span></tt> flag (or by using <tt class="docutils literal"><span class="pre">--woff</span></tt>, which turns
off all compiler warnings.)  Furthermore, <tt class="docutils literal"><span class="pre">--werror</span></tt> can be provided to
direct the compiler to treat any warnings as errors.</p>
<p>The <tt class="docutils literal"><span class="pre">--pic</span></tt> flag can be used to generate position-independent code suitable
for use in a shared library. The <tt class="docutils literal"><span class="pre">--PIC</span></tt> flag can be used to generate
position-independent code suitable for dynamic linking avoiding any limit on
the size of the global offset table. When no <tt class="docutils literal"><span class="pre">--pic</span></tt> or <tt class="docutils literal"><span class="pre">--PIC</span></tt> flag is
provided, the compiler enforces target-specific default behavior.</p>
<p>The <tt class="docutils literal"><span class="pre">-ffunction-sections</span></tt> flag can be used to generate each function in a
separate section. This flag is useful for reducing the size of the final
executable by removing unused functions when it is combined with linker flag
that removes unused sections: <tt class="docutils literal"><span class="pre">--gc-sections</span></tt> for <tt class="docutils literal">GNU ld</tt> and <tt class="docutils literal">/OPT:REF</tt>
for <tt class="docutils literal">MSVC link.exe</tt>. On macOS, this flag does not have any effect (as in
clang) because dead stripping <tt class="docutils literal"><span class="pre">-dead_strip</span></tt> for <tt class="docutils literal">ld64</tt> works differently.
The <tt class="docutils literal"><span class="pre">-fno-function-sections</span></tt> disables this behavior.</p>
<p>The <tt class="docutils literal"><span class="pre">--darwin-version-min</span></tt> option was added to specify the minimum deployment
target version for macOS and iOS applications addressing the new linker
introduced in Xcode 15.0 that issues a warning when no version is provided.
The version should be specified in the format <tt class="docutils literal">[major.minor]</tt>. When an empty
string (&quot;&quot;) is passed, no minimum version will be specified in the output binary.</p>
<p>The <tt class="docutils literal"><span class="pre">--nanobind-wrapper=&lt;filename&gt;</span></tt> option can be used to generate a
<tt class="docutils literal">nanobind</tt> wrapper for the ISPC module. This allows easy and lightweight
integration of ISPC code into Python. The generated wrapper can be built into a
native Python module and imported into Python code. During wrapper generation,
we assume the following:</p>
<ul class="simple">
<li>All pointer types are treated as numpy arrays: both <tt class="docutils literal">TYPE*</tt> and <tt class="docutils literal">TYPE[]</tt>
map to <tt class="docutils literal"><span class="pre">nb::ndarray</span></tt></li>
<li>.data() method returns compatible pointer</li>
<li><tt class="docutils literal">nanobind</tt> headers and library are required to build the wrapper.</li>
</ul>
<p>See <a class="reference external" href="https://nanobind.readthedocs.io/en/latest/">nanobind</a> and <a class="reference external" href="https://numpy.org/doc/stable/">numpy</a> documentation for more details.</p>
</div>
<div class="section" id="selecting-the-compilation-target">
<h2>Selecting The Compilation Target</h2>
<p>There are four options that affect the compilation target: <tt class="docutils literal"><span class="pre">--arch</span></tt>,
which sets the target architecture, <tt class="docutils literal"><span class="pre">--device</span></tt> (also may be spelled as <tt class="docutils literal"><span class="pre">--cpu</span></tt>),
which sets the target CPU or GPU, <tt class="docutils literal"><span class="pre">--target</span></tt>, which sets the target instruction
set, and <tt class="docutils literal"><span class="pre">--target-os</span></tt>, which sets the target operating system.</p>
<p>If none of these options is specified, <tt class="docutils literal">ispc</tt> generates code for the host
OS and for the architecture of the system the compiler is running on (i.e.
64-bit x86-64 (<tt class="docutils literal"><span class="pre">--arch=x86-64</span></tt>) on x86 systems and ARM NEON on ARM systems).</p>
<p>To compile to a 32-bit x86 target, for example, supply <tt class="docutils literal"><span class="pre">--arch=x86</span></tt> on
the command line:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj --arch=x86
</pre>
<p>To compile for Intel Xe LP platform:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.bin --target=xelp-x16 --device=tgllp --emit-zebin
</pre>
<p>Currently-supported architectures are <tt class="docutils literal">x86</tt>, <tt class="docutils literal"><span class="pre">x86-64</span></tt>, <tt class="docutils literal">xe64</tt>,
<tt class="docutils literal">arm</tt>, and <tt class="docutils literal">aarch64</tt>.</p>
<p>The target CPU determines both the default instruction set used as well as
which CPU architecture the code is tuned for.  <tt class="docutils literal">ispc <span class="pre">--help</span></tt> provides a
list of all of the supported CPUs.  By default, the CPU type of the system
on which you're running <tt class="docutils literal">ispc</tt> is used to determine the target CPU.</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj --device=corei7-avx
</pre>
<p>Next, <tt class="docutils literal"><span class="pre">--target</span></tt> selects the target instruction set.  For targets without
hardware support for masking, the target string is of the form <tt class="docutils literal"><span class="pre">[ISA]-i[mask</span> size]x[gang size]</tt>.
For example, <tt class="docutils literal"><span class="pre">--target=avx2-i32x16</span></tt> specifies a target with the AVX2 instruction set,
a mask size of 32 bits, and a gang size of 16.  For targets with hardware masking support,
which are AVX-512 and GPU targets, the target string is of the form
<tt class="docutils literal"><span class="pre">[ISA]-x[gang</span> size]</tt>.  For example, <tt class="docutils literal"><span class="pre">--target=xehpg-x16</span></tt> specifies Intel XeHPG
as a target ISA and defines a gang size of 16.</p>
<p>By default, the target instruction set is chosen based on the most capable
one supported by the system on which you're running <tt class="docutils literal">ispc</tt>.  In this case a warning
will be issued noting the target used for compilation.  It is recommended to
always use <tt class="docutils literal"><span class="pre">--target</span></tt> switch to explicitly specify the target.</p>
<p>To get the complete list of supported targets, please use <tt class="docutils literal"><span class="pre">--help</span></tt> switch
and note the list in the description of <tt class="docutils literal"><span class="pre">--target</span></tt>, or use <tt class="docutils literal"><span class="pre">--support-matrix</span></tt>
switch, which will give the complete information of supported combinations
of target, arch and target OS.</p>
<p>The following CPU targets are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="26%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">CPU target</th>
<th class="head">SIMD instruction set</th>
<th class="head">First-CPU codename to support the target</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>sse2</td>
<td>SSE2</td>
<td>Intel Pentium 4 (2001), AMD Athlon 64 (2003)</td>
</tr>
<tr><td>sse4.1</td>
<td>SSE4.1</td>
<td>Intel Penryn (2007), AMD Bulldozer/Jaguar (2011/2013)</td>
</tr>
<tr><td>sse4.2</td>
<td>SSE4.2</td>
<td>Intel Nehalem (2008), AMD Bulldozer/Jaguar (2011/2013)</td>
</tr>
<tr><td>avx, avx1</td>
<td>AVX</td>
<td>Intel Sandy Bridge (2011), AMD Bulldozer/Jaguar (2011/2013)</td>
</tr>
<tr><td>avx2</td>
<td>AVX2</td>
<td>Intel Haswell (2013) <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>, AMD Excavator (2015)</td>
</tr>
<tr><td>avx2vnni</td>
<td>AVX2</td>
<td>Intel Alder Lake (2021), AMD Zen5 (2024)</td>
</tr>
<tr><td>avx512skx</td>
<td>AVX-512</td>
<td>Intel Skylake Xeon (2017), AMD Zen4 (2022)</td>
</tr>
<tr><td>avx512icl</td>
<td>AVX-512</td>
<td>Intel Icelake (2019), AMD Zen4 (2022)</td>
</tr>
<tr><td>avx512spr</td>
<td>AVX-512</td>
<td>Intel Sapphire Rapids (2023)</td>
</tr>
<tr><td>avx10.2</td>
<td>AVX10.2</td>
<td>Intel Diamond Rapids (2026+)</td>
</tr>
<tr><td>neon</td>
<td>ARMv8 NEON</td>
<td>ARM Cortex-A35/A53/A57 (2012-2015)</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>This exclude models branded as Celeron and Pentium (starting with
Tiger Lake 2020 CPUs and newer).</td></tr>
</tbody>
</table>
<p>For more information about the AVX-512 targets, please read this <a class="reference external" href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-512_CPU_compatibility_table">AVX-512 CPU compatibility table</a></p>
<p>The following GPU targets are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="26%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">GPU target</th>
<th class="head">GPU microarchitecture</th>
<th class="head">First-GPU codename to support the target</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>gen9</td>
<td>Intel Gen9</td>
<td>Intel Skylake iGPU (2015)</td>
</tr>
<tr><td>xelp</td>
<td>Intel XeLP</td>
<td>Intel Tiger Lake LP iGPU (2020)</td>
</tr>
<tr><td>xehpg</td>
<td>Intel XeHPG</td>
<td>Intel Arc Alchemist GPU (2022)</td>
</tr>
<tr><td>xehpc</td>
<td>Intel XeHPC</td>
<td>Intel Ponte Vecchio GPU (2022)</td>
</tr>
<tr><td>xelpg</td>
<td>Intel XeLPG</td>
<td>Intel Meteor Lake iGPU (2023)</td>
</tr>
<tr><td>xe2hpg</td>
<td>Intel Xe2HPG</td>
<td>Intel Battlemage GPU (2024)</td>
</tr>
<tr><td>xe2lpg</td>
<td>Intel Xe2LPG</td>
<td>Intel Lunar Lake iGPU (2024)</td>
</tr>
</tbody>
</table>
<p>The other following targets are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="26%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Target</th>
<th class="head">Description</th>
<th class="head">Hardware to support the target</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>generic</td>
<td>Platform-agnostic</td>
<td>Any compatible CPU/GPU</td>
</tr>
</tbody>
</table>
<p>Consult your CPU's manual for specifics on which vector instruction set it
supports.</p>
<p>The mask size may be 8, 16, 32, or 64 bits, though not all combinations of ISA
and mask size are supported.  For best performance, the best general
approach is to choose a mask size equal to the size of the most common
data type in your programs.  For example, if most of the computations are done using
32-bit floating-point values, an <tt class="docutils literal">i32</tt> target is appropriate.  However,
if you're mostly doing computation with 8-bit data types, <tt class="docutils literal">i8</tt> is a better choice.</p>
<p>See <a class="reference internal" href="#basic-concepts-program-instances-and-gangs-of-program-instances">Basic Concepts: Program Instances and Gangs of Program Instances</a> for
more discussion of the &quot;gang size&quot; and its implications for program
execution.</p>
<p>The naming scheme for compilation targets changed in August 2013; the
following table shows the relationship between names in the old scheme and
in the new scheme:</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<tbody valign="top">
<tr><td>Target</td>
<td>Former Name</td>
</tr>
<tr><td>avx1-i32x8</td>
<td>avx, avx1</td>
</tr>
<tr><td>avx1-i32x16</td>
<td>avx-x2</td>
</tr>
<tr><td>avx2-i32x8</td>
<td>avx2</td>
</tr>
<tr><td>avx2-i32x16</td>
<td>avx2-x2</td>
</tr>
<tr><td>neon-8</td>
<td>n/a</td>
</tr>
<tr><td>neon-16</td>
<td>n/a</td>
</tr>
<tr><td>neon-32</td>
<td>n/a</td>
</tr>
<tr><td>sse2-i32x4</td>
<td>sse2</td>
</tr>
<tr><td>sse2-i32x8</td>
<td>sse2-x2</td>
</tr>
<tr><td>sse4.2-i32x4</td>
<td>sse4</td>
</tr>
<tr><td>sse4.2-i32x8</td>
<td>sse4-x2</td>
</tr>
<tr><td>sse4.2-i8x16</td>
<td>n/a</td>
</tr>
<tr><td>sse4.2-i16x8</td>
<td>n/a</td>
</tr>
</tbody>
</table>
<p>The full list of supported targets is below.</p>
<p>x86 targets:</p>
<p><tt class="docutils literal"><span class="pre">sse2-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">sse2-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">sse4.1-i8x16</span></tt>, <tt class="docutils literal"><span class="pre">sse4.1-i16x8</span></tt>, <tt class="docutils literal"><span class="pre">sse4.1-i32x4</span></tt>,
<tt class="docutils literal"><span class="pre">sse4.1-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">sse4.2-i8x16</span></tt>, <tt class="docutils literal"><span class="pre">sse4.2-i16x8</span></tt>, <tt class="docutils literal"><span class="pre">sse4.2-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">sse4.2-i32x8</span></tt>,
<tt class="docutils literal"><span class="pre">avx1-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">avx1-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">avx1-i32x16</span></tt>, <tt class="docutils literal"><span class="pre">avx1-i64x4</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i8x32</span></tt>,
<tt class="docutils literal"><span class="pre">avx2-i16x16</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i32x16</span></tt>, <tt class="docutils literal"><span class="pre">avx2-i64x4</span></tt>,
<tt class="docutils literal"><span class="pre">avx2vnni-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">avx2vnni-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">avx2vnni-i32x16</span></tt>,
<tt class="docutils literal"><span class="pre">avx512skx-x4</span></tt>, <tt class="docutils literal"><span class="pre">avx512skx-x8</span></tt>, <tt class="docutils literal"><span class="pre">avx512skx-x16</span></tt>, <tt class="docutils literal"><span class="pre">avx512skx-x32</span></tt>,
<tt class="docutils literal"><span class="pre">avx512skx-x64</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-x4</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-x8</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-x16</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-x32</span></tt>,
<tt class="docutils literal"><span class="pre">avx512icl-x64</span></tt>, <tt class="docutils literal"><span class="pre">avx512spr-x4</span></tt>, <tt class="docutils literal"><span class="pre">avx512spr-x8</span></tt>, <tt class="docutils literal"><span class="pre">avx512spr-x16</span></tt>, <tt class="docutils literal"><span class="pre">avx512spr-x32</span></tt>,
<tt class="docutils literal"><span class="pre">avx512spr-x64</span></tt>.</p>
<p>Neon targets:</p>
<p><tt class="docutils literal"><span class="pre">neon-i8x16</span></tt>, <tt class="docutils literal"><span class="pre">neon-i16x8</span></tt>, <tt class="docutils literal"><span class="pre">neon-i32x4</span></tt>, <tt class="docutils literal"><span class="pre">neon-i32x8</span></tt>, <tt class="docutils literal"><span class="pre">neon-i8x32</span></tt> and <tt class="docutils literal"><span class="pre">neon-i16x16</span></tt>.</p>
<p>These targets correspond to ARMv8 (64-bit) when <tt class="docutils literal"><span class="pre">--arch=aarch64</span></tt> is used (default) and
to ARMv8 (32-bit) when <tt class="docutils literal"><span class="pre">--arch=arm</span></tt> is used.</p>
<p>Xe targets:</p>
<p><tt class="docutils literal"><span class="pre">gen9-x8</span></tt>, <tt class="docutils literal"><span class="pre">gen9-x16</span></tt>, <tt class="docutils literal"><span class="pre">xelp-x8</span></tt>, <tt class="docutils literal"><span class="pre">xelp-x16</span></tt>, <tt class="docutils literal"><span class="pre">xehpg-x8</span></tt>, <tt class="docutils literal"><span class="pre">xehpg-x16</span></tt>, <tt class="docutils literal"><span class="pre">xehpc-x16</span></tt>, <tt class="docutils literal"><span class="pre">xehpc-x32</span></tt>.</p>
<p>Note that <tt class="docutils literal">sse4.1</tt> and <tt class="docutils literal">sse4.2</tt> targets may not be used together in
multi-target compilation. While the auto-dispatch code will correctly detect
the difference between these two ISAs, they both yield a binary with <tt class="docutils literal">sse4</tt>
suffix. This limitation is to maintain backward compatibility with build
systems expecting <tt class="docutils literal">sse4</tt> suffix.</p>
<p>Finally, <tt class="docutils literal"><span class="pre">--target-os</span></tt> selects the target operating system. Depending on
your host <tt class="docutils literal">ispc</tt> may support Windows, Linux, macOS, Android, iOS and PS4/PS5
targets. Running <tt class="docutils literal">ispc <span class="pre">--help</span></tt> and looking at the output for the <tt class="docutils literal"><span class="pre">--target-os</span></tt>
option gives the list of supported targets. By default <tt class="docutils literal">ispc</tt> produces the
code for your host operating system.</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj --target-os=android
</pre>
<p>Note that cross-OS compilation is in the experimental stage. We encourage you to
try it and send us a note with your experiences or to file a bug or feature
requests with the <tt class="docutils literal">ispc</tt> <a class="reference external" href="https://github.com/ispc/ispc/issues?state=open">bug tracker</a>.</p>
</div>
<div class="section" id="selecting-32-or-64-bit-addressing">
<h2>Selecting 32 or 64 Bit Addressing</h2>
<p>By default, <tt class="docutils literal">ispc</tt> uses 32-bit arithmetic for performing addressing
calculations, even when using a 64-bit compilation target like x86-64.
This implementation approach can provide substantial performance benefits
by reducing the cost of addressing calculations.  (Note that pointers
themselves are still maintained as 64-bit quantities for 64-bit targets.)</p>
<p>If you need to be able to address more than 4GB of memory from your
<tt class="docutils literal">ispc</tt> programs, the <tt class="docutils literal"><span class="pre">--addressing=64</span></tt> command-line argument can be
provided to cause the compiler to generate 64-bit arithmetic for addressing
calculations.  Note that it is safe to mix object files where some were
compiled with the default <tt class="docutils literal"><span class="pre">--addressing=32</span></tt> and others were compiled with
<tt class="docutils literal"><span class="pre">--addressing=64</span></tt>.</p>
</div>
<div class="section" id="the-preprocessor">
<h2>The Preprocessor</h2>
<p><tt class="docutils literal">ispc</tt> automatically runs the C preprocessor on your input program before
compiling it.  Thus, you can use <tt class="docutils literal">#ifdef</tt>, <tt class="docutils literal">#define</tt>, and so forth in
your ispc programs.</p>
<p>A number of preprocessor symbols are automatically defined before the
preprocessor runs:</p>
<table border="1" class="docutils">
<caption>Predefined Preprocessor symbols and their values</caption>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr><td>Symbol name</td>
<td>Value</td>
<td>Description</td>
</tr>
<tr><td>ISPC</td>
<td>1</td>
<td>Enables detecting that the <tt class="docutils literal">ispc</tt> compiler is processing the file</td>
</tr>
<tr><td>ISPC_TARGET_{NEON, SSE2, SSE4, AVX, AVX2, AVX512SKX, AVX512ICL, AVX512SPR, AVX10_2}</td>
<td>1</td>
<td>One of these will be set, depending on the compilation target</td>
</tr>
<tr><td>ISPC_POINTER_SIZE</td>
<td>32 or 64</td>
<td>Number of bits used to represent a pointer for the target architecture</td>
</tr>
<tr><td>ISPC_MAJOR_VERSION</td>
<td>&nbsp;</td>
<td>Major version of the <tt class="docutils literal">ispc</tt> compiler/language</td>
</tr>
<tr><td>ISPC_MINOR_VERSION</td>
<td>&nbsp;</td>
<td>Minor version of the <tt class="docutils literal">ispc</tt> compiler/language</td>
</tr>
<tr><td>LLVM_VERSION_MAJOR</td>
<td>&nbsp;</td>
<td>Major version of the LLVM compiler used by <tt class="docutils literal">ispc</tt></td>
</tr>
<tr><td>LLVM_VERSION_MINOR</td>
<td>&nbsp;</td>
<td>Minor version of the LLVM compiler used by <tt class="docutils literal">ispc</tt></td>
</tr>
<tr><td>PI</td>
<td>3.1415926535</td>
<td>Mathematics</td>
</tr>
<tr><td>TARGET_WIDTH</td>
<td>Vector width of the target, e.g., 8 for sse2-i32x8</td>
<td>Can be used for code versioning for static varying initialization</td>
</tr>
<tr><td>TARGET_ELEMENT_WIDTH</td>
<td>Element width in bytes, e.g., 4 for i32</td>
<td>Can be used for code versioning for static varying initialization</td>
</tr>
<tr><td>ISPC_UINT_IS_DEFINED</td>
<td>1</td>
<td>The macro is defined if uint8/uint16/uint32/uint64 types are defined in the <tt class="docutils literal">ispc</tt> (it's defined in 1.13.0 and later)</td>
</tr>
<tr><td>ISPC_ATTRIBUTE_SUPPORTED</td>
<td>1</td>
<td>The macro is defined if the <tt class="docutils literal">ispc</tt> compiler supports <tt class="docutils literal"><span class="pre">__attribute__(())</span></tt> syntax.</td>
</tr>
<tr><td>ISPC_FP16_SUPPORTED</td>
<td>1</td>
<td>The macro is defined if float16 type is supported by the <tt class="docutils literal">ispc</tt> target.
The implementation may rely either on native hardware support or emulation.</td>
</tr>
<tr><td>ISPC_FP64_SUPPORTED</td>
<td>1</td>
<td>The macro is defined if double type is supported by the target</td>
</tr>
<tr><td>ISPC_LLVM_INTRINSICS_ENABLED</td>
<td>1</td>
<td>The macro is defined if LLVM intrinsics support is enabled</td>
</tr>
<tr><td>INT8_MIN, INT16_MIN, INT32_MIN, INT64_MIN</td>
<td>&nbsp;</td>
<td>Minimum value of signed integer types of the corresponding size</td>
</tr>
<tr><td>INT8_MAX, INT16_MAX, INT32_MAX, INT64_MAX</td>
<td>&nbsp;</td>
<td>Maximum value of signed integer types of the corresponding size</td>
</tr>
<tr><td>UINT8_MAX, UINT16_MAX, UINT32_MAX, UINT64_MAX</td>
<td>&nbsp;</td>
<td>Maximum value of unsigned integer types of the corresponding size</td>
</tr>
<tr><td>FLT16_MIN, FLT_MIN, DBL_MIN</td>
<td>&nbsp;</td>
<td>Smallest positive normal number of the corresponding floating-point type</td>
</tr>
<tr><td>FLT16_MAX, FLT_MAX, DBL_MAX</td>
<td>&nbsp;</td>
<td>Largest normal number of the corresponding floating-point type</td>
</tr>
</tbody>
</table>
<p>Others Standard Predefined Macros:</p>
<p><tt class="docutils literal">__FILE__</tt> expands to the name of the current input file, in the form of a C
string constant.</p>
<p><tt class="docutils literal">__LINE__</tt> expands to the current line number in the input file, in the form
of a decimal integer constant.</p>
<p><tt class="docutils literal">__DATE__</tt> expands to a string constant containing the date the preprocessor
was run, e.g., <tt class="docutils literal">&quot;Feb&nbsp; 3 2025&quot;</tt>.</p>
<p><tt class="docutils literal">__TIME__</tt> expands to a string constant containing the time the preprocessor
was run, e.g., <tt class="docutils literal">&quot;13:14:33&quot;</tt>.</p>
<p>Variadic Macros:</p>
<p>Variadic macros are supported in <tt class="docutils literal">ispc</tt>. The <tt class="docutils literal">__VA_ARGS__</tt> and
<tt class="docutils literal">__VA_OPT__</tt> macros are defined inside a variadic macro definition.</p>
<p><tt class="docutils literal">__VA_ARGS__</tt> is a variable argument list macro that represents the arguments
after the last named argument.</p>
<p><tt class="docutils literal"><span class="pre">__VA_OPT__(...)</span></tt> is a function macro that expands to its argument if the
variable argument has any tokens, but if the variable argument does not have
any tokens, the <tt class="docutils literal">__VA_OPT__</tt> expands to nothing.</p>
<p>To illustrate, consider the following example:</p>
<pre class="literal-block">
#define PRINT(fmt, ...) print(fmt, __VA_ARGS__)
#define EPRINT(fmt, ...) print(fmt __VA_OPT__(,) __VA_ARGS__)

void test_va_args() {
    PRINT(&quot;% % %\n&quot;, 0, 1, 2);
    // PRINT(&quot;Hello, World!\n&quot;); is compilation error
    // you can't call PRINT with just string because of trailing comma in
    // macro expansion, call EPRINT with __VA_OPT__(,) instead
    EPRINT(&quot;Hello, World!\n&quot;);
}
</pre>
</div>
<div class="section" id="pragma-directives">
<h2>Pragma Directives</h2>
<p><tt class="docutils literal">ispc</tt> supports the following <tt class="docutils literal">#pragma</tt> directives.</p>
<p><tt class="docutils literal">#pragma ignore warning</tt> directives direct the compiler to ignore compiler warnings for individual lines.</p>
<table border="1" class="docutils">
<caption><tt class="docutils literal">#pragma ignore warning</tt> directives and their functions:</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">#pragma</tt> name</td>
<td>Use</td>
</tr>
<tr><td><tt class="docutils literal">#pragma ignore warning(all)</tt></td>
<td>Turns off all <tt class="docutils literal">ispc</tt> compiler warnings including performance warnings for the following line of code.</td>
</tr>
<tr><td><tt class="docutils literal">#pragma ignore warning(perf)</tt></td>
<td>Turns off only performance warnings for the following line of code.</td>
</tr>
<tr><td><tt class="docutils literal">#pragma ignore warning</tt></td>
<td>Turns off all <tt class="docutils literal">ispc</tt> compiler warnings including performance warnings for the following line of code.</td>
</tr>
</tbody>
</table>
<p>When using <tt class="docutils literal">#pragma ignore warning</tt> before a call to a macro, it suppresses warnings from the expanded macro code.</p>
</div>
<div class="section" id="debugging">
<h2>Debugging</h2>
<p>The <tt class="docutils literal"><span class="pre">-g</span></tt> command-line flag can be supplied to the compiler, which causes
it to generate debugging symbols.  The debug info is emitted in DWARF format
on Linux* and macOS*.  The version of the DWARF can be controlled by
command-line switch <tt class="docutils literal"><span class="pre">--dwarf-version={2,3,4,5}</span></tt>.  On Windows* CodeView format
is used by default (it's natively supported by Microsoft Visual Studio*) but
this switch can force the generation of DWARF format that can be used, e.g.,
together with MinGW generated code.
Running <tt class="docutils literal">ispc</tt> programs in the debugger, setting breakpoints, printing out
variables is just the same as debugging C/C++ programs.  Similarly, you can
directly step up and down the call stack between <tt class="docutils literal">ispc</tt> code and C/C++
code.</p>
<p>One limitation of the current debugging support is that the debugger
provides a window into an entire gang's worth of program instances, rather
than just a single program instance.  (These concepts will be introduced
shortly, in <a class="reference internal" href="#basic-concepts-program-instances-and-gangs-of-program-instances">Basic Concepts: Program Instances and Gangs of Program Instances</a>
). Thus, when a <tt class="docutils literal">varying</tt> variable is printed, the values for
each of the program instances are displayed.  Along similar lines, the path
the debugger follows through program source code passes each statement that
any program instance wants to execute (see <a class="reference internal" href="#control-flow-within-a-gang">Control Flow Within A Gang</a>
for more details on control flow in <tt class="docutils literal">ispc</tt>.)</p>
<p>While debugging, a variable, <tt class="docutils literal">__mask</tt>, is available to provide the
current program execution mask at the current point in the program</p>
<p>Another option for debugging is
to use the <tt class="docutils literal">print</tt> statement for <tt class="docutils literal">printf()</tt> style debugging.  (See
<a class="reference internal" href="#output-functions">Output Functions</a> for more information.)  You can also use the ability to
call back to application code at particular points in the program, passing
a set of variable values to be logged or otherwise analyzed from there.</p>
</div>
<div class="section" id="optimization-settings">
<h2>Optimization Settings</h2>
<p>The <tt class="docutils literal">ispc</tt> compiler has a number of optimization settings that can be
controlled via command-line flags. These options can be specified using the
<cite>--opt=&lt;option&gt;</cite> flag. Below is a list of available optimization options:</p>
<p>Available options:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-assertions</span></tt></p>
<p>Remove assertion statements from the final code. This can reduce the overhead
of runtime checks.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-fma</span></tt></p>
<p>Disable the generation of 'fused multiply-add' (FMA) instructions on targets
that support them.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-gathers</span></tt></p>
<p>Disable the generation of gather instructions on targets that support them.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-loop-unroll</span></tt></p>
<p>Disable loop unrolling.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-scatters</span></tt></p>
<p>Disable the generation of scatter instructions on targets that support them.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">disable-zmm</span></tt></p>
<p>Disable the use of ZMM registers for AVX-512 targets in favor of YMM registers.
This also affects the ABI. ZMM registers are 512-bit wide, while YMM registers
are 256-bit wide.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">fast-masked-vload</span></tt></p>
<p>Enable faster masked vector loads on SSE targets. Note that this may result in
memory accesses beyond the end of an array, which could cause undefined
behavior if not handled carefully.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">fast-math</span></tt></p>
<p>Perform non-IEEE-compliant optimizations of numeric expressions. These
optimizations may improve performance but can result in less precise results
or different behavior compared to IEEE-compliant math.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">force-aligned-memory</span></tt></p>
<p>Always issue &quot;aligned&quot; vector load and store instructions.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">reset-ftz-daz</span></tt></p>
<p>Reset FTZ (Flush-to-Zero) and DAZ (Denormals-Are-Zero) flags on ISPC extern
function entrance and restore them on return.</p>
</li>
</ul>
</div>
<div class="section" id="other-ways-of-passing-arguments-to-ispc">
<h2>Other ways of passing arguments to ISPC</h2>
<p>In addition to specifying arguments on the command line, if the <tt class="docutils literal">ISPC_ARGS</tt>
environment variable has been set it is split into arguments and these arguments
are appended to any provided on the command line.</p>
<p>It is also possible to pass arguments to <tt class="docutils literal">ispc</tt> in a file. If an argument has
the form <tt class="docutils literal">&#64;&lt;filename&gt;</tt>, where <tt class="docutils literal">&lt;filename&gt;</tt> exists and is readable, it is
replaced with the content of the file split into arguments. Note that it <em>is</em>
allowed for a file to contain a further <tt class="docutils literal">&#64;&lt;filename&gt;</tt> argument.</p>
<p>Where a file or environment variable is split into arguments, this is done based on
the arguments being separated by one or more whitespace characters, including tabs
and newlines. There is no means of escaping or quoting a character to allow an
argument to contain a whitespace character.</p>
</div>
</div>
<div class="section" id="using-ispc-as-a-library">
<h1>Using ISPC as a Library</h1>
<p>Starting with ISPC 1.28.0, ISPC can be used as a C++ library (<tt class="docutils literal">libispc</tt>)
to embed ISPC compilation directly into applications. This allows you to
compile ISPC code programmatically.</p>
<div class="section" id="library-initialization">
<h2>Library Initialization</h2>
<p>Before using any ISPC library functions, you must initialize the library:</p>
<pre class="literal-block">
#include &quot;ispc/ispc.h&quot;

int main() {
    // Initialize ISPC library - call once at startup
    if (!ispc::Initialize()) {
        std::cerr &lt;&lt; &quot;Failed to initialize ISPC library\n&quot;;
        return 1;
    }

    // Use ISPC library functions...

    // Shutdown ISPC library - call once at exit
    ispc::Shutdown();
    return 0;
}
</pre>
<p>The <tt class="docutils literal">Initialize()</tt> function initializes the LLVM targets and creates global state.
The <tt class="docutils literal">Shutdown()</tt> function releases all global resources.</p>
</div>
<div class="section" id="simple-compilation-interface">
<h2>Simple Compilation Interface</h2>
<p>The simplest way to compile ISPC code is using <tt class="docutils literal">CompileFromArgs()</tt>:</p>
<pre class="literal-block">
#include &quot;ispc/ispc.h&quot;
#include &lt;vector&gt;
#include &lt;string&gt;

std::vector&lt;std::string&gt; args = {
    &quot;my_program.ispc&quot;,         // Input file
    &quot;--target=host&quot;,           // Target specification
    &quot;-O2&quot;,                     // Optimization level
    &quot;-o&quot;, &quot;my_program.o&quot;,      // Output object file
    &quot;-h&quot;, &quot;my_program.h&quot;       // Output header file
};

int result = ispc::CompileFromArgs(args);
if (result == 0) {
    std::cout &lt;&lt; &quot;Compilation successful\n&quot;;
} else {
    std::cerr &lt;&lt; &quot;Compilation failed\n&quot;;
}
</pre>
<p>All standard ISPC command-line options are supported.</p>
</div>
<div class="section" id="advanced-interface-with-ispcengine">
<h2>Advanced Interface with ISPCEngine</h2>
<p>For more control over the compilation process, use the <tt class="docutils literal">ISPCEngine</tt> class:</p>
<pre class="literal-block">
#include &quot;ispc/ispc.h&quot;

std::vector&lt;std::string&gt; args = {
    &quot;my_program.ispc&quot;, &quot;--target=host&quot;, &quot;-O2&quot;
};

auto engine = ispc::ISPCEngine::CreateFromArgs(args);
if (!engine) {
    std::cerr &lt;&lt; &quot;Failed to create ISPC engine\n&quot;;
    return 1;
}
int result = engine-&gt;Execute();
if (result == 0) {
    std::cout &lt;&lt; &quot;Compilation successful\n&quot;;
}
</pre>
<p>The <tt class="docutils literal">ISPCEngine</tt> allows you to separate argument parsing from execution,
which can be useful for more complex compilation workflows.</p>
</div>
<div class="section" id="just-in-time-jit-compilation-interface">
<h2>Just-In-Time (JIT) Compilation Interface</h2>
<p>ISPC provides Just-In-Time (JIT) compilation capabilities that allow you to
compile ISPC code at runtime and execute it directly in memory without
generating intermediate files. This is useful for applications that need
dynamic code generation or runtime optimization.</p>
<div class="section" id="basic-jit-usage">
<h3>Basic JIT Usage</h3>
<p>Here's a simple example of JIT compilation:</p>
<pre class="literal-block">
#include &quot;ispc/ispc.h&quot;

// Function pointer type for your ISPC function
typedef void (*simple_func_t)(float input[], float output[], int count);

// Initialize ISPC
if (!ispc::Initialize()) {
    std::cerr &lt;&lt; &quot;Failed to initialize ISPC\n&quot;;
    return 1;
}

// Create an engine for JIT compilation
std::vector&lt;std::string&gt; args = {&quot;--target=host&quot;, &quot;-O2&quot;};
auto engine = ispc::ISPCEngine::CreateFromArgs(args);

if (!engine) {
    std::cerr &lt;&lt; &quot;Failed to create ISPC engine\n&quot;;
    return 1;
}

// Compile ISPC file to JIT
int result = engine-&gt;CompileFromFileToJit(&quot;my_program.ispc&quot;);
if (result != 0) {
    std::cerr &lt;&lt; &quot;JIT compilation failed\n&quot;;
    return 1;
}

// Get function pointer from JIT-compiled code
auto func_ptr = engine-&gt;GetJitFunction(&quot;my_function&quot;);
if (!func_ptr) {
    std::cerr &lt;&lt; &quot;Function not found in JIT code\n&quot;;
    return 1;
}

// Cast and call the function
simple_func_t my_function = reinterpret_cast&lt;simple_func_t&gt;(func_ptr);

// Use the function
float input[4] = {1.0f, 2.0f, 3.0f, 4.0f};
float output[4];
my_function(input, output, 4);

// Clean up
ispc::Shutdown();
</pre>
</div>
<div class="section" id="runtime-function-registration">
<h3>Runtime Function Registration</h3>
<p>JIT-compiled ISPC code may need access to runtime functions (like <tt class="docutils literal">ISPCLaunch</tt>,
<tt class="docutils literal">ISPCSync</tt>, <tt class="docutils literal">ISPCAlloc</tt>) for task-based parallel execution. You must register
these functions before compilation:</p>
<pre class="literal-block">
// Define runtime function implementations
void ISPCLaunch(void **handlePtr, void *f, void *d, int count0, int count1, int count2) {
    // Your implementation
}

void ISPCSync(void *handle) {
    // Your implementation
}

void *ISPCAlloc(void **handlePtr, int64_t size, int32_t alignment) {
    // Your implementation
    return aligned_alloc(alignment, size);
}

// Register runtime functions with the JIT engine
if (!engine-&gt;SetJitRuntimeFunction(&quot;ISPCLaunch&quot;, (void*)ISPCLaunch) ||
    !engine-&gt;SetJitRuntimeFunction(&quot;ISPCSync&quot;, (void*)ISPCSync) ||
    !engine-&gt;SetJitRuntimeFunction(&quot;ISPCAlloc&quot;, (void*)ISPCAlloc)) {
    std::cerr &lt;&lt; &quot;Failed to set runtime functions\n&quot;;
    return 1;
}

// Now compile - the JIT code can call these runtime functions
engine-&gt;CompileFromFileToJit(&quot;parallel_program.ispc&quot;);
</pre>
</div>
<div class="section" id="jit-management-functions">
<h3>JIT Management Functions</h3>
<p>The <tt class="docutils literal">ISPCEngine</tt> provides several functions for managing JIT-compiled code:</p>
<ul class="simple">
<li><tt class="docutils literal">CompileFromFileToJit(filename)</tt> - Compile an ISPC file to JIT</li>
<li><tt class="docutils literal">GetJitFunction(name)</tt> - Retrieve a function pointer by name</li>
<li><tt class="docutils literal">SetJitRuntimeFunction(name, ptr)</tt> - Register a runtime function</li>
<li><tt class="docutils literal">ClearJitRuntimeFunction(name)</tt> - Remove a specific runtime function</li>
<li><tt class="docutils literal">ClearJitRuntimeFunctions()</tt> - Remove all runtime functions</li>
<li><tt class="docutils literal">ClearJitCode()</tt> - Clear all JIT-compiled code</li>
</ul>
</div>
<div class="section" id="jit-limitations-and-considerations">
<h3>JIT Limitations and Considerations</h3>
<ul class="simple">
<li><strong>Single Target Only</strong>: JIT compilation only supports single target compilation.
Multi-target compilation will result in an error.</li>
<li><strong>Thread Safety</strong>: JIT compilation is not thread-safe. Use JIT functionality
from a single thread only.</li>
<li><strong>Function Lifetime</strong>: JIT-compiled function pointers remain valid only as long
as the <tt class="docutils literal">ISPCEngine</tt> instance exists. Do not use function pointers after the
engine is destroyed.</li>
<li><strong>Error Handling</strong>: Always check return values and function pointers for null.
JIT compilation can fail for various reasons (syntax errors, missing files, etc.).
Errors and warnings from JIT compilation will be sent to stderr.</li>
<li><strong>Memory Management</strong>: JIT-compiled code uses internal memory management.
Calling <tt class="docutils literal">ClearJitCode()</tt> will invalidate all previously obtained function pointers.</li>
<li><strong>Platform Support</strong>: JIT compilation requires LLVM JIT support and may not be
available on all platforms or build configurations.</li>
</ul>
</div>
</div>
<div class="section" id="compatibility">
<h2>Compatibility</h2>
<p>For compatibility with C-style interfaces, the library also provides
<tt class="docutils literal">argc</tt>/<tt class="docutils literal">argv</tt> variants:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ispc::CompileFromCArgs(int</span> argc, char* <span class="pre">argv[])</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ispc::ISPCEngine::CreateFromCArgs(int</span> argc, char* <span class="pre">argv[])</span></tt></li>
</ul>
<p>These functions have the same behavior as their vector counterparts.</p>
</div>
<div class="section" id="cmake-integration">
<h2>CMake Integration</h2>
<p>ISPC provides CMake configuration files (<tt class="docutils literal">ispcConfig.cmake</tt>) for easy
integration into CMake projects.</p>
<div class="section" id="basic-usage">
<h3>Basic Usage</h3>
<p>After installing ISPC, you can use <tt class="docutils literal">find_package()</tt>:</p>
<pre class="literal-block">
find_package(ispc REQUIRED)

# Link against the ISPC shared library
target_link_libraries(my_target ispc::lib)
</pre>
<p>The <tt class="docutils literal">find_package()</tt> command locates the ISPC installation and imports
the shared library target. The configuration files are installed to
<tt class="docutils literal"><span class="pre">&lt;install_prefix&gt;/lib/cmake/ispc/</span></tt>.</p>
</div>
<div class="section" id="cmake-variables">
<h3>CMake Variables</h3>
<p>The CMake configuration provides these variables:</p>
<ul class="simple">
<li><tt class="docutils literal">ISPC_FOUND</tt> - True if ISPC was found</li>
<li><tt class="docutils literal">ISPC_INCLUDE_DIRS</tt> - Path to ISPC headers (<tt class="docutils literal">include/</tt>)</li>
<li><tt class="docutils literal">ISPC_LIBRARY</tt> - Path to ISPC shared library</li>
<li><tt class="docutils literal">ISPC_EXECUTABLE</tt> - Path to ISPC compiler executable</li>
</ul>
</div>
<div class="section" id="cmake-example">
<h3>CMake Example</h3>
<p>Here's a complete <tt class="docutils literal">CMakeLists.txt</tt> for a project using ISPC as a library:</p>
<pre class="literal-block">
cmake_minimum_required(VERSION 3.15)
project(MyISPCApp)

set(CMAKE_CXX_STANDARD 17)

# Find ISPC library
find_package(ispc REQUIRED)

# Create executable
add_executable(my_app main.cpp)

# Link ISPC library
target_link_libraries(my_app ispc::lib)

# Optional: Print found information
message(STATUS &quot;ISPC found: ${ISPC_FOUND}&quot;)
message(STATUS &quot;ISPC executable: ${ISPC_EXECUTABLE}&quot;)
message(STATUS &quot;ISPC include dirs: ${ISPC_INCLUDE_DIRS}&quot;)
</pre>
</div>
</div>
</div>
<div class="section" id="the-ispc-parallel-execution-model">
<h1>The ISPC Parallel Execution Model</h1>
<p>Though <tt class="docutils literal">ispc</tt> is a C-based language, it is inherently a language for
parallel computation.  Understanding the details of <tt class="docutils literal">ispc</tt>'s parallel
execution model that are introduced in this section is critical for writing
efficient and correct programs in <tt class="docutils literal">ispc</tt>.</p>
<p><tt class="docutils literal">ispc</tt> supports two types of parallelism: task parallelism to parallelize
across multiple processor cores and SPMD parallelism to parallelize across
the SIMD vector lanes on a single core.  Most of this section focuses on
SPMD parallelism, but see <a class="reference internal" href="#tasking-model">Tasking Model</a> at the end of this section for
discussion of task parallelism in <tt class="docutils literal">ispc</tt>.</p>
<p>This section will use some snippets of <tt class="docutils literal">ispc</tt> code to illustrate various
concepts.  Given <tt class="docutils literal">ispc</tt>'s relationship to C, these should be
understandable on their own, but you may want to refer to the <a class="reference internal" href="#the-ispc-language">The ISPC
Language</a> section for details on language syntax.</p>
<div class="section" id="basic-concepts-program-instances-and-gangs-of-program-instances">
<h2>Basic Concepts: Program Instances and Gangs of Program Instances</h2>
<p>Upon entry to an <tt class="docutils literal">ispc</tt> function called from C/C++ code, the execution
model switches from the application's serial model to <tt class="docutils literal">ispc</tt>'s execution
model.  Conceptually, a number of <tt class="docutils literal">ispc</tt> <em>program instances</em> start
running concurrently.  The group of running program instances is
called a <em>gang</em> (a term borrowed from &quot;gang scheduling&quot;, since <tt class="docutils literal">ispc</tt> provides
certain guarantees about control flow coherence among program instances
running in a gang, as detailed in <a class="reference internal" href="#gang-convergence-guarantees">Gang Convergence Guarantees</a>.)  An
<tt class="docutils literal">ispc</tt> program instance is thus similar to a CUDA* &quot;thread&quot; or an OpenCL*
&quot;work-item&quot;, and an <tt class="docutils literal">ispc</tt> gang is similar to a CUDA* &quot;warp&quot;.</p>
<p>An <tt class="docutils literal">ispc</tt> program expresses the computation performed by a gang of
program instances, using an &quot;implicit parallel&quot; model, where the <tt class="docutils literal">ispc</tt>
program generally describes the behavior of a single program instance, even
though a gang of them is actually executing together.  This implicit model
is the same as that used for shaders in programmable graphics pipelines,
OpenCL* kernels, and CUDA*.  For example, consider the following <tt class="docutils literal">ispc</tt>
function:</p>
<pre class="literal-block">
float func(float a, float b) {
     return a + b / 2.;
}
</pre>
<p>In C, this function describes a simple computation on two individual
floating-point values.  In <tt class="docutils literal">ispc</tt>, this function describes the
computation to be performed by each program instance in a gang.  Each
program instance has distinct values for the variables <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>, and
thus each program instance generally computes a different result when
executing this function.</p>
<p>The gang of program instances starts executing in the same hardware thread
and context as the application code that called the <tt class="docutils literal">ispc</tt> function; no
thread creation or context switching is done under the covers by <tt class="docutils literal">ispc</tt>.
Rather, the set of program instances is mapped to the SIMD lanes of the
current processor, leading to excellent utilization of hardware SIMD units
and high performance.</p>
<p>The number of program instances in a gang is relatively small; in practice,
it's no more than 2-4 times the native SIMD width of the target hardware.
Typically, this means four or eight program instances in a gang on a CPU
using the 4-wide SSE instruction set, eight or sixteen on a CPU
using 8-wide AVX/AVX2, eight, sixteen, thirty-two, or sixty-four on an AVX-512 CPU,
and eight or sixteen on an Intel GPU.</p>
</div>
<div class="section" id="control-flow-within-a-gang">
<h2>Control Flow Within A Gang</h2>
<p>Almost all the standard control-flow constructs are supported by <tt class="docutils literal">ispc</tt>;
program instances are free to follow different program execution paths than
other ones in their gang.  For example, consider a simple <tt class="docutils literal">if</tt> statement
in <tt class="docutils literal">ispc</tt> code:</p>
<pre class="literal-block">
float x = ..., y = ...;
if (x &lt; y) {
   // true statements
}
else {
   // false statements
}
</pre>
<p>In general, the test <tt class="docutils literal">x &lt; y</tt> may have different results for different
program instances in the gang: some of the currently running program
instances want to execute the statements for the &quot;true&quot; case and some want
to execute the statements for the &quot;false&quot; case.</p>
<p>Complex control flow in <tt class="docutils literal">ispc</tt> programs generally works as expected,
computing the same results for each program instance in a gang as would
have been computed if the equivalent code ran serially in C to compute each
program instance's result individually.  However, we will now provide a more
precise definition of the execution model for control flow to clearly
specify the language's behavior in specific situations.</p>
<p>We will specify the notion of a <em>program counter</em> and how it is updated to
step through the program, and an <em>execution mask</em> that indicates which
program instances want to execute the instruction at the current program
counter.  The program counter is shared by all of the
program instances in the gang; it points to a single instruction to be
executed next.  The execution mask is a per-program-instance boolean value
that indicates whether or not side effects from the current instruction
should affect each program instance.  Thus, for example, if a statement
were to be executed with an &quot;all off&quot; mask, there should be no observable
side-effects.</p>
<p>Upon entry to an <tt class="docutils literal">ispc</tt> function called by the application, the execution
mask is &quot;all on&quot; and the program counter points at the first statement in
the function.  The following two statements describe the required behavior
of the program counter and the execution mask over the course of execution
of an <tt class="docutils literal">ispc</tt> function.</p>
<blockquote>
<p>1. The program counter will have a sequence of values corresponding to a
conservative execution path through the function, wherein if <em>any</em>
program instance wants to execute a statement, the program counter will
pass through that statement.</p>
<p>2. At each statement the program counter passes through, the execution
mask will be set such that its value for a particular program instance is
&quot;on&quot; if and only if the program instance wants to execute that statement.</p>
</blockquote>
<p>Note that these definitions provide the compiler some latitude; for example,
the program counter is allowed to pass through a series of statements with the
execution mask &quot;all off&quot; because doing so has no observable side-effects.</p>
<p>Elsewhere, we will speak informally of the <em>control flow coherence</em> of a
program; this notion describes the degree to which the program instances in
the gang want to follow the same control flow path through a function (or,
conversely, whether most statements are executed with a &quot;mostly on&quot;
execution mask or a &quot;mostly off&quot; execution mask.)  In general, control flow
divergence leads to reductions in SIMD efficiency (and thus performance) as
different program instances want to perform different computations.</p>
</div>
<div class="section" id="control-flow-example-if-statements">
<h2>Control Flow Example: If Statements</h2>
<p>As a concrete example of the interplay between program counter and
execution mask, one way that an <tt class="docutils literal">if</tt> statement like the one in the
previous section can be represented is shown by the following pseudo-code
compiler output:</p>
<pre class="literal-block">
float x = ..., y = ...;
bool test = (x &lt; y);
mask originalMask = get_current_mask();
set_mask(originalMask &amp; test);
if (any_mask_entries_are_enabled()) {
  // true statements
}
set_mask(originalMask &amp; ~test);
if (any_mask_entries_are_enabled()) {
  // false statements
}
set_mask(originalMask);
</pre>
<p>In other words, the program counter steps through the statements for both
the &quot;true&quot; case and the &quot;false&quot; case, with the execution mask set so that
no side-effects from the true statements affect the program instances that
want to run the false statements, and vice versa.  However, a block of
statements does not execute if the mask is &quot;all off&quot; upon entry to that
block.  The execution mask is then restored to the value it had before the
<tt class="docutils literal">if</tt> statement.</p>
</div>
<div class="section" id="control-flow-example-loops">
<h2>Control Flow Example: Loops</h2>
<p><tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, and <tt class="docutils literal">do</tt> statements are handled in an analogous
fashion.  The program counter continues to run additional iterations of the
loop until all of the program instances are ready to exit the loop.</p>
<p>Therefore, if we have a loop like the following:</p>
<pre class="literal-block">
int limit = ...;
for (int i = 0; i &lt; limit; ++i) {
    ...
}
</pre>
<p>where <tt class="docutils literal">limit</tt> has the value 1 for all of the program instances but one,
and has value 1000 for the other one, the program counter will step through
the loop body 1000 times.  The first time, the execution mask will be all
on (assuming it is all on going into the <tt class="docutils literal">for</tt> loop), and the remaining
999 times, the mask will be off except for the program instance with a
<tt class="docutils literal">limit</tt> value of 1000.  (This would be a loop with poor control flow
coherence!)</p>
<p>A <tt class="docutils literal">continue</tt> statement in a loop may be handled either by disabling the
execution mask for the program instances that execute the <tt class="docutils literal">continue</tt> and
then continuing to step the program counter through the rest of the loop,
or by jumping to the loop step statement, if all program instances are
disabled after the <tt class="docutils literal">continue</tt> has executed.  <tt class="docutils literal">break</tt> statements are
handled in a similar fashion.</p>
</div>
<div class="section" id="gang-convergence-guarantees">
<h2>Gang Convergence Guarantees</h2>
<p>The <tt class="docutils literal">ispc</tt> execution model provides an important guarantee about the
behavior of the program counter and execution mask: the execution of
program instances is <em>maximally converged</em>.  Maximal convergence means that
if two program instances follow the same control path, they are guaranteed
to execute each program statement concurrently. If two program instances
follow diverging control paths, it is guaranteed that they will reconverge
as soon as possible in the function (if they do later reconverge). <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a></p>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>This is another significant difference between the <tt class="docutils literal">ispc</tt>
execution model and the one implemented by OpenCL* and CUDA*, which
doesn't provide this guarantee.</td></tr>
</tbody>
</table>
<p>Maximal convergence means that in the presence of divergent control flow
such as the following:</p>
<pre class="literal-block">
if (test) {
  // true
}
else {
  // false
}
</pre>
<p>It is guaranteed that all program instances that were running before the
<tt class="docutils literal">if</tt> test will also be running after the end of the <tt class="docutils literal">else</tt> block.
(This guarantee stems from the notion of having a single program counter
for the gang of program instances, rather than the concept of a unique
program counter for each program instance.)</p>
<p>Another implication of this property is that it would be illegal for the
<tt class="docutils literal">ispc</tt> implementation to execute a function with an 8-wide gang by
running it two times, with a 4-wide gang representing half of the original
8-wide gang each time.</p>
<p>It also follows that given the following program:</p>
<pre class="literal-block">
if (programIndex == 0) {
    while (true)  // infinite loop
        ;
}
print(&quot;hello, world\n&quot;);
</pre>
<p>the program will loop infinitely and the <tt class="docutils literal">print</tt> statement will never be
executed.  (A different execution model that allowed gang divergence might
execute the <tt class="docutils literal">print</tt> statement since not all program instances were caught
in the infinite loop in the example above.)</p>
<p>The way that &quot;varying&quot; function pointers are handled in <tt class="docutils literal">ispc</tt> is also
affected by this guarantee: if a function pointer is <tt class="docutils literal">varying</tt>, then it
has a possibly-different value for all running program instances.  Given a
call to a varying function pointer, <tt class="docutils literal">ispc</tt> must maintain as much
execution convergence as possible; the assembly code generated finds the
set of unique function pointers over the currently running program
instances and calls each one just once, such that the executing program
instances when it is called are the set of active program instances that
had that function pointer value.  The order in which the various function
pointers are called in this case is undefined.</p>
</div>
<div class="section" id="uniform-data">
<h2>Uniform Data</h2>
<p>A variable that is declared with the <tt class="docutils literal">uniform</tt> qualifier represents a
single value that is shared across the entire gang.  (In contrast, the
default variability qualifier for variables in <tt class="docutils literal">ispc</tt>, <tt class="docutils literal">varying</tt>,
represents a variable that has a distinct storage location for each program
instance in the gang.)  (Though see the discussion in <a class="reference internal" href="#struct-types">Struct Types</a> for
some subtleties related to <tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt> when used with
structures.)</p>
<p>It is an error to try to assign a <tt class="docutils literal">varying</tt> value to a <tt class="docutils literal">uniform</tt>
variable, though <tt class="docutils literal">uniform</tt> values can be assigned to <tt class="docutils literal">uniform</tt>
variables.  Assignments to <tt class="docutils literal">uniform</tt> variables are not affected by the
execution mask (there's no unambiguous way that they could be); rather,
they always apply if the program counter pointer passes through a statement
that is a <tt class="docutils literal">uniform</tt> assignment.</p>
</div>
<div class="section" id="uniform-control-flow">
<h2>Uniform Control Flow</h2>
<p>One advantage of declaring variables that are shared across the gang as
<tt class="docutils literal">uniform</tt>, when appropriate, is the reduction in storage space required.
A more important benefit is that it can enable the compiler to generate
substantially better code for control flow; when a test condition for a
control flow decision is based on a <tt class="docutils literal">uniform</tt> quantity, the compiler can
be immediately aware that all of the running program instances will follow
the same path at that point, saving the overhead of needing to deal with
control flow divergence and mask management.  (To distinguish the two forms
of control flow, we will say that control flow based on <tt class="docutils literal">varying</tt>
expressions is &quot;varying&quot; control flow.)</p>
<p>Consider for example an image filtering operation where the program loops
over pixels adjacent to the given (x,y) coordinates:</p>
<pre class="literal-block">
float box3x3(uniform float image[32][32], int x, int y) {
    float sum = 0;
    for (int dy = -1; dy &lt;= 1; ++dy)
        for (int dx = -1; dx &lt;= 1; ++dx)
            sum += image[y+dy][x+dx];
    return sum / 9.;
}
</pre>
<p>In general each program instance in the gang has different values for <tt class="docutils literal">x</tt>
and <tt class="docutils literal">y</tt> in this function.  For the box filtering algorithm here, all of
the program instances will actually want to execute the same number of
iterations of the <tt class="docutils literal">for</tt> loops, with all of them having the same values
for <tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> each time through.  If these loops are instead
implemented with <tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> declared as <tt class="docutils literal">uniform</tt> variables, then
the <tt class="docutils literal">ispc</tt> compiler can generate more efficient code for the loops. <a class="footnote-reference" href="#footnote-3" id="footnote-reference-3">[3]</a></p>
<table class="docutils footnote" frame="void" id="footnote-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-3">[3]</a></td><td>In this case, a sufficiently smart compiler could determine that
<tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> have the same value for all program instances and thus
generate more optimized code from the start, though this optimization
isn't yet implemented in <tt class="docutils literal">ispc</tt>.</td></tr>
</tbody>
</table>
<pre class="literal-block">
for (uniform int dy = -1; dy &lt;= 1; ++dy)
    for (uniform int dx = -1; dx &lt;= 1; ++dx)
        sum += image[y+dy][x+dx];
</pre>
<p>In particular, <tt class="docutils literal">ispc</tt> can avoid the overhead of checking to see if any of
the running program instances wants to do another loop iteration.  Instead,
the compiler can generate code where all instances always do the same
iterations.</p>
<p>The analogous benefit comes when using <tt class="docutils literal">if</tt> statements--if the test in an
<tt class="docutils literal">if</tt> statement is based on a <tt class="docutils literal">uniform</tt> test, then the result will by
definition be the same for all of the running program instances.  Thus, the
code for only one of the two cases needs to execute.  <tt class="docutils literal">ispc</tt> can generate
code that jumps to one of the two, avoiding the overhead of needing to run
the code for both cases.</p>
</div>
<div class="section" id="uniform-variables-and-varying-control-flow">
<h2>Uniform Variables and Varying Control Flow</h2>
<p>Recall that in the presence of varying control flow, both the &quot;true&quot; and
&quot;false&quot; clauses of an <tt class="docutils literal">if</tt> statement may be executed, with the side
effects of the instructions masked so that they only apply to the program
instances that are supposed to be executing the corresponding clause.
Under this model, we must define the effect of modifying <tt class="docutils literal">uniform</tt>
variables in the context of varying control flow.</p>
<p>In general, modifying <tt class="docutils literal">uniform</tt> variables under varying control flow
leads to the <tt class="docutils literal">uniform</tt> variable having a value that depends on whether
any of the program instances in the gang followed a particular execution
path.  Consider the following example:</p>
<pre class="literal-block">
float a = ...;
uniform int b = 0;
if (a == 0) {
    ++b;
    // b is 1
}
else {
    b = 10;
    // b is 10
}
// whether b is 1 or 10 depends on whether any of the values
// of &quot;a&quot; in the executing gang were 0.
</pre>
<p>Here, if any of the values of <tt class="docutils literal">a</tt> across the gang was non-zero, then
<tt class="docutils literal">b</tt> will have a value of 10 after the <tt class="docutils literal">if</tt> statement has executed.
However, if all of the values of <tt class="docutils literal">a</tt> in the currently-executing program
instances at the start of the <tt class="docutils literal">if</tt> statement had a value of zero, then
<tt class="docutils literal">b</tt> would have a value of 1.</p>
</div>
<div class="section" id="data-races-within-a-gang">
<h2>Data Races Within a Gang</h2>
<p>In order to be able to write well-formed programs where program instances
depend on values that are written to memory by other program instances
within their gang, it's necessary to have a clear definition of when
side-effects from one program instance become visible to other program
instances running in the same gang.</p>
<p>In the model implemented by <tt class="docutils literal">ispc</tt>, any side effect from one program
instance is visible to other program instances in the gang after the next
sequence point in the program. <a class="footnote-reference" href="#footnote-4" id="footnote-reference-4">[4]</a></p>
<table class="docutils footnote" frame="void" id="footnote-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-4">[4]</a></td><td>This is a significant difference between <tt class="docutils literal">ispc</tt> and SPMD languages
like OpenCL* and CUDA*, which require barrier synchronization among the
running program instances with functions like <tt class="docutils literal">barrier()</tt> or
<tt class="docutils literal">__syncthreads()</tt>, respectively, to ensure this condition.</td></tr>
</tbody>
</table>
<p>Generally, sequence points include the end of a full expression, before a
function is entered in a function call, at function return, and at the end
of initializer expressions.  The fact that there is no sequence point
between the increment of <tt class="docutils literal">i</tt> and the assignment to <tt class="docutils literal">i</tt> in <tt class="docutils literal">i=i++</tt> is
why the effect that expression is undefined in C, for example.  See, for
example, the <a class="reference external" href="http://en.wikipedia.org/wiki/Sequence_point">Wikipedia page on sequence points</a> for more information
about sequence points in C and C++.</p>
<p>In the following example, we have declared an array of values <tt class="docutils literal">v</tt>, with
one value for each running program instance.  In the below, assume that
<tt class="docutils literal">programCount</tt> gives the gang size, and the <tt class="docutils literal">varying</tt> integer value
<tt class="docutils literal">programIndex</tt> indexes into the running program instances starting from
zero.  (Thus, if 8 program instances are running, the first one of them
will have a value 0, the next one a value of 1, and so forth up to 7.)</p>
<pre class="literal-block">
int x = ...;
uniform int tmp[programCount];
tmp[programIndex] = x;
int neighbor = tmp[(programIndex+1)%programCount];
</pre>
<p>In this code, the running program instances have written their values of
<tt class="docutils literal">x</tt> into the <tt class="docutils literal">tmp</tt> array such that the ith element of <tt class="docutils literal">tmp</tt> is equal
to the value of <tt class="docutils literal">x</tt> for the ith program instance.  Then, the program
instances load the value of <tt class="docutils literal">neighbor</tt> from <tt class="docutils literal">tmp</tt>, accessing the value
written by their neighboring program instance (wrapping around to the first
one at the end.)  This code is well-defined and without data races, since
the writes to and reads from <tt class="docutils literal">tmp</tt> are separated by a sequence point.</p>
<p>(For this particular application of communicating values from one program
instance to another, there are more efficient built-in functions in the
<tt class="docutils literal">ispc</tt> standard library; see <a class="reference internal" href="#cross-program-instance-operations">Cross-Program Instance Operations</a> for
more information.)</p>
<p>It is possible to write code that has data races across the gang of program
instances.  For example, if the following function is called with multiple
program instances having the same value of <tt class="docutils literal">index</tt>, then it is undefined
which of them will write their value of <tt class="docutils literal">value</tt> to <tt class="docutils literal">array[index]</tt>.</p>
<pre class="literal-block">
void assign(uniform int array[], int index, int value) {
    array[index] = value;
}
</pre>
<p>As another example, if the values of the array indices <tt class="docutils literal">i</tt> and <tt class="docutils literal">j</tt> have
the same values for some of the program instances, and an assignment like
the following is performed:</p>
<pre class="literal-block">
int i = ..., j = ...;
uniform int array[...] = { ... };
array[i] = array[j];
</pre>
<p>then the program's behavior is undefined, since there is no sequence point
between the reads and writes to the same location.</p>
<p>While this rule that says that program instances can safely depend on
side-effects from other program instances in their gang eliminates a
class of synchronization requirements imposed by some other SPMD languages,
it conversely means that it is possible to write <tt class="docutils literal">ispc</tt> programs that
compute different results when run with different gang sizes.</p>
</div>
<div class="section" id="tasking-model">
<h2>Tasking Model</h2>
<p><tt class="docutils literal">ispc</tt> provides an asynchronous function call (i.e. tasking) mechanism
through the <tt class="docutils literal">launch</tt> keyword.  (The syntax is documented in the <a class="reference internal" href="#task-parallelism-launch-and-sync-statements">Task
Parallelism: &quot;launch&quot; and &quot;sync&quot; Statements</a> section.)  A function called
with <tt class="docutils literal">launch</tt> executes asynchronously from the function that called it;
it may run immediately or it may run concurrently on another processor in
the system, for example.</p>
<p>If a function launches multiple tasks, there are no guarantees about the
order in which the tasks will execute.  Furthermore, multiple launched
tasks from a single function may execute concurrently.</p>
<p>A function that has launched tasks may use the <tt class="docutils literal">sync</tt> keyword to force
synchronization with the launched functions; <tt class="docutils literal">sync</tt> causes a function to
wait for all of the tasks it has launched to finish before execution
continues after the <tt class="docutils literal">sync</tt>.  (Note that <tt class="docutils literal">sync</tt> only waits for the tasks
launched by the current function, not tasks launched by other functions).</p>
<p>Alternatively, when a function that has launched tasks returns, an implicit
<tt class="docutils literal">sync</tt> waits for all launched tasks to finish before allowing the
function to return to its calling function.  This feature is important
since it enables parallel composition: a function can call second function
without needing to be concerned if the second function has launched
asynchronous tasks or not--in either case, when the second function
returns, the first function can trust that all of its computation has
completed.</p>
</div>
</div>
<div class="section" id="the-ispc-language">
<h1>The ISPC Language</h1>
<p><tt class="docutils literal">ispc</tt> is an extended version of the C programming language, providing a
number of new features that make it easy to write high-performance SPMD
programs for the CPU and GPU.  Note that due to not only the few small syntactic
differences between <tt class="docutils literal">ispc</tt> and C code but more importantly <tt class="docutils literal">ispc</tt>'s
fundamentally parallel execution model, C code can't just be recompiled to
correctly run in parallel with <tt class="docutils literal">ispc</tt>.  However, starting with working C
code and porting it to <tt class="docutils literal">ispc</tt> can be an efficient way to quickly write
<tt class="docutils literal">ispc</tt> programs.</p>
<p>This section describes the syntax and semantics of the <tt class="docutils literal">ispc</tt> language.
To understand how to use <tt class="docutils literal">ispc</tt>, you need to understand both the language
syntax and <tt class="docutils literal">ispc</tt>'s parallel execution model, which was described in the
previous section, <a class="reference internal" href="#the-ispc-parallel-execution-model">The ISPC Parallel Execution Model</a>.</p>
<div class="section" id="relationship-to-the-c-programming-language">
<h2>Relationship To The C Programming Language</h2>
<p>This subsection summarizes the differences between <tt class="docutils literal">ispc</tt> and C; if you
are already familiar with C, you may find it most effective to focus on
this subsection and then on the topics in the remainder of this section
that introduce new language features.  You may also find it helpful to
compare the <tt class="docutils literal">ispc</tt> and C++ implementations of various algorithms in the
<tt class="docutils literal">ispc</tt> <tt class="docutils literal">examples/</tt> directory to get a sense of the close relationship
between <tt class="docutils literal">ispc</tt> and C.</p>
<p>Specifically, C89 is used as the baseline for comparison in this subsection
(this is also the version of C described in the Second Edition of Kernighan
and Ritchie's book).  (<tt class="docutils literal">ispc</tt> adopts some features from C99 and C++,
which will be highlighted below.)</p>
<p><tt class="docutils literal">ispc</tt> has the same syntax and features as C for the following:</p>
<ul class="simple">
<li>Expression syntax and basic types</li>
<li>Syntax for variable declarations</li>
<li>Control flow structures: <tt class="docutils literal">if</tt>, <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, <tt class="docutils literal">do</tt>, and <tt class="docutils literal">switch</tt>.</li>
<li>Pointers, including function pointers, <tt class="docutils literal">void *</tt>, and C's array/pointer
duality (arrays are converted to pointers when passed to functions, etc.)</li>
<li>Structs and arrays</li>
<li>Support for recursive function calls</li>
<li>Support for separate compilation of source files</li>
<li>&quot;Short-circuit&quot; evaluation of <tt class="docutils literal">||</tt>, <tt class="docutils literal">&amp;&amp;</tt> and <tt class="docutils literal">? :</tt> operators</li>
<li>The preprocessor</li>
</ul>
<p><tt class="docutils literal">ispc</tt> adds a number of features from C++ and C99 to this base:</p>
<ul class="simple">
<li>A boolean type, <tt class="docutils literal">bool</tt>, as well as built-in <tt class="docutils literal">true</tt> and <tt class="docutils literal">false</tt>
values</li>
<li>Reference types (e.g. <tt class="docutils literal">const float &amp;foo</tt>)</li>
<li>Comments delimited by <tt class="docutils literal">//</tt></li>
<li>Variables can be declared anywhere in blocks, not just at their start.</li>
<li>Iteration variables for <tt class="docutils literal">for</tt> loops can be declared in the <tt class="docutils literal">for</tt>
statement itself (e.g. <tt class="docutils literal">for (int i = 0; ...</tt>)</li>
<li>The <tt class="docutils literal">inline</tt> qualifier to indicate that a function should be inlined</li>
<li>Function overloading by parameter type</li>
<li>Hexadecimal floating-point constants</li>
<li>Dynamic memory allocation with <tt class="docutils literal">new</tt> and <tt class="docutils literal">delete</tt>.</li>
<li>Limited support for overloaded operators (<a class="reference internal" href="#operators-overloading">Operators Overloading</a>).</li>
</ul>
<p><tt class="docutils literal">ispc</tt> also adds a number of new features that aren't in C89, C99, or
C++:</p>
<ul class="simple">
<li>Parallel <tt class="docutils literal">foreach</tt> and <tt class="docutils literal">foreach_tiled</tt> iteration constructs (see
<a class="reference internal" href="#parallel-iteration-statements-foreach-and-foreach-tiled">Parallel Iteration Statements: &quot;foreach&quot; and &quot;foreach_tiled&quot;</a>)</li>
<li>The <tt class="docutils literal">foreach_active</tt> and <tt class="docutils literal">foreach_unique</tt> iteration constructs, which
provide ways of iterating over subsets of the program instances in the
gang.  See <a class="reference internal" href="#iteration-over-active-program-instances-foreach-active">Iteration over active program instances: &quot;foreach_active&quot;</a>
and <a class="reference internal" href="#iteration-over-unique-elements-foreach-unique">Iteration over unique elements: &quot;foreach_unique&quot;</a>.)</li>
<li>Language support for task parallelism (see <a class="reference internal" href="#task-parallel-execution">Task Parallel Execution</a>)</li>
<li>&quot;Coherent&quot; control flow statements that indicate that control flow is
expected to be coherent across the running program instances (see
<a class="reference internal" href="#coherent-control-flow-statements-cif-and-friends">&quot;Coherent&quot; Control Flow Statements: &quot;cif&quot; and Friends</a>)</li>
<li>A rich standard library, though one that differs from C's (see <a class="reference internal" href="#the-ispc-standard-library">The
ISPC Standard Library</a>.)</li>
<li>Short vector types (see <a class="reference internal" href="#short-vector-types">Short Vector Types</a>)</li>
<li>Syntax to specify integer constants as bit vectors (e.g. <tt class="docutils literal">0b1100</tt> is 12)</li>
</ul>
<p>There are a number of features of C89 that are not supported in <tt class="docutils literal">ispc</tt>
but are likely to be supported in future releases:</p>
<ul class="simple">
<li>There are no types named <tt class="docutils literal">char</tt>, <tt class="docutils literal">short</tt>, or <tt class="docutils literal">long</tt> (or <tt class="docutils literal">long
double</tt>).  However, there are built-in <tt class="docutils literal">int8</tt>, <tt class="docutils literal">int16</tt>, and
<tt class="docutils literal">int64</tt> types</li>
<li>Character constants</li>
<li>String constants and arrays of characters as strings</li>
<li><tt class="docutils literal">goto</tt> statements are partially supported (see <a class="reference internal" href="#unstructured-control-flow-goto">Unstructured Control Flow: &quot;goto&quot;</a>)</li>
<li><tt class="docutils literal">union</tt> types</li>
<li>Bitfield members of <tt class="docutils literal">struct</tt> types</li>
<li>Variable numbers of arguments to functions</li>
<li>Literal floating-point constants (even without an <tt class="docutils literal">f</tt> suffix) are
currently treated as <tt class="docutils literal">float</tt> type, not <tt class="docutils literal">double</tt>. To specify a double-precision
floating-point constant, use the <tt class="docutils literal">d</tt> suffix.</li>
<li>The <tt class="docutils literal">volatile</tt> qualifier</li>
<li>The <tt class="docutils literal">register</tt> storage class for variables.  (Will be ignored).</li>
</ul>
<p>The following C89 features are not expected to be supported in any future
<tt class="docutils literal">ispc</tt> release:</p>
<ul class="simple">
<li>&quot;K&amp;R&quot; style function declarations</li>
<li>The C standard library</li>
<li>Octal integer constants</li>
</ul>
<p>The following reserved words from C89 are also reserved in <tt class="docutils literal">ispc</tt>:</p>
<p><tt class="docutils literal">break</tt>, <tt class="docutils literal">case</tt>, <tt class="docutils literal">const</tt>, <tt class="docutils literal">continue</tt>, <tt class="docutils literal">default</tt>, <tt class="docutils literal">do</tt>,
<tt class="docutils literal">double</tt>, <tt class="docutils literal">else</tt>, <tt class="docutils literal">enum</tt>, <tt class="docutils literal">extern</tt>, <tt class="docutils literal">float</tt>, <tt class="docutils literal">for</tt>, <tt class="docutils literal">goto</tt>,
<tt class="docutils literal">if</tt>, <tt class="docutils literal">int</tt>, <tt class="docutils literal">NULL</tt>, <tt class="docutils literal">return</tt>, <tt class="docutils literal">signed</tt>, <tt class="docutils literal">sizeof</tt>, <tt class="docutils literal">static</tt>,
<tt class="docutils literal">struct</tt>, <tt class="docutils literal">switch</tt>, <tt class="docutils literal">typedef</tt>, <tt class="docutils literal">unsigned</tt>, <tt class="docutils literal">void</tt>, and <tt class="docutils literal">while</tt>.</p>
<p><tt class="docutils literal">ispc</tt> additionally reserves the following words:</p>
<p><tt class="docutils literal">bool</tt>, <tt class="docutils literal">cdo</tt>, <tt class="docutils literal">cfor</tt>, <tt class="docutils literal">cif</tt>, <tt class="docutils literal">cwhile</tt>, <tt class="docutils literal">delete</tt>, <tt class="docutils literal">export</tt>,
<tt class="docutils literal">false</tt>, <tt class="docutils literal">float16</tt>, <tt class="docutils literal">foreach</tt>, <tt class="docutils literal">foreach_active</tt>, <tt class="docutils literal">foreach_tiled</tt>,
<tt class="docutils literal">foreach_unique</tt>, <tt class="docutils literal">in</tt>, <tt class="docutils literal">inline</tt>, <tt class="docutils literal">int8</tt>, <tt class="docutils literal">int16</tt>, <tt class="docutils literal">int32</tt>,
<tt class="docutils literal">int64</tt>, <tt class="docutils literal">invoke_sycl</tt>, <tt class="docutils literal">launch</tt>, <tt class="docutils literal">new</tt>, <tt class="docutils literal">noinline</tt>, <tt class="docutils literal">print</tt>,
<tt class="docutils literal">soa</tt>, <tt class="docutils literal">sync</tt>, <tt class="docutils literal">task</tt>, <tt class="docutils literal">template</tt>, <tt class="docutils literal">true</tt>, <tt class="docutils literal">typename</tt>, <tt class="docutils literal">uint8</tt>,
<tt class="docutils literal">uint16</tt>, <tt class="docutils literal">uint32</tt>, <tt class="docutils literal">uint64</tt>, <tt class="docutils literal">uint</tt>, <tt class="docutils literal">uniform</tt>, <tt class="docutils literal">unmasked</tt>,
<tt class="docutils literal">varying</tt>, <tt class="docutils literal">__attribute__</tt>, <tt class="docutils literal">__regcall</tt>, <tt class="docutils literal">__vectorcall</tt>.</p>
</div>
<div class="section" id="lexical-structure">
<h2>Lexical Structure</h2>
<p>Tokens in <tt class="docutils literal">ispc</tt> are delimited by white-space and comments.  The
white-space characters are the usual set of spaces, tabs, and carriage
returns/line feeds.  Comments can be delineated with <tt class="docutils literal">//</tt>, which starts a
comment that continues to the end of the line, or the start of a comment
can be delineated with <tt class="docutils literal">/*</tt> at the start and with <tt class="docutils literal">*/</tt> at the end.
Like C/C++, comments can't be nested.</p>
<p>Identifiers in <tt class="docutils literal">ispc</tt> are sequences of characters that start with an
underscore or an upper-case or lower-case letter, and then followed by
zero or more letters, numbers, or underscores.  Identifiers that start with
two underscores are reserved for use by the compiler.</p>
</div>
<div class="section" id="integer-literals">
<h2>Integer Literals</h2>
<p>Integer numeric constants can be specified in base 10, hexadecimal, or
binary.  (Octal integer constants aren't supported).  Base 10 constants are
given by a sequence of one or more digits from 0 to 9.  Hexadecimal
constants are denoted by a leading <tt class="docutils literal">0x</tt> or <tt class="docutils literal">0X</tt> and then one or more digits from
0-9, a-f, or A-F.  Finally, binary constants are denoted by a leading
<tt class="docutils literal">0b</tt> and then a sequence of 1s and 0s.</p>
<p>Here are three ways of specifying the integer value &quot;15&quot;:</p>
<pre class="literal-block">
int fifteen_decimal = 15;
int fifteen_hex     = 0xf;
int fifteen_binary  = 0b1111;
</pre>
<p>A number of suffixes can be provided with integer numeric constants.
First, &quot;u&quot; denotes that the constant is unsigned, and &quot;ll&quot; denotes a 64-bit
integer constant (while &quot;l&quot; denotes a 32-bit integer constant). The
aforementioned suffixes can also be written in uppercase. However, like in C,
you cannot mix uppercase and lowercase in a given suffix (e.g. uLl or ulL).
It is also possible to denote units of 1024, 1024*1024, or 1024*1024*1024 with
the SI-inspired suffixes &quot;k&quot;, &quot;M&quot;, and &quot;G&quot; respectively. Note that the latter
suffixes must precede the type-related suffixes. Here is an example:</p>
<pre class="literal-block">
uint three = 3ul;
int two_kb = 2k;         // 2048
int two_megs = 2M;       // 2 * 1024 * 1024
int one_gig = 1G;        // 1024 * 1024 * 1024
uint three_gig = 3Gu;    // 3 * 1024 * 1024 * 1024
uint64 six_gig = 6GuLL;  // 6 * 1024 * 1024 * 1024
int64 ten_gig = 10Gll;   // 10 * 1024 * 1024 * 1024
</pre>
</div>
<div class="section" id="floating-point-literals">
<h2>Floating Point Literals</h2>
<p>ISPC supports 3 floating point types : <tt class="docutils literal">float16</tt>, <tt class="docutils literal">float</tt> and <tt class="docutils literal">double</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">float16</tt> is an IEEE 754 half-precision (16 bit format) floating point type.</li>
<li><tt class="docutils literal">float</tt> is an IEEE 754 single-precision (32 bit format) floating point type.</li>
<li><tt class="docutils literal">double</tt> is an IEEE 754 double-precision (64 bit format) floating point type.</li>
</ul>
<p>Floating-point constants of all three types can be specified in one of three ways.</p>
<ul class="simple">
<li>Decimal floating-point with radix separator - a sequence of zero or more
0-9 digits, followed by a period, followed by zero or more 0-9 digits.
There must be at least one digit before or after the period. If floating-point
suffix is used, radix separator is optional.</li>
<li>Scientific notation - a decimal base followed by an &quot;e&quot; or &quot;E&quot;, then optional
plus or minus sign, and then a decimal exponent.</li>
<li>Hexadecimal floating-point constant - bit-accurate representation of a particular
floating-point number. It starts with &quot;0x&quot; or &quot;0X&quot; prefix, followed by a zero
or a one, a period, and then the remainder of the mantissa in hexadecimal form,
with digits from 0-9, a-f, or A-F. The start of the exponent is denoted by a &quot;p&quot;
or &quot;P&quot;, which is then followed by an optional plus or minus sign and then digits
from 0 to 9, representing decimal value of the exponent. The exponent is never
optional for hexadecimal floating-point literals.</li>
</ul>
<p>The default type for floating-point literals is <tt class="docutils literal">float</tt>. Floating-point
literals can be specified by adding one of the following suffixes:</p>
<table border="1" class="docutils">
<caption>Operators</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>Suffix</td>
<td>Type</td>
</tr>
<tr><td><tt class="docutils literal">f16</tt> or <tt class="docutils literal">F16</tt></td>
<td><tt class="docutils literal">float16</tt></td>
</tr>
<tr><td><tt class="docutils literal">f</tt> or <tt class="docutils literal">F</tt></td>
<td><tt class="docutils literal">float</tt></td>
</tr>
<tr><td><tt class="docutils literal">d</tt> or <tt class="docutils literal">D</tt></td>
<td><tt class="docutils literal">double</tt></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<p><tt class="docutils literal">float</tt> type floating point literals</p>
<pre class="literal-block">
float16 two_f16   = 2.0f16;                // 2.0
float16 pi_f16    = 0x1.92p+1f16;          // 3.1406
float16 neg_f16   = -65520.f16;            // -Inf
float   two_f     = 0x1p+1;                // 2.0
float   pi_f      = 0x1.921fb6p+1;         // 3.14159274
float   neg_f     = -0x1.ffep+11;          // -4095.0
double  two_d     = 2.0d;                  // 2.0
double  pi_d      = 0x1.921fb54442d18p+1d; // 3.1415926535897931
double  neg_d     = -0.3333333333333333d;  // -1/3
</pre>
<p>Also, &quot;Fortran double&quot; format is accepted - a scientific notation with a literal
&quot;d&quot; or &quot;D&quot; used instead of &quot;e&quot;. This notation yields a double precision floating
point literal:</p>
<pre class="literal-block">
double d1 = 1.234d+3;  // 1234.0d
double d2 = 1.234e+3d; // 1234.0d
</pre>
</div>
<div class="section" id="string-literals">
<h2>String Literals</h2>
<p>String constants in <tt class="docutils literal">ispc</tt> are denoted by an opening double quote <tt class="docutils literal">&quot;</tt>
followed by any character other than a newline, up to a closing double
quote.  Within the string, a number of special escape sequences can be used
to specify special characters.  These sequences all start with an initial
<tt class="docutils literal">\</tt> and are listed below:</p>
<table border="1" class="docutils">
<caption>Escape sequences in strings</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">\\</tt></td>
<td>backslash: <tt class="docutils literal">\</tt></td>
</tr>
<tr><td><tt class="docutils literal">\&quot;</tt></td>
<td>double quotation mark: <tt class="docutils literal">&quot;</tt></td>
</tr>
<tr><td><tt class="docutils literal">\'</tt></td>
<td>single quotation mark: <tt class="docutils literal">'</tt></td>
</tr>
<tr><td><tt class="docutils literal">\a</tt></td>
<td>bell (alert)</td>
</tr>
<tr><td><tt class="docutils literal">\b</tt></td>
<td>backspace character</td>
</tr>
<tr><td><tt class="docutils literal">\f</tt></td>
<td>formfeed character</td>
</tr>
<tr><td><tt class="docutils literal">\n</tt></td>
<td>newline</td>
</tr>
<tr><td><tt class="docutils literal">\r</tt></td>
<td>carriage return</td>
</tr>
<tr><td><tt class="docutils literal">\t</tt></td>
<td>horizontal tab</td>
</tr>
<tr><td><tt class="docutils literal">\v</tt></td>
<td>vertical tab</td>
</tr>
<tr><td><tt class="docutils literal">\</tt> followed by one or more digits from 0-8</td>
<td>ASCII character in octal notation</td>
</tr>
<tr><td><tt class="docutils literal">\x</tt>, followed by one or more digits from 0-9, a-f, A-F</td>
<td>ASCII character in hexadecimal notation</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">ispc</tt> doesn't support a string data type; string constants can be passed
as the first argument to the <tt class="docutils literal">print()</tt> statement, however.  <tt class="docutils literal">ispc</tt> also
doesn't support character constants.</p>
<p>The following identifiers are reserved as language keywords: <tt class="docutils literal">bool</tt>,
<tt class="docutils literal">break</tt>, <tt class="docutils literal">case</tt>, <tt class="docutils literal">cdo</tt>, <tt class="docutils literal">cfor</tt>, <tt class="docutils literal">cif</tt>, <tt class="docutils literal">const</tt>, <tt class="docutils literal">continue</tt>,
<tt class="docutils literal">cwhile</tt>, <tt class="docutils literal">default</tt>, <tt class="docutils literal">delete</tt>, <tt class="docutils literal">do</tt>, <tt class="docutils literal">double</tt>, <tt class="docutils literal">else</tt>, <tt class="docutils literal">enum</tt>,
<tt class="docutils literal">export</tt>, <tt class="docutils literal">extern</tt>, <tt class="docutils literal">false</tt>, <tt class="docutils literal">float16</tt>, <tt class="docutils literal">float</tt>, <tt class="docutils literal">for</tt>,
<tt class="docutils literal">foreach</tt>, <tt class="docutils literal">foreach_active</tt>, <tt class="docutils literal">foreach_tiled</tt>, <tt class="docutils literal">foreach_unique</tt>,
<tt class="docutils literal">goto</tt>, <tt class="docutils literal">if</tt>, <tt class="docutils literal">in</tt>, <tt class="docutils literal">inline</tt>, <tt class="docutils literal">int8</tt>, <tt class="docutils literal">int16</tt>, <tt class="docutils literal">int32</tt>,
<tt class="docutils literal">int64</tt>, <tt class="docutils literal">int</tt>, <tt class="docutils literal">invoke_sycl</tt>, <tt class="docutils literal">launch</tt>, <tt class="docutils literal">new</tt>, <tt class="docutils literal">noinline</tt>,
<tt class="docutils literal">NULL</tt>, <tt class="docutils literal">print</tt>, <tt class="docutils literal">return</tt>, <tt class="docutils literal">signed</tt>, <tt class="docutils literal">sizeof</tt>, <tt class="docutils literal">soa</tt>, <tt class="docutils literal">static</tt>,
<tt class="docutils literal">struct</tt>, <tt class="docutils literal">switch</tt>, <tt class="docutils literal">sync</tt>, <tt class="docutils literal">task</tt>, <tt class="docutils literal">template</tt>, <tt class="docutils literal">true</tt>,
<tt class="docutils literal">typedef</tt>, <tt class="docutils literal">typename</tt>, <tt class="docutils literal">uint8</tt>, <tt class="docutils literal">uint16</tt>, <tt class="docutils literal">uint32</tt>, <tt class="docutils literal">uint64</tt>,
<tt class="docutils literal">uint</tt>, <tt class="docutils literal">uniform</tt>, <tt class="docutils literal">unmasked</tt>, <tt class="docutils literal">unsigned</tt>, <tt class="docutils literal">varying</tt>, <tt class="docutils literal">void</tt>,
<tt class="docutils literal">while</tt>, <tt class="docutils literal">__attribute__</tt>, <tt class="docutils literal">__regcall</tt>, <tt class="docutils literal">__vectorcall</tt>.</p>
<p><tt class="docutils literal">ispc</tt> defines the following operators and punctuation:</p>
<table border="1" class="docutils">
<caption>Operators</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>Symbols</td>
<td>Use</td>
</tr>
<tr><td><tt class="docutils literal">=</tt></td>
<td>Assignment</td>
</tr>
<tr><td><tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, *, <tt class="docutils literal">/</tt>, <tt class="docutils literal">%</tt></td>
<td>Arithmetic operators</td>
</tr>
<tr><td><tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">!</tt>, <tt class="docutils literal">~</tt>, <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt>, <tt class="docutils literal">&lt;&lt;</tt>, <tt class="docutils literal">&gt;&gt;</tt></td>
<td>Logical and bitwise operators</td>
</tr>
<tr><td><tt class="docutils literal">++</tt>, <tt class="docutils literal"><span class="pre">--</span></tt></td>
<td>Pre/post increment/decrement</td>
</tr>
<tr><td><tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&lt;=</tt>, <tt class="docutils literal">&gt;</tt>, <tt class="docutils literal">&gt;=</tt>, <tt class="docutils literal">==</tt>, <tt class="docutils literal">!=</tt></td>
<td>Relational operators</td>
</tr>
<tr><td><tt class="docutils literal">*=</tt>, <tt class="docutils literal">/=</tt>, <tt class="docutils literal">+=</tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal">&lt;&lt;=</tt>, <tt class="docutils literal">&gt;&gt;=</tt>, <tt class="docutils literal">&amp;=</tt>, <tt class="docutils literal">|=</tt></td>
<td>Compound assignment operators</td>
</tr>
<tr><td><tt class="docutils literal">?</tt>, <tt class="docutils literal">:</tt></td>
<td>Selection operators</td>
</tr>
<tr><td><tt class="docutils literal">;</tt></td>
<td>Statement separator</td>
</tr>
<tr><td><tt class="docutils literal">,</tt></td>
<td>Expression separator</td>
</tr>
<tr><td><tt class="docutils literal">.</tt></td>
<td>Member access</td>
</tr>
</tbody>
</table>
<p>A number of tokens are used for grouping in <tt class="docutils literal">ispc</tt>:</p>
<table border="1" class="docutils">
<caption>Grouping Tokens</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">(</tt>, <tt class="docutils literal">)</tt></td>
<td>Parenthesization of expressions, function calls, delimiting specifiers
for control flow constructs.</td>
</tr>
<tr><td><tt class="docutils literal">[</tt>, <tt class="docutils literal">]</tt></td>
<td>Array and short-vector indexing</td>
</tr>
<tr><td><tt class="docutils literal">{</tt>, <tt class="docutils literal">}</tt></td>
<td>Compound statements</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="types">
<h2>Types</h2>
</div>
<div class="section" id="basic-types-and-type-qualifiers">
<h2>Basic Types and Type Qualifiers</h2>
<p><tt class="docutils literal">ispc</tt> is a statically-typed language.  It supports a variety of core
basic types:</p>
<ul class="simple">
<li><tt class="docutils literal">void</tt>: &quot;empty&quot; type representing no value.</li>
<li><tt class="docutils literal">bool</tt>: boolean value; may be assigned <tt class="docutils literal">true</tt>, <tt class="docutils literal">false</tt>, or the
value of a boolean expression.</li>
<li><tt class="docutils literal">int8</tt>: 8-bit signed integer.</li>
<li><tt class="docutils literal">unsigned int8</tt>: 8-bit unsigned integer; may also be specified as <tt class="docutils literal">uint8</tt>.</li>
<li><tt class="docutils literal">int16</tt>: 16-bit signed integer.</li>
<li><tt class="docutils literal">unsigned int16</tt>: 16-bit unsigned integer; may also be specified as <tt class="docutils literal">uint16</tt>.</li>
<li><tt class="docutils literal">int</tt>: 32-bit signed integer; may also be specified as <tt class="docutils literal">int32</tt>.</li>
<li><tt class="docutils literal">unsigned int</tt>: 32-bit unsigned integer; may also be specified as
<tt class="docutils literal">unsigned int32</tt>, <tt class="docutils literal">uint32</tt> or <tt class="docutils literal">uint</tt>.</li>
<li><tt class="docutils literal">int64</tt>: 64-bit signed integer.</li>
<li><tt class="docutils literal">unsigned int64</tt>: 64-bit unsigned integer; may also be specified as <tt class="docutils literal">uint64</tt>.</li>
<li><tt class="docutils literal">float16</tt>: 16-bit floating point value</li>
<li><tt class="docutils literal">float</tt>: 32-bit floating point value</li>
<li><tt class="docutils literal">double</tt>: 64-bit double-precision floating point value.</li>
</ul>
<p>There are also a few built-in types related to pointers and memory:</p>
<ul class="simple">
<li><tt class="docutils literal">size_t</tt>: the maximum size of any object (structure or array)</li>
<li><tt class="docutils literal">ptrdiff_t</tt>: an integer type large enough to represent the difference
between two pointers</li>
<li><tt class="docutils literal">intptr_t</tt>: signed integer type that is large enough to represent
a pointer value</li>
<li><tt class="docutils literal">uintptr_t</tt>: unsigned integer type large enough to represent a pointer</li>
</ul>
<p>Implicit type conversion between values of different types is done
automatically by the <tt class="docutils literal">ispc</tt> compiler.  Thus, a value of <tt class="docutils literal">float</tt> type
can be assigned to a variable of <tt class="docutils literal">int</tt> type directly.  In binary
arithmetic expressions with mixed types, types are promoted to the &quot;more
general&quot; of the two types, with the following precedence:</p>
<pre class="literal-block">
double &gt; uint64 &gt; int64 &gt; float &gt; uint32 &gt; int32 &gt;
    float16 &gt; uint16 &gt; int16 &gt; uint8 &gt; int8 &gt; bool
</pre>
<p>In other words, adding an <tt class="docutils literal">int64</tt> to a <tt class="docutils literal">double</tt> causes the <tt class="docutils literal">int64</tt> to
be converted to a <tt class="docutils literal">double</tt>, the addition to be performed, and a
<tt class="docutils literal">double</tt> value to be returned.  If a different conversion behavior is
desired, then explicit type-casts can be used, where the destination type
is provided in parenthesis around the expression:</p>
<pre class="literal-block">
double foo = 1. / 3.;
int bar = (float)foo + (float)foo;  // 32-bit float addition
</pre>
<p>If a <tt class="docutils literal">bool</tt> is converted to an integer numeric type (<tt class="docutils literal">int</tt>, <tt class="docutils literal">int64</tt>,
etc.), then the result is a non-zero value if the <tt class="docutils literal">bool</tt> has the value
<tt class="docutils literal">true</tt> and has the value zero otherwise. A <tt class="docutils literal">bool</tt> with value <tt class="docutils literal">true</tt>
is not guaranteed to be one if converted to an integer numeric type.</p>
<p>Variables can be declared with the <tt class="docutils literal">const</tt> qualifier, which prohibits
their modification.</p>
<pre class="literal-block">
const float PI = 3.1415926535;
</pre>
<p>As in C, the <tt class="docutils literal">extern</tt> qualifier can be used to declare a function or
global variable defined in another source file, and the <tt class="docutils literal">static</tt>
qualifier can be used to define a variable or function that is only visible
in the current scope.  The values of <tt class="docutils literal">static</tt> variables declared in
functions are preserved across function calls.</p>
</div>
<div class="section" id="signed-and-unsigned-integer-types">
<h2>Signed and Unsigned Integer Types</h2>
<p>Like in C and C++ signed and unsigned integer types behave differently with
respect to overflow. Unsigned integer types have defined behavior in case of
overflow and underflow, they are guaranteed to wraparound. I.e. maximum
unsigned integer value plus one is guaranteed to be zero. Signed integer types
have <strong>undefined</strong> behavior in case of overflow and underflow, they are <strong>not</strong>
guaranteed to wraparound. This is done on purpose to enable the compiler to be more
aggressive with optimizations of signed types.</p>
<p>There is a subtle difference with C and C++ for 8 and 16 bit integer types. In
C and C++ binary operations require <em>integer promotions</em> for both operands,
while <tt class="docutils literal">ispc</tt> does not. This means that C and C++ do not have 8 and 16 bit
arithmetic and all operations are promoted to at least to 32 bits, and hence,
overflow and underflow do not happen for these types. If the resulting value is
outside the 8 and 16 bit type range and it is assigned to 8 or 16 bit variable,
the result is truncated. In <tt class="docutils literal">ispc</tt> there are no <em>integer promotions</em> rules,
and hence, overflow and underflow may happen for 8 and 16 bit types.</p>
<p>Note that undefined behavior for signed integer overflow was introduced in
<tt class="docutils literal">ispc</tt> only starting from version <tt class="docutils literal">1.21.0</tt>, which may cause compatibility
issues. This behavior can be managed by <tt class="docutils literal"><span class="pre">--[no-]wrap-signed-int</span></tt> compiler
switch. <tt class="docutils literal"><span class="pre">--no-wrap-signed-int</span></tt> enables undefined behavior for signed integer
overflow / underflow and it is the default. If the old behavior (before
<tt class="docutils literal">1.21.0</tt>) needs to be preserved, use <tt class="docutils literal"><span class="pre">--wrap-signed-int</span></tt>, which cause
signed integers to have defined wraparound behavior (keep in mind that it will
prevent some compiler optimizations).</p>
</div>
<div class="section" id="uniform-and-varying-qualifiers">
<h2>&quot;uniform&quot; and &quot;varying&quot; Qualifiers</h2>
<p>If a variable has a <tt class="docutils literal">uniform</tt> qualifier, then there is only a single
instance of that variable shared by all program instances in a gang.  (In
other words, it necessarily has the same value across all of the program
instances.)  In addition to requiring less storage than varying values,
<tt class="docutils literal">uniform</tt> variables lead to a number of performance advantages when they
are applicable (see <a class="reference internal" href="#uniform-control-flow">Uniform Control Flow</a>, for example.)  Varying
variables may be qualified with <tt class="docutils literal">varying</tt>, though doing so has no effect,
as <tt class="docutils literal">varying</tt> is the default.</p>
<p>There are two exceptions for this rule described in <a class="reference internal" href="#pointer-types">Pointer Types</a> and
<a class="reference internal" href="#type-casting">Type Casting</a> sections.</p>
<p><tt class="docutils literal">uniform</tt> variables can be modified as the program executes, but only in
ways that preserve the property that they have a single value for the
entire gang.  Thus, it's legal to add two uniform variables together and
assign the result to a uniform variable, but assigning a non-<tt class="docutils literal">uniform</tt>
(i.e., <tt class="docutils literal">varying</tt>) value to a <tt class="docutils literal">uniform</tt> variable is a compile-time
error.</p>
<p><tt class="docutils literal">uniform</tt> variables implicitly type-convert to varying types as required:</p>
<pre class="literal-block">
uniform int x = ...;
int y = ...;
int z = x * y;  // x is converted to varying for the multiply
</pre>
<p>Arrays themselves aren't uniform or varying, but the elements that they
store are:</p>
<pre class="literal-block">
float foo[10];
uniform float bar[10];
</pre>
<p>The first declaration corresponds to 10 gang-wide <tt class="docutils literal">float</tt> values in
memory, while the second declaration corresponds to 10 <tt class="docutils literal">float</tt> values.</p>
</div>
<div class="section" id="defining-new-names-for-types">
<h2>Defining New Names For Types</h2>
<p>The <tt class="docutils literal">typedef</tt> keyword can be used to name types:</p>
<pre class="literal-block">
typedef int64 BigInt;
typedef float Float3[3];
</pre>
<p>Following C's syntax, the code above defines <tt class="docutils literal">BigInt</tt> to have <tt class="docutils literal">int64</tt>
type and <tt class="docutils literal">Float3</tt> to have <tt class="docutils literal">float[3]</tt> type.</p>
<p>Also as in C, <tt class="docutils literal">typedef</tt> doesn't create a new type: it just provides an
alternative name for an existing type.  Thus, in the above example, it is
legal to pass a value with <tt class="docutils literal">float[3]</tt> type to a function that has been
declared to take a <tt class="docutils literal">Float3</tt> parameter.</p>
</div>
<div class="section" id="pointer-types">
<h2>Pointer Types</h2>
<p>It is possible to have pointers to data in memory; pointer arithmetic,
changing values in memory with pointers, and so forth is supported as in C.
As with other basic types, pointers can be both <tt class="docutils literal">uniform</tt> and
<tt class="docutils literal">varying</tt>.</p>
<p><strong>Like other types in ispc, pointers are</strong> <tt class="docutils literal">varying</tt> <strong>by default, if an
explicit</strong> <tt class="docutils literal">uniform</tt> <strong>qualifier isn't provided. However, the default
variability of the pointed-to type is</strong> <tt class="docutils literal">uniform</tt>. This rule will be
illustrated and explained in examples below.</p>
<p>For example, the <tt class="docutils literal">ptr</tt> variable in the code below is a varying pointer to
<tt class="docutils literal">uniform float</tt> values.  Each program instance has a separate pointer
value and the assignment to <tt class="docutils literal">*ptr</tt> generally represents a scatter to
memory.</p>
<pre class="literal-block">
uniform float a[] = ...;
int index = ...;
float * ptr = &amp;a[index];
*ptr = 1;
</pre>
<p>A <tt class="docutils literal">uniform</tt> pointer can be declared with an appropriately-placed
qualifier:</p>
<pre class="literal-block">
float f = 0;
varying float * uniform pf = &amp;f;  // uniform pointer to a varying float
*pf = 1;
</pre>
<p>The placement of the <tt class="docutils literal">uniform</tt> qualifier to declare a <tt class="docutils literal">uniform</tt> pointer
may be initially surprising, but it matches the form of how, for example, a
pointer that is itself <tt class="docutils literal">const</tt> (as opposed to pointing to a <tt class="docutils literal">const</tt>
type) is declared in C.  (Reading the declaration from right to left gives
its meaning: a uniform pointer to a float that is varying.)</p>
<p>A subtlety comes in in cases like the where a <tt class="docutils literal">uniform</tt> pointer points to a
<tt class="docutils literal">varying</tt> data type. In this case, each program instance accesses a distinct
location in memory (because the underlying <tt class="docutils literal">varying</tt> data type is itself laid
out with a separate location in memory for each program instance.)</p>
<pre class="literal-block">
float a;
varying float * uniform pa = &amp;a;
*pa = programIndex;  // same as (a = programIndex)
</pre>
<p>Also as in C, arrays are silently converted into pointers:</p>
<pre class="literal-block">
float a[10] = { ... };
varying float * uniform pa = a;     // pointer to first element of a
varying float * uniform pb = a + 5; // pointer to 5th element of a
</pre>
<p>Any pointer type can be explicitly typecast to another pointer type, as
long as the source type isn't a <tt class="docutils literal">varying</tt> pointer when the destination
type is a <tt class="docutils literal">uniform</tt> pointer.</p>
<pre class="literal-block">
float *pa = ...;
int *pb = (int *)pa;  // legal, but beware
</pre>
<p>Like other types, <tt class="docutils literal">uniform</tt> pointers can be typecast to be <tt class="docutils literal">varying</tt>
pointers, however.</p>
<p>Any pointer type can be assigned to a <tt class="docutils literal">void</tt> pointer without a type cast:</p>
<pre class="literal-block">
float foo(void *);
int *bar = ...;
foo(bar);
</pre>
<p>There is a special <tt class="docutils literal">NULL</tt> value that corresponds to a NULL pointer.  As a
special case, the integer value zero can be implicitly converted to a NULL
pointer and pointers are implicitly converted to boolean values in
conditional expressions.</p>
<pre class="literal-block">
void foo(float *ptr) {
    if (ptr != 0) { // or, (ptr != NULL), or just (ptr)
       ...
</pre>
<p>It is legal to explicitly type-cast a pointer type to an integer type and
back from an integer type to a pointer type.  Note that this  conversion
isn't performed implicitly, for example for function calls.</p>
</div>
<div class="section" id="function-pointer-types">
<h2>Function Pointer Types</h2>
<p>Pointers to functions can also be taken and used as in C and C++.
The syntax for declaring function pointer types is the same as in those
languages; it's generally easiest to use a <tt class="docutils literal">typedef</tt> to help:</p>
<pre class="literal-block">
int inc(int v) { return v+1; }
int dec(int v) { return v-1; }

typedef int (*FPType)(int);
FPType fptr = inc;  // vs. int (*fptr)(int) = inc;
</pre>
<p>Given a function pointer, the function it points to can be called:</p>
<pre class="literal-block">
int x = fptr(1);
</pre>
<p>It's not necessary to take the address of a function to assign it to a
function pointer or to dereference it to call the function.</p>
<p>As with pointers to data in <tt class="docutils literal">ispc</tt>, function pointers can be either
<tt class="docutils literal">uniform</tt> or <tt class="docutils literal">varying</tt>.  A call through a <tt class="docutils literal">uniform</tt> causes all of the
running program instances in the gang to call into the target function; the
implications of a call through a <tt class="docutils literal">varying</tt> function pointer are discussed
in the section <a class="reference internal" href="#gang-convergence-guarantees">Gang Convergence Guarantees</a>.</p>
</div>
<div class="section" id="reference-types">
<h2>Reference Types</h2>
<p><tt class="docutils literal">ispc</tt> also provides reference types (like C++ references) that can be
used for passing values to functions by reference, allowing functions can
return multiple results or modify existing variables.</p>
<pre class="literal-block">
void increment(float &amp;f) {
    ++f;
}
</pre>
<p>As in C++, once a reference is bound to a variable, it can't be rebound
to a different variable:</p>
<pre class="literal-block">
float a = ..., b = ...;
float &amp;r = a;  // makes r refer to a
r = b;  // assigns b to a, doesn't make r refer to b
</pre>
<p>An important limitation with references in <tt class="docutils literal">ispc</tt> is that references
can't be bound to varying lvalues; doing so causes a compile-time error to
be issued.  This situation is illustrated in the following code, where
<tt class="docutils literal">vptr</tt> is a <tt class="docutils literal">varying</tt> pointer type (in other words, there each program
instance in the gang has its own unique pointer value)</p>
<pre class="literal-block">
uniform float * uniform uptr = ...;
float &amp;ra = *uptr;  // ok
uniform float * varying vptr = ...;
float &amp;rb = *vptr;  // ERROR: *ptr is a varying lvalue type
</pre>
<p>(The rationale for this limitation is that references must be represented
as either a uniform pointer or a varying pointer internally.  While
choosing a varying pointer would provide maximum flexibility and eliminate
this restriction, it would reduce performance in the common case where a
uniform pointer is all that's needed.  As a work-around, a varying pointer
can be used in cases where a varying lvalue reference would be desired.)</p>
</div>
<div class="section" id="enumeration-types">
<h2>Enumeration Types</h2>
<p>It is possible to define user-defined enumeration types in <tt class="docutils literal">ispc</tt> with
the <tt class="docutils literal">enum</tt> keyword, which is followed by an optional enumeration type name
and then a brace-delimited list of enumerators with optional values:</p>
<pre class="literal-block">
enum Color { RED, GREEN, BLUE };
enum Flags {
    UNINITIALIZED = 0,
    INITIALIZED = 2,
    CACHED = 4
};
</pre>
<p>Each <tt class="docutils literal">enum</tt> declaration defines a new type; an attempt to implicitly
convert between enumerations of different types gives a compile-time error,
but enumerations of different types can be explicitly cast to one other.</p>
<pre class="literal-block">
Color c = (Color)CACHED;
</pre>
<p>Enumerators are implicitly converted to integer types, however, so they can
be directly passed to routines that take integer parameters and can be used
in expressions including integers, for example.  However, the integer
result of such an expression must be explicitly cast back to the enumerated
type if it to be assigned to a variable with the enumerated type.</p>
<pre class="literal-block">
Color c = RED;
int nextColor = c+1;
c = (Color)nextColor;
</pre>
<p>In this particular case, the explicit cast could be avoided using an
increment operator.</p>
<pre class="literal-block">
Color c = RED;
++c;  // c == GREEN now
</pre>
</div>
<div class="section" id="short-vector-types">
<h2>Short Vector Types</h2>
<p><tt class="docutils literal">ispc</tt> supports a parameterized type to define short vectors.  These
short vectors can only be used with basic types like <tt class="docutils literal">float</tt> and <tt class="docutils literal">int</tt>;
they can't be applied to arrays or structures.  Note: <tt class="docutils literal">ispc</tt> does <em>not</em>
use these short vectors to facilitate program vectorization; they are
purely a syntactic convenience.  Using them or writing the corresponding
code without them shouldn't lead to any noticeable performance differences
between the two approaches.</p>
<p>Syntax similar to C++ templates is used to declare these types:</p>
<pre class="literal-block">
float&lt;3&gt; foo;   // vector of three floats
double&lt;6&gt; bar;
</pre>
<p>The length of these vectors can be arbitrarily long, though the expected
usage model is relatively short vectors.</p>
<p>You can use <tt class="docutils literal">typedef</tt> to create types that don't carry around
the brackets around the vector length:</p>
<pre class="literal-block">
typedef float&lt;3&gt; float3;
</pre>
<p>The vector length must be a compile-time constant.</p>
<pre class="literal-block">
uniform int i = foo();
float&lt;i&gt; vec; // ERROR: length must be compile-time constant
</pre>
<p>Arithmetic on these short vector types works as one would expect; the
operation is applied component-wise to the values in the vector. The vector
length can be a template parameter.  Here is a short example:</p>
<pre class="literal-block">
template &lt;int N&gt;
float&lt;N&gt; func(float&lt;N&gt; a, float&lt;N&gt; b) {
    a += b;    // add individual elements of a and b
    a *= 2.;   // multiply all elements of a by 2
    bool&lt;N&gt; test = a &lt; b;  // component-wise comparison
    return test ? a : b;   // return each minimum component
}
</pre>
<p>As shown by the above code, scalar types automatically convert to
corresponding vector types when used in vector expressions.  In this
example, the constant <tt class="docutils literal">2.</tt> above is converted to a three-vector of 2s for
the multiply in the second line of the function implementation.</p>
<p>Type conversion between other short vector types also works as one would
expect, though the two vector types must have the same length:</p>
<pre class="literal-block">
float&lt;3&gt; foo = ...;
int&lt;3&gt; bar = foo;    // ok, cast elements to ints
int&lt;4&gt; bat = foo;    // ERROR: different vector lengths
float&lt;4&gt; bing = foo; // ERROR: different vector lengths
</pre>
<p>For convenience, short vectors can be initialized with a list of individual
element values:</p>
<pre class="literal-block">
float x = ..., y = ..., z = ...;
float&lt;3&gt; pos = { x, y, z };
</pre>
<p>There are two mechanisms to access the individual elements of these short
vector data types.  The first is with the array indexing operator:</p>
<pre class="literal-block">
float&lt;4&gt; foo;
for (uniform int i = 0; i &lt; 4; ++i)
    foo[i] = i;
</pre>
<p><tt class="docutils literal">ispc</tt> also provides a specialized mechanism for naming and accessing
the first few elements of short vectors based on an overloading of
the structure member access operator.  The syntax is similar to that used
in HLSL, for example.</p>
<pre class="literal-block">
float&lt;3&gt; position;
position.x = ...;
position.y = ...;
position.z = ...;
</pre>
<p>More specifically, the first element of any short vector type can be
accessed with <tt class="docutils literal">.x</tt> or <tt class="docutils literal">.r</tt>, the second with <tt class="docutils literal">.y</tt> or <tt class="docutils literal">.g</tt>, the third
with <tt class="docutils literal">.z</tt> or <tt class="docutils literal">.b</tt>, and the fourth with <tt class="docutils literal">.w</tt> or <tt class="docutils literal">.a</tt>.  Just like
using the array indexing operator with an index that is greater than the
vector size, accessing an element that is beyond the vector's size is
undefined behavior and may cause your program to crash.</p>
<p>It is also possible to construct new short vectors from other short vector
values using this syntax, extended for &quot;swizzling&quot;.  For example,</p>
<pre class="literal-block">
float&lt;3&gt; position = ...;
float&lt;3&gt; new_pos = position.zyx;  // reverse order of components
float&lt;2&gt; pos_2d = position.xy;
</pre>
<p>Though a single element can be assigned to, as in the examples above, it is
not currently possible to use swizzles on the left-hand side of assignment
expressions:</p>
<pre class="literal-block">
int8&lt;2&gt; foo = ...;
int8&lt;2&gt; bar = ...;
foo.yz = bar;   // Error: can't assign to left-hand side of expression
</pre>
</div>
<div class="section" id="array-types">
<h2>Array Types</h2>
<p>Arrays of any type can be declared just as in C and C++:</p>
<pre class="literal-block">
float a[10]; // array of 10 varying floats
uniform int * varying b[20]; // array of 20 varying pointers to uniform int
</pre>
<p>Multidimensional arrays can be specified as arrays of arrays; the following
declares an array of 5 arrays of 15 floats.</p>
<pre class="literal-block">
uniform float a[5][15];
</pre>
<p>The size of arrays must be a compile-time constant, though array size can
be determined from array initializer lists; see the following section,
<a class="reference internal" href="#declarations-and-initializers">Declarations and Initializers</a>, for details.  One exception to this is
that functions can be declared to take &quot;unsized arrays&quot; as parameters:</p>
<pre class="literal-block">
void foo(float array[], int length);
</pre>
<p>Finally, the name of an array will be automatically implicitly converted to
a uniform pointer to the array type if needed:</p>
<pre class="literal-block">
uniform int a[10];
int * uniform ap = a;
</pre>
</div>
<div class="section" id="struct-types">
<h2>Struct Types</h2>
<p>Aggregate data structures can be built using <tt class="docutils literal">struct</tt>.</p>
<pre class="literal-block">
struct Foo {
    float time;
    int flags[10];
};
</pre>
<p>As in C++, after a <tt class="docutils literal">struct</tt> is declared, an instance can be created using
the <tt class="docutils literal">struct</tt>'s name:</p>
<pre class="literal-block">
Foo f;
</pre>
<p>Alternatively, <tt class="docutils literal">struct</tt> can be used before the structure name:</p>
<pre class="literal-block">
struct Foo f;
</pre>
<p>Members in a structure declaration may each have <tt class="docutils literal">uniform</tt> or <tt class="docutils literal">varying</tt>
qualifiers, or may have no rate qualifier, in which case their variability
is initially &quot;unbound&quot;.</p>
<pre class="literal-block">
struct Bar {
    uniform int a;
    varying int b;
    int c;
};
</pre>
<p>In the declaration above, the variability of <tt class="docutils literal">c</tt> is unbound.  The
variability of struct members that are unbound is resolved when a struct is
defined; if the <tt class="docutils literal">struct</tt> is <tt class="docutils literal">uniform</tt>, then unbound members are
<tt class="docutils literal">uniform</tt>, and if the <tt class="docutils literal">struct</tt> is <tt class="docutils literal">varying</tt>, then unbound members are
varying.</p>
<pre class="literal-block">
Bar vb;
uniform Bar ub;
</pre>
<p>Here, <tt class="docutils literal">b</tt> is a <tt class="docutils literal">varying Bar</tt> (since <tt class="docutils literal">varying</tt> is the default
variability).  If <tt class="docutils literal">Bar</tt> is defined as above, then <tt class="docutils literal">vb.a</tt> is still a
<tt class="docutils literal">uniform int</tt>, since its variability was bound in the original
declaration of the <tt class="docutils literal">Bar</tt> type.  Similarly, <tt class="docutils literal">vb.b</tt> is <tt class="docutils literal">varying</tt>.  The
variability of <tt class="docutils literal">vb.c</tt> is <tt class="docutils literal">varying</tt>, since <tt class="docutils literal">vb</tt> is <tt class="docutils literal">varying</tt>.</p>
<p>(Similarly, <tt class="docutils literal">ub.a</tt> is <tt class="docutils literal">uniform</tt>, <tt class="docutils literal">ub.b</tt> is <tt class="docutils literal">varying</tt>, and <tt class="docutils literal">ub.c</tt>
is <tt class="docutils literal">uniform</tt>.)</p>
<p>In most cases, it's worthwhile to declare <tt class="docutils literal">struct</tt> members with unbound
variability so that all have the same variability for both <tt class="docutils literal">uniform</tt> and
<tt class="docutils literal">varying</tt> structs.  In particular, if a <tt class="docutils literal">struct</tt> has a member with
bound <tt class="docutils literal">uniform</tt> type, it's not possible to index into an array of the
struct type with a <tt class="docutils literal">varying</tt> index.  Consider the following example:</p>
<pre class="literal-block">
struct Foo { uniform int a; };
uniform Foo f[...] = ...;
int index = ...;
Foo fv = f[index];  // ERROR
</pre>
<p>Here, the <tt class="docutils literal">Foo</tt> type has a member with bound <tt class="docutils literal">uniform</tt> variability.
Because <tt class="docutils literal">index</tt> has a different value for each program instance in the
above code, the value of <tt class="docutils literal">f[index]</tt> needs to be able to store a different
value of <tt class="docutils literal"><span class="pre">Foo::a</span></tt> for each program instance.  However, a <tt class="docutils literal">varying Foo</tt>
still has only a single <tt class="docutils literal">a</tt> member, since <tt class="docutils literal">a</tt> was declared with
<tt class="docutils literal">uniform</tt> variability in the declaration of <tt class="docutils literal">Foo</tt>.  Therefore, the
indexing operation in the last line results in an error.</p>
</div>
<div class="section" id="operators-overloading">
<h2>Operators Overloading</h2>
<p>ISPC has support for overloaded operators for <tt class="docutils literal">struct</tt> types. This allows you
to define custom behavior when operators are used with your <tt class="docutils literal">struct</tt> types.</p>
</div>
<div class="section" id="binary-operators">
<h2>Binary Operators</h2>
<p>Binary operators that can be overloaded include: <tt class="docutils literal">*, /, %, +, <span class="pre">-,</span> &gt;&gt;, &lt;&lt;, ==,
!=, &lt;, &gt;, &lt;=, &gt;=, &amp;, |, ^, &amp;&amp;, and ||</tt>. Operator overloading support is
similar to the one in the C++ language.</p>
<p>To overload a binary operator for <tt class="docutils literal">struct S</tt>, you need to declare and
implement a function using keyword <tt class="docutils literal">operator</tt>, which accepts two parameters of
type <tt class="docutils literal">struct S</tt> or <tt class="docutils literal">struct S&amp;</tt> and returns either of these types or another
appropriate type. For example:</p>
<pre class="literal-block">
struct S { float re, im;};
struct S operator*(struct S a, struct S b) {
    struct S result;
    result.re = a.re * b.re - a.im * b.im;
    result.im = a.re * b.im + a.im * b.re;
    return result;
}

void foo(struct S a, struct S b) {
    struct S mul = a*b;
    print(&quot;a.re:   %\na.im:   %\n&quot;, a.re, a.im);
    print(&quot;b.re:   %\nb.im:   %\n&quot;, b.re, b.im);
    print(&quot;mul.re: %\nmul.im: %\n&quot;, mul.re, mul.im);
}
</pre>
</div>
<div class="section" id="unary-operators">
<h2>Unary Operators</h2>
<p>ISPC also supports overloading unary operators: <tt class="docutils literal">++, <span class="pre">--,</span> <span class="pre">-,</span> !, and ~</tt>. For
unary operators, the implementation depends on the operator type:</p>
<ol class="arabic simple">
<li><strong>Prefix Increment/Decrement (</strong> <tt class="docutils literal">++x</tt> <strong>,</strong> <tt class="docutils literal"><span class="pre">--x</span></tt> <strong>)</strong>: Define a function that
takes a reference to your struct and returns the modified struct.</li>
</ol>
<pre class="literal-block">
struct S operator++(struct S &amp;s) {
    // Increment logic here
    s.value++;
    return s;
}
</pre>
<ol class="arabic simple" start="2">
<li><strong>Postfix Increment/Decrement (</strong> <tt class="docutils literal">x++</tt> <strong>,</strong> <tt class="docutils literal"><span class="pre">x--</span></tt> <strong>)</strong>: Define a function that
takes a reference to your struct and an additional dummy int parameter,
returning the original value before modification.</li>
</ol>
<pre class="literal-block">
struct S operator++(struct S &amp;s, int) {
    struct S temp = s;  // Save original value
    s.value++;          // Modify the original
    return temp;        // Return saved original
}
</pre>
<ol class="arabic simple" start="3">
<li><strong>Unary Minus, Logical NOT, Bitwise NOT (</strong> <tt class="docutils literal"><span class="pre">-x</span></tt> <strong>,</strong> <tt class="docutils literal">!x</tt> <strong>,</strong> <tt class="docutils literal">~x</tt> <strong>)</strong>: Define a
function that takes your struct by value and returns an appropriate result.</li>
</ol>
<pre class="literal-block">
struct S operator-(struct S s) {
    struct S result;
    result.value = -s.value;
    return result;
}

bool operator!(struct S s) {
    return s.value == 0;  // Return true if &quot;empty&quot; or &quot;zero&quot;
}
</pre>
</div>
<div class="section" id="assignment-operators">
<h2>Assignment Operators</h2>
<p>ISPC also supports overloading assignment operators for <tt class="docutils literal">struct</tt> types. The assignment
operators include: <tt class="docutils literal">=, +=, <span class="pre">-=,</span> *=, /=, %=, <span class="pre">&lt;&lt;=,</span> <span class="pre">&gt;&gt;=,</span> &amp;=, |=, and ^=</tt>. This allows for
more intuitive operations with custom data types.</p>
<ol class="arabic simple">
<li><strong>Basic Assignment (</strong> <tt class="docutils literal">=</tt> <strong>)</strong>: Define a function that takes a reference to your struct
as the left-hand side and a value (or reference) of another type as the right-hand side,
returning a reference to the modified struct.</li>
</ol>
<pre class="literal-block">
struct Matrix {
    float elements[16];
};

struct Matrix&amp; operator=(struct Matrix &amp;A, const struct FloatMatrix &amp;B) {
    // Copy elements with possible type conversion
    for (uniform int i = 0; i &lt; 16; i++) {
        A.elements[i] = B.elements[i];  // Implicit float to double conversion
    }
    return A;
}
</pre>
<ol class="arabic simple" start="2">
<li><strong>Compound Assignment (</strong> <tt class="docutils literal">+=</tt> <strong>,</strong> <tt class="docutils literal"><span class="pre">-=</span></tt> <strong>, etc.)</strong>: Define a function that takes a reference
to your struct as the left-hand side and a value (or reference) as the right-hand side,
returning a reference to the modified struct.</li>
</ol>
<pre class="literal-block">
struct Vector2 {
    float x, y;
};

struct Vector2&amp; operator+=(struct Vector2 &amp;v, const struct Vector2 &amp;other) {
    v.x += other.x;
    v.y += other.y;
    return v;
}

void foo() {
    struct Vector2 v = {1.0f, 2.0f};
    struct Vector2 u = {3.0f, 4.0f};

    v += u;  // v now contains {4.0f, 6.0f}
}
</pre>
</div>
<div class="section" id="structure-of-array-types">
<h2>Structure of Array Types</h2>
<p>If data can be laid out in memory so that the executing program instances
access it via loads and stores of contiguous sections of memory, overall
performance can be improved noticeably.  One way to improve this memory
access coherence is to lay out structures in &quot;structure of arrays&quot; (SOA)
format in memory; the benefits from SOA layout are discussed in more detail
in the <a class="reference external" href="perfguide.html#use-structure-of-arrays-layout-when-possible">Use &quot;Structure of Arrays&quot; Layout When Possible</a> section in the
ispc Performance Guide.</p>
<p><tt class="docutils literal">ispc</tt> provides two key language-level capabilities for laying out and
accessing data in SOA format:</p>
<ul class="simple">
<li>An <tt class="docutils literal">soa</tt> keyword that transforms a regular <tt class="docutils literal">struct</tt> into an SOA version
of the struct.</li>
<li>Array indexing syntax for SOA arrays that transparently handles SOA
indexing.</li>
</ul>
<p>As an example, consider a simple struct declaration:</p>
<pre class="literal-block">
struct Point { float x, y, z; };
</pre>
<p>With the <tt class="docutils literal">soa</tt> rate qualifier, an array of SOA variants of this structure
can be declared:</p>
<pre class="literal-block">
soa&lt;8&gt; Point pts[...];
</pre>
<p>The in-memory layout of the <tt class="docutils literal">Point</tt> instances has had the SOA transformation
applied, such that there are 8 <tt class="docutils literal">x</tt> values in memory followed by 8 <tt class="docutils literal">y</tt>
values, and so forth.  Here is the effective declaration of <tt class="docutils literal">soa&lt;8&gt;
Point</tt>:</p>
<pre class="literal-block">
struct { uniform float x[8], y[8], z[8]; };
</pre>
<p>Given an array of SOA data, array indexing (and pointer arithmetic) is done
so that the appropriate values from the SOA array are accessed.  For
example, given:</p>
<pre class="literal-block">
soa&lt;8&gt; Point pts[...];
uniform float x = pts[10].x;
</pre>
<p>The generated code effectively accesses the second 8-wide SOA structure and
then loads the third <tt class="docutils literal">x</tt> value from it.  In general, one can write the
same code to access arrays of SOA elements as one would write to access
them in AOS layout.</p>
<p>Note that it directly follows from SOA layout that the layout of a single
element of the array isn't contiguous in memory--<tt class="docutils literal"><span class="pre">pts[1].x</span></tt> and
<tt class="docutils literal"><span class="pre">pts[1].y</span></tt> are separated by 7 <tt class="docutils literal">float</tt> values in the above example.</p>
<p>There are a few limitations to the current implementation of SOA types in
<tt class="docutils literal">ispc</tt>; these may be relaxed in future releases:</p>
<ul class="simple">
<li>It's illegal to typecast <tt class="docutils literal">soa</tt> data to <tt class="docutils literal">void</tt> pointers.</li>
<li>Reference types are illegal in SOA structures</li>
<li>All members of SOA structures must have no rate qualifiers--specifically,
it's illegal to have an explicitly-qualified <tt class="docutils literal">uniform</tt> or <tt class="docutils literal">varying</tt>
member of a structure that has <tt class="docutils literal">soa</tt> applied to it.</li>
</ul>
</div>
<div class="section" id="declarations-and-initializers">
<h2>Declarations and Initializers</h2>
<p>Variables are declared and assigned just as in C:</p>
<pre class="literal-block">
float foo = 0, bar[5];
float bat = func(foo);
</pre>
<p>More complex declarations are also possible:</p>
<pre class="literal-block">
void (*fptr_array[16])(int, int);
</pre>
<p>Here, <tt class="docutils literal">fptr_array</tt> is an array of 16 pointers to functions that have
<tt class="docutils literal">void</tt> return type and take two <tt class="docutils literal">int</tt> parameters.</p>
<p>If a variable is declared without an initializer expression, then its value
is undefined until a value is assigned to it.  Reading an undefined
variable is undefined behavior.</p>
<p>Any variable that is declared at file scope (i.e. outside a function) is a
global variable.  If a global variable is qualified with the <tt class="docutils literal">static</tt>
keyword, then it is only visible within the compilation unit in which it was
defined.  As in C/C++, a variable with a <tt class="docutils literal">static</tt> qualifier inside a
function maintains its value across function invocations.</p>
<p>As in C++, variables don't need to be declared at the start of a basic
block:</p>
<pre class="literal-block">
int foo = ...;
if (foo &lt; 2) { ... }
int bar = ...;
</pre>
<p>Variables can also be declared in <tt class="docutils literal">for</tt> statement initializers:</p>
<pre class="literal-block">
for (int i = 0; ...)
</pre>
<p>Varying variables can be initialized with individual element values in braces.
The number of values has to be equal to the target width. So, static varying
initialization is not portable across targets with different widths unless
guarded with <tt class="docutils literal">#if TARGET_WIDTH</tt>:</p>
<pre class="literal-block">
#if TARGET_WIDTH == 4
    varying int bar = { 1, 2, 3, 4 };
#elif TARGET_WIDTH == 8
    varying int bar = { 1, 2, 3, 4, 5, 6, 7, 8 };
#elif TARGET_WIDTH == 16
    ...
#endif
</pre>
<p>However, there is a special case when only one value is in braces. All
vector elements are initialized with this value:</p>
<pre class="literal-block">
varying int x = { 3, };
</pre>
<p>It is effectively equivalent to:</p>
<pre class="literal-block">
varying int x = 3;
</pre>
<p>Arrays can be initialized with individual element values in braces:</p>
<pre class="literal-block">
int bar[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };
</pre>
<p>An array with an initializer expression can be declared with some or all of
its dimensions unspecified.  In this case, the &quot;shape&quot; of the initializer
expression is used to determine the array dimensions:</p>
<pre class="literal-block">
// This corresponds to bar[2][4], due to the initializer expression
int bar[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };
</pre>
<p>Structures can also be initialized by providing element values in braces:</p>
<pre class="literal-block">
struct Color { float r, g, b; };
....
Color d = { 0.5, .75, 1.0 }; // r = 0.5, ...
</pre>
<p>Arrays of structures and arrays inside structures can be initialized with
the expected syntax:</p>
<pre class="literal-block">
struct Foo { int x; float bar[3]; };
Foo fa[2] = { { 1, { 2, 3, 4 } }, { 10, { 20, 30, 40 } } };
// now, fa[1].bar[2] == 40, and so forth
</pre>
<p>Variables with const qualifiers can be initialized using the values of
previously initialized const variables including arithmetic operations above
them:</p>
<pre class="literal-block">
const uniform int x = 1;
const uniform int y = 1 + 2;
...
const varying int x = { 1, 2, 3, 2 + 2 };
const varying int y = x * 2;
</pre>
</div>
<div class="section" id="attributes">
<h2>Attributes</h2>
<p>ISPC provides GNU-style attribute syntax using the <tt class="docutils literal">__attribute__</tt> keyword.
This section contains the list of currently supported attributes.</p>
</div>
<div class="section" id="noescape">
<h2>noescape</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((noescape))</span></tt> can be placed on a function parameter of a
uniform pointer type. It informs the compiler that the pointer cannot escape,
i.e., no reference to the object the pointer points to, derived from the
parameter value, will survive after the function returns. Applying this
attribute to a varying pointer type is not supported.</p>
<pre class="literal-block">
uniform int *uniform global_ptr;

void nonescaping(__attribute__((noescape)) uniform int * uniform ptr) {
    // OK, because ptr doesn't escape the function
    *ptr = 1;
}

void escaping(__attribute__((noescape)) uniform int * uniform ptr) {
    // Not OK, because ptr escapes the function
    global_ptr = ptr;
}
</pre>
</div>
<div class="section" id="address-space">
<h2>address_space</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((address_space(N)))</span></tt> is an Xe-specific attribute that can be
applied to a pointer type or a reference type.  The value of this type points
to or refers to the value allocated in the provided address space.  The address
space is a non-negative integer value, and the default address space is 0.
ISPC doesn't support allocation of data in address spaces other than the
default one.  Placing this attribute to a varying pointer or reference type is
not supported.</p>
<pre class="literal-block">
uniform int example(__attribute__((address_space(1))) uniform int *uniform ptr) {
    // ptr points to value in address space 1
    return *ptr;
}

// allocation of data in non-default address space is not supported
__attribute__((address_space(1))) uniform int x;
</pre>
</div>
<div class="section" id="unmangled">
<h2>unmangled</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((unmangled))</span></tt> can be applied to a function declaration to
prevent its name from being mangled. This is useful when name mangling is not
desired, but other qualifiers like <tt class="docutils literal">export</tt> or <tt class="docutils literal">extern</tt> are unsuitable due
to the additional features they introduce.</p>
<pre class="literal-block">
__attribute__((unmangled)) void foo(int a, int b);
</pre>
</div>
<div class="section" id="external-only">
<h2>external_only</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((external_only))</span></tt> can be applied to a function with
<tt class="docutils literal">export</tt> qualifier. It informs the compiler that it should not generate an
ISPC version of the function. This is useful for functions that are only called
from C/C++ in case when the user wants to reduce the size of the generated
code. The same effect can be achieved by using the <tt class="docutils literal"><span class="pre">-ffunction-sections</span></tt> compiler
option but not in all cases (e.g., shared libraries with ISPC code), so this
attribute is provided as more fine-grained control.</p>
</div>
<div class="section" id="deprecated">
<h2>deprecated</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((deprecated))</span></tt> can be applied to a function to mark it as
deprecated. The compiler will issue a warning when the function is called.
There are two ways to use this attribute in ISPC with or without a message:</p>
<pre class="literal-block">
__attribute__((deprecated)) void foo();
__attribute__((deprecated(&quot;Use bar() instead.&quot;))) void foo();
</pre>
</div>
<div class="section" id="aligned">
<h2>aligned</h2>
<p><tt class="docutils literal"><span class="pre">__attribute__((aligned(N)))</span></tt> can be applied to variables to specify their
alignment:</p>
<pre class="literal-block">
__attribute__((aligned(16))) uniform int x;
</pre>
<p>To specify the alignment of a type (such as a struct), place the attribute
after the struct definition. This means that any variable of this type will be
aligned unless overridden.</p>
<pre class="literal-block">
struct S { int x; } __attribute__((aligned(16)));
// v is aligned to 16 bytes
struct S v;
</pre>
<p>Consider the following example that combines both the type alignment and the
variable alignment.</p>
<pre class="literal-block">
// v16 is aligned to 16 bytes
__attribute__((aligned(16))) struct S { int x; } __attribute__((aligned(32))) v16;
// v32 is aligned to 32 bytes
struct S v32;
</pre>
<p>Note that ISPC doesn't support <tt class="docutils literal"><span class="pre">__attribute__((aligned))</span></tt> without an
argument. It also doesn't support placing the aligned attribute for specific
members of struct types.</p>
</div>
<div class="section" id="expressions">
<h2>Expressions</h2>
<p>All of the operators from C that you'd expect for writing expressions are
present.  Rather than enumerating all of them, here is a short summary of
the range of them available in action.</p>
<pre class="literal-block">
unsigned int i = 0x1234feed;
unsigned int j = (i &lt;&lt; 3) ^ ~(i - 3);
i += j / 6;
float f = 1.234e+23;
float g = j * f / (2.f * i);
double h = (g &lt; 2) ? f : g/5;
</pre>
<p>Structure member access and array indexing also work as in C.</p>
<pre class="literal-block">
struct Foo { float f[5]; int i; };
Foo foo = { { 1,2,3,4,5 }, 2 };
return foo.f[4] - foo.i;
</pre>
<p>The address-of operator, pointer dereference operator, and pointer member
operator also work as expected.</p>
<pre class="literal-block">
struct Foo { float a, b, c; };
Foo f;
Foo * uniform fp = &amp;f;
(*fp).a = 0;
fp-&gt;b = 1;
</pre>
<p>As in C and C++, evaluation of the <tt class="docutils literal">||</tt> and <tt class="docutils literal">&amp;&amp;</tt> logical operators as
well as the selection operator <tt class="docutils literal">? :</tt> is &quot;short-circuited&quot;; the right hand
side won't be evaluated if the value from the left-hand side determines the
logical operator's value.  For example, in the following code,
<tt class="docutils literal">array[index]</tt> won't be evaluated for values of <tt class="docutils literal">index</tt> that are
greater than or equal to <tt class="docutils literal">NUM_ITEMS</tt>.</p>
<pre class="literal-block">
if (index &lt; NUM_ITEMS &amp;&amp; array[index] &gt; 0) {
    // ...
}
</pre>
<p>Short-circuiting may impose some overhead in the generated code; for cases
where short-circuiting is undesirable due to performance impact, see
the section <a class="reference internal" href="#logical-and-selection-operations">Logical and Selection Operations</a>, which introduces helper
functions in the standard library that provide these operations without
short-circuiting.</p>
</div>
<div class="section" id="dynamic-memory-allocation">
<h2>Dynamic Memory Allocation</h2>
<p><tt class="docutils literal">ispc</tt> programs can dynamically allocate (and free) memory, using syntax
based on C++'s <tt class="docutils literal">new</tt> and <tt class="docutils literal">delete</tt> operators:</p>
<pre class="literal-block">
int count = ...;
int *ptr = new int[count];
// use ptr...
delete[] ptr;
</pre>
<p>In the above code, each program instance allocates its own <tt class="docutils literal">count</tt> sized
array of <tt class="docutils literal">uniform int</tt> values, uses that memory, and then deallocates
that memory.  Uses of <tt class="docutils literal">new</tt> and <tt class="docutils literal">delete</tt> in <tt class="docutils literal">ispc</tt> programs are
implemented as calls to C library's aligned memory allocation routines,
which are platform-dependent (<tt class="docutils literal">posix_memalign()</tt> and <tt class="docutils literal">free()</tt> on Linux*
and macOS* and <tt class="docutils literal">_aligned_malloc()</tt> and <tt class="docutils literal">_aligned_free()</tt> on Windows*). So it's
advised to pair ISPC's <tt class="docutils literal">new</tt> and <tt class="docutils literal">delete</tt> with each other, but not with
C/C++ memory management functions.</p>
<p>Note that the rules for <tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt> for <tt class="docutils literal">new</tt> are
analogous to the corresponding rules for pointers (as described in
<a class="reference internal" href="#pointer-types">Pointer Types</a>).  Specifically, if a specific rate qualifier isn't
provided with the <tt class="docutils literal">new</tt> expression, then the default is that a &quot;varying&quot;
<tt class="docutils literal">new</tt> is performed, where each program instance performs a unique
allocation.  The allocated type, in turn, is by default <tt class="docutils literal">uniform</tt>.</p>
<p>After a pointer has been deleted, it is illegal to access the memory it
points to.  However, that deletion happens on a per-program-instance basis.
In other words, consider the following code:</p>
<pre class="literal-block">
int *ptr = new int[count];
// use ptr
if (count &gt; 1000)
    delete[] ptr;
// ...
</pre>
<p>Here, the program instances where <tt class="docutils literal">count</tt> is greater than 1000 have
deleted the dynamically allocated memory pointed to by <tt class="docutils literal">ptr</tt>, but the
other program instances have not.  As such, it's illegal for the former set
of program instances to access <tt class="docutils literal">*ptr</tt>, but it's perfectly fine for the
latter set to continue to use the memory <tt class="docutils literal">ptr</tt> points to.  Note that it
is illegal to delete a pointer value returned by <tt class="docutils literal">new</tt> more than one
time.</p>
<p>Sometimes, it's useful to be able to do a single allocation for the entire
gang of program instances.  A <tt class="docutils literal">new</tt> statement can be qualified with
<tt class="docutils literal">uniform</tt> to indicate a single memory allocation:</p>
<pre class="literal-block">
float * uniform ptr = uniform new float[10];
</pre>
<p>While a regular call to <tt class="docutils literal">new</tt> returns a <tt class="docutils literal">varying</tt> pointer (i.e. a
distinct pointer to separately-allocated memory for each program instance),
a <tt class="docutils literal">uniform new</tt> performs a single allocation and returns a <tt class="docutils literal">uniform</tt>
pointer.  Recall that with a <tt class="docutils literal">uniform</tt> <tt class="docutils literal">new</tt>, the default variability
of the allocated type is <tt class="docutils literal">varying</tt>, so the above code is allocating an
array of ten <tt class="docutils literal">varying float</tt> values.</p>
<p>When using <tt class="docutils literal">uniform new</tt>, it's important to be aware of a subtlety; if
the returned pointer is stored in a varying pointer variable (as may be
appropriate and useful for the particular program being written), then the
varying pointer may inadvertently be passed to a subsequent <tt class="docutils literal">delete</tt>
statement, which is an error: effectively</p>
<pre class="literal-block">
varying float * ptr = uniform new float[10];
// use ptr...
delete ptr;  // ERROR: varying pointer is deleted
</pre>
<p>In this case, <tt class="docutils literal">ptr</tt> will be deleted multiple times, once for each
executing program instance, which is an error (unless it happens that only
a single program instance is active in the above code.)</p>
<p>When using <tt class="docutils literal">new</tt> statements, it's important to make an appropriate choice
of <tt class="docutils literal">uniform</tt> or <tt class="docutils literal">varying</tt>, for both the <tt class="docutils literal">new</tt> operator itself as well
as the type of data being allocated, based on the program's needs.
Consider the following four memory allocations:</p>
<pre class="literal-block">
uniform float * uniform p1 = uniform new uniform float[10];
float * uniform p2 = uniform new float[10];
float * p3 = new float[10];
varying float * p4 = new varying float[10];
</pre>
<p>Assuming that a <tt class="docutils literal">float</tt> is 4 bytes in memory and if the gang size is 8
program instances, then the first allocation represents a single allocation
of 10 <tt class="docutils literal">uniform float</tt> values (40 bytes), the second is a single
allocation of 10 <tt class="docutils literal">varying float</tt> values (8*4*10 = 320 bytes), the third
is 8 allocations of 10 <tt class="docutils literal">uniform float</tt> values (8 allocations of 40 bytes
each), and the last performs 8 allocations of 320 bytes each.</p>
<p>Note in particular that varying allocations of varying data types are rarely
desirable in practice.  In that case, each program instance is performing a
separate allocation of <tt class="docutils literal">varying float</tt> memory.  In this case, it's likely
that the program instances will only access a single element of each
<tt class="docutils literal">varying float</tt>, which is wasteful.  (This in turn is partially why the
allocated type is uniform by default with both pointers and <tt class="docutils literal">new</tt>
statements.)</p>
<p>Although <tt class="docutils literal">ispc</tt> doesn't support constructors or destructors like C++, it
is possible to provide initializer values with <tt class="docutils literal">new</tt> statements:</p>
<pre class="literal-block">
struct Point { float x, y, z; };
Point *pptr = new Point(10, 20, 30);
</pre>
<p>Here for example, the &quot;x&quot; element of the returned <tt class="docutils literal">Point</tt> is initialized
to have the value 10 and so forth.  In general, the rules for how
initializer values provided in <tt class="docutils literal">new</tt> statements are used to initialize
complex data types follow the same rules as initializers for variables
described in <a class="reference internal" href="#declarations-and-initializers">Declarations and Initializers</a>.</p>
</div>
<div class="section" id="type-casting">
<h2>Type Casting</h2>
<p>C-style type casting expressions work as in the C language with an exception that
unbound type is not treated as <tt class="docutils literal">varying</tt> by default.</p>
<p>When typecasting to some type <tt class="docutils literal">T</tt> without specifying a variability, the
variability is derived from the type of expression being casted. I.e. the
expression <tt class="docutils literal">(int) E</tt> has the same variability as original expression <tt class="docutils literal">E</tt>.
This feature may lead to confusion when the resulting expression is used
as a function argument. Consider an example:</p>
<pre class="literal-block">
float bar(uniform float f);
float bar(varying float f);
float foo(uniform int B) {
   return bar((float)B);
}
</pre>
<p>This code will yield the following warning suggesting to use fully qualified
type in this case.</p>
<pre class="literal-block">
Warning: Typecasting to type &quot;/*unbound*/ float&quot; (variability not specified)
       from &quot;uniform&quot; type &quot;uniform int32&quot; results in &quot;uniform&quot; variability.
       In the context of function argument it may lead to unexpected behavior.
       Casting to &quot;uniform float&quot; is recommended.
</pre>
</div>
<div class="section" id="control-flow">
<h2>Control Flow</h2>
<p><tt class="docutils literal">ispc</tt> supports most of C's control flow constructs, including <tt class="docutils literal">if</tt>,
<tt class="docutils literal">switch</tt>, <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, <tt class="docutils literal">do</tt>.  It has limited support for
<tt class="docutils literal">goto</tt>, detailed below.  It also supports variants of C's control flow
constructs that provide hints about the expected runtime coherence of the
control flow at that statement.  It also provides parallel looping
constructs, <tt class="docutils literal">foreach</tt> and <tt class="docutils literal">foreach_tiled</tt>, all of which will be
detailed in this section.</p>
</div>
<div class="section" id="conditional-statements-if">
<h2>Conditional Statements: &quot;if&quot;</h2>
<p>The <tt class="docutils literal">if</tt> statement behaves precisely as in C; the code in the &quot;true&quot;
block only executes if the condition evaluates to <tt class="docutils literal">true</tt>, and if an
optional <tt class="docutils literal">else</tt> clause is provided, the code in the &quot;else&quot; block only
executes if the condition is false.</p>
<pre class="literal-block">
float x = ..., y = ...;
if (x &lt; 0.)
    y = -y;
else
    x *= 2.;
</pre>
</div>
<div class="section" id="conditional-statements-switch">
<h2>Conditional Statements: &quot;switch&quot;</h2>
<p>The <tt class="docutils literal">switch</tt> conditional statement is also available, again with the same
behavior as in C; the expression used in the <tt class="docutils literal">switch</tt> must be of integer
type (but it can be uniform or varying).  As in C, if there is no <tt class="docutils literal">break</tt>
statement at the end of the code for a given case, execution &quot;falls
through&quot; to the following case.  These features are demonstrated in the
code below.</p>
<pre class="literal-block">
int x = ...;
switch (x) {
case 0:
case 1:
    foo(x);
    /* fall through */
case 5:
    x = 0;
    break;
default:
    x *= x;
}
</pre>
</div>
<div class="section" id="iteration-statements">
<h2>Iteration Statements</h2>
<p>In addition to the standard iteration statements <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, and
<tt class="docutils literal">do</tt>, inherited from C/C++, <tt class="docutils literal">ispc</tt> provides a number of additional
specialized ways to iterate over data.</p>
</div>
<div class="section" id="basic-iteration-statements-for-while-and-do">
<h2>Basic Iteration Statements: &quot;for&quot;, &quot;while&quot;, and &quot;do&quot;</h2>
<p><tt class="docutils literal">ispc</tt> supports <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, and <tt class="docutils literal">do</tt> loops, with the same
specification as in C.  As in C++, variables can be declared in the <tt class="docutils literal">for</tt>
statement itself:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; 10; ++i) {
  // loop body
}
// i is now no longer in scope
</pre>
<p>You can use <tt class="docutils literal">break</tt> and <tt class="docutils literal">continue</tt> statements in <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>,
and <tt class="docutils literal">do</tt> loops; <tt class="docutils literal">break</tt> breaks out of the current enclosing loop, while
<tt class="docutils literal">continue</tt> has the effect of skipping the remainder of the loop body and
jumping to the loop step.</p>
<p>Note that all of these looping constructs have the effect of executing
independently for each of the program instances in a gang; for example, if
one of them executes a <tt class="docutils literal">continue</tt> statement, other program instances
executing code in the loop body that didn't execute the <tt class="docutils literal">continue</tt> will
be unaffected by it.</p>
</div>
<div class="section" id="iteration-over-active-program-instances-foreach-active">
<h2>Iteration over active program instances: &quot;foreach_active&quot;</h2>
<p>The <tt class="docutils literal">foreach_active</tt> construct specifies a loop that serializes over the
active program instances: the loop body executes once for each active
program instance, and with only that program instance executing.</p>
<p>As an example of the use of this construct, consider an application where
each program instance independently computes an offset into a shared array
that is being updated:</p>
<pre class="literal-block">
uniform float array[...] = { ... };
int index = ...;
++array[index];
</pre>
<p>If more than one active program instance computes the same value for
<tt class="docutils literal">index</tt>, the above code has undefined behavior (see the section <a class="reference internal" href="#data-races-within-a-gang">Data
Races Within a Gang</a> for details.)  The increment of <tt class="docutils literal">array[index]</tt>
could instead be written inside a <tt class="docutils literal">foreach_active</tt> statement:</p>
<pre class="literal-block">
foreach_active (index) {
    ++array[index];
}
</pre>
<p>The variable name provided in parenthesis after the <tt class="docutils literal">foreach_active</tt>
keyword (here, <tt class="docutils literal">index</tt>), causes a <tt class="docutils literal">const uniform int64</tt> local variable
of that name to be declared, where the variable takes the <tt class="docutils literal">programIndex</tt>
value of the program instance executing at each loop iteration.</p>
<p>In the code above, because only one program instance is executing at a time
when the loop body executes, the update to <tt class="docutils literal">array</tt> is well-defined.
Note that for this particular example, the &quot;local atomic&quot; operations in
the standard library could be used instead to safely update <tt class="docutils literal">array</tt>.
(However, local atomic functions aren't always available or appropriate for
more complex cases.)</p>
<p><tt class="docutils literal">continue</tt> statements may be used inside <tt class="docutils literal">foreach_active</tt> loops, though
<tt class="docutils literal">break</tt> and <tt class="docutils literal">return</tt> are prohibited.  The order in which the active
program instances are processed in the loop is not defined.</p>
<p>See the <a class="reference external" href="perfguide.html#using-foreach-active-effectively">Using &quot;foreach_active&quot; Effectively</a> Section in the <tt class="docutils literal">ispc</tt>
Performance Guide for more details about <tt class="docutils literal">foreach_active</tt>.</p>
</div>
<div class="section" id="iteration-over-unique-elements-foreach-unique">
<h2>Iteration over unique elements: &quot;foreach_unique&quot;</h2>
<p>It can be useful to iterate over the elements of a varying variable,
processing the subsets that have the same value together.  For
example, consider a varying variable <tt class="docutils literal">x</tt> that has the values <tt class="docutils literal">{1, 2, 2,
1, 1, 0, 0, 0}</tt>, where the program is running on a target with a gang size
of 8 program instances.  Here, <tt class="docutils literal">x</tt> has three unique values across the
program instances: <tt class="docutils literal">0</tt>, <tt class="docutils literal">1</tt>, and <tt class="docutils literal">2</tt>.</p>
<p>The <tt class="docutils literal">foreach_unique</tt> looping construct allows us to iterate over these
unique values.  In the code below, the <tt class="docutils literal">foreach_unique</tt> loop body
executes once for each of the three unique values, with execution mask set
to match the program instances where the varying value matches the current
unique value being processed.</p>
<pre class="literal-block">
int x = ...; // assume {1, 2, 2, 1, 1, 0, 0, 0}
foreach_unique (val in x) {
    extern void func(uniform int v);
    func(val);
}
</pre>
<p>In the above, <tt class="docutils literal">func()</tt> will be called three times, once with value 0,
once with value 1, and once with value 2.  When it is called for value 0,
only the last three program instances will be executing, and so forth.  The
order in which the loop executes for the unique values isn't defined.</p>
<p>The varying expression that provides the values to be iterated over is only
evaluated once, and it must be of an atomic type (<tt class="docutils literal">float</tt>, <tt class="docutils literal">int</tt>,
etc.), an <tt class="docutils literal">enum</tt> type, or a pointer type.  The iteration variable <tt class="docutils literal">val</tt>
is a variable of <tt class="docutils literal">const uniform</tt> type of the iteration type; it can't be
modified within the loop.  Finally, <tt class="docutils literal">break</tt> and <tt class="docutils literal">return</tt> statements are
illegal within the loop body, but <tt class="docutils literal">continue</tt> statements are allowed.</p>
</div>
<div class="section" id="parallel-iteration-statements-foreach-and-foreach-tiled">
<h2>Parallel Iteration Statements: &quot;foreach&quot; and &quot;foreach_tiled&quot;</h2>
<p>The <tt class="docutils literal">foreach</tt> and <tt class="docutils literal">foreach_tiled</tt> constructs specify loops over a
possibly multi-dimensional domain of integer ranges.  Their role goes
beyond &quot;syntactic sugar&quot;; they provide one of the two key ways of
expressing parallel computation in <tt class="docutils literal">ispc</tt>.</p>
<p>In general, a <tt class="docutils literal">foreach</tt> or <tt class="docutils literal">foreach_tiled</tt> statement takes one or more
dimension specifiers separated by commas, where each dimension is specified
by <tt class="docutils literal">identifier = start ... end</tt>, where <tt class="docutils literal">start</tt> is a signed integer
value less than or equal to <tt class="docutils literal">end</tt>, specifying iteration over all integer
values from <tt class="docutils literal">start</tt> up to and including <tt class="docutils literal"><span class="pre">end-1</span></tt>.  An arbitrary number
of iteration dimensions may be specified, with each one spanning a
different range of values.  Within the <tt class="docutils literal">foreach</tt> loop, the given
identifiers are available as <tt class="docutils literal">const varying int32</tt> variables.  The
execution mask starts out &quot;all on&quot; at the start of each <tt class="docutils literal">foreach</tt> loop
iteration, but may be changed by control flow constructs within the loop.</p>
<p>It is illegal to have a <tt class="docutils literal">break</tt> statement or a <tt class="docutils literal">return</tt> statement
within a <tt class="docutils literal">foreach</tt> loop; a compile-time error will be issued in this
case.  (It is legal to have a <tt class="docutils literal">break</tt> in a regular <tt class="docutils literal">for</tt> loop that's
nested inside a <tt class="docutils literal">foreach</tt> loop.)  <tt class="docutils literal">continue</tt> statements are legal in
<tt class="docutils literal">foreach</tt> loops; they have the same effect as in regular <tt class="docutils literal">for</tt> loops:
a program instance that executes a <tt class="docutils literal">continue</tt> statement effectively
skips over the rest of the loop body for the current iteration.</p>
<p>It is also currently illegal to have nested <tt class="docutils literal">foreach</tt> statements; this
limitation will be removed in a future release of <tt class="docutils literal">ispc</tt>.</p>
<p>As a specific example, consider the following <tt class="docutils literal">foreach</tt> statement:</p>
<pre class="literal-block">
foreach (j = 0 ... height, i = 0 ... width) {
    // loop body--process data element (i,j)
}
</pre>
<p>It specifies a loop over a 2D domain, where the <tt class="docutils literal">j</tt> variable goes from 0
to <tt class="docutils literal"><span class="pre">height-1</span></tt> and <tt class="docutils literal">i</tt> goes from 0 to <tt class="docutils literal"><span class="pre">width-1</span></tt>.  Within the loop, the
variables <tt class="docutils literal">i</tt> and <tt class="docutils literal">j</tt> are available and initialized accordingly.</p>
<p><tt class="docutils literal">foreach</tt> loops actually cause the given iteration domain to be
automatically mapped to the program instances in the gang, so that all of
the data can be processed, in gang-sized chunks.  As a specific example,
consider a simple <tt class="docutils literal">foreach</tt> loop like the following, on a target where
the gang size is 8:</p>
<pre class="literal-block">
foreach (i = 0 ... 16) {
    // perform computation on element i
}
</pre>
<p>One possible valid execution path of this loop would be for the program
counter to step through the statements of this loop just <tt class="docutils literal"><span class="pre">16/8==2</span></tt>
times; the first time through, with the <tt class="docutils literal">varying int32</tt> variable <tt class="docutils literal">i</tt>
having the values (0,1,2,3,4,5,6,7) over the program instances, and the
second time through, having the values (8,9,10,11,12,13,14,15), thus
mapping the available program instances to all of the data by the end of
the loop's execution.</p>
<p>In general, however, you shouldn't make any assumptions about the order in
which elements of the iteration domain will be processed by a <tt class="docutils literal">foreach</tt>
loop.  For example, the following code exhibits undefined behavior:</p>
<pre class="literal-block">
uniform float a[10][100];
foreach (i = 0 ... 10, j = 0 ... 100) {
    if (i == 0)
        a[i][j] = j;
    else
        // Error: can't assume that a[i-1][j] has been set yet
        a[i][j] = a[i-1][j];
</pre>
<p>The <tt class="docutils literal">foreach</tt> statement generally subdivides the iteration domain by
selecting sets of contiguous elements in the inner-most dimension of the
iteration domain.  This decomposition approach generally leads to coherent
memory reads and writes, but may lead to worse control flow coherence than
other decompositions.</p>
<p>Therefore, <tt class="docutils literal">foreach_tiled</tt> decomposes the iteration domain in a way that
tries to map locations in the domain to program instances in a way that is
compact across all of the dimensions.  For example, on a target with an
8-wide gang size, the following <tt class="docutils literal">foreach_tiled</tt> statement might process
the iteration domain in chunks of 2 elements in <tt class="docutils literal">j</tt> and 4 elements in
<tt class="docutils literal">i</tt> each time.  (The trade-offs between these two constructs are
discussed in more detail in the <a class="reference external" href="perfguide.html#improving-control-flow-coherence-with-foreach-tiled">ispc Performance Guide</a>.)</p>
<pre class="literal-block">
foreach_tiled (j = 0 ... height, i = 0 ... width) {
    // loop body--process data element (i,j)
}
</pre>
</div>
<div class="section" id="parallel-iteration-with-programindex-and-programcount">
<h2>Parallel Iteration with &quot;programIndex&quot; and &quot;programCount&quot;</h2>
<p>In addition to <tt class="docutils literal">foreach</tt> and <tt class="docutils literal">foreach_tiled</tt>, <tt class="docutils literal">ispc</tt> provides a
lower-level mechanism for mapping SPMD program instances to data to operate
on via the built-in <tt class="docutils literal">programIndex</tt> and <tt class="docutils literal">programCount</tt> variables.</p>
<p><tt class="docutils literal">programIndex</tt> gives the index of the SIMD-lane being used for running
each program instance.  (In other words, it's a varying integer value that
has value zero for the first program instance, and so forth.)  The
<tt class="docutils literal">programCount</tt> builtin gives the total number of instances in the gang.
Together, these can be used to uniquely map executing program instances to
input data. <a class="footnote-reference" href="#footnote-5" id="footnote-reference-5">[5]</a></p>
<table class="docutils footnote" frame="void" id="footnote-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-5">[5]</a></td><td><tt class="docutils literal">programIndex</tt> is analogous to <tt class="docutils literal">get_global_id()</tt> in OpenCL* and
<tt class="docutils literal">threadIdx</tt> in CUDA*.</td></tr>
</tbody>
</table>
<p>As a specific example, consider an <tt class="docutils literal">ispc</tt> function that needs to perform
some computation on an array of data.</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; count; i += programCount) {
    float d = data[i + programIndex];
    float r = ....
    result[i + programIndex] = r;
}
</pre>
<p>Here, we've written a loop that explicitly loops over the data in chunks of
<tt class="docutils literal">programCount</tt> elements.  In each loop iteration, the running program
instances effectively collude amongst themselves using <tt class="docutils literal">programIndex</tt> to
determine which elements to work on in a way that ensures that all of the
data elements will be processed.  In this particular case, a <tt class="docutils literal">foreach</tt>
loop would be preferable, as <tt class="docutils literal">foreach</tt> naturally handles the case where
<tt class="docutils literal">programCount</tt> doesn't evenly divide the number of elements to be
processed, while the loop above assumes that case implicitly.</p>
<p>Remember that <tt class="docutils literal">foreach</tt> begins each loop iteration with an &quot;all on&quot;
execution mask, meaning all program instances are active at the start.
In contrast, a <tt class="docutils literal">for</tt> loop using <tt class="docutils literal">programIndex</tt> and <tt class="docutils literal">programCount</tt>
respects the current execution mask, which may disable some instances.
To match the behavior of <tt class="docutils literal">foreach</tt> with regard to masking, you should
use an <tt class="docutils literal">unmasked</tt> region. For example:</p>
<pre class="literal-block">
foreach (index = 0 ... 16) {
    values[index] = select(upd, newVal, values[index]);
}
</pre>
<p>will be equivalent to the following code:</p>
<pre class="literal-block">
unmasked {
    for (uniform int i = 0; i &lt; 16; i+=programCount) {
        int index = i + programIndex;
        values[index] = select(upd, newVal, values[index]);
    }
}
</pre>
</div>
<div class="section" id="unstructured-control-flow-goto">
<h2>Unstructured Control Flow: &quot;goto&quot;</h2>
<p><tt class="docutils literal">goto</tt> statements are allowed in <tt class="docutils literal">ispc</tt> programs under limited
circumstances; specifically, only when the compiler can determine that if
any program instance executes a <tt class="docutils literal">goto</tt> statement, then all of the program
instances will be running at that statement, such that all will follow the
<tt class="docutils literal">goto</tt>.</p>
<p>Put another way: it's illegal for there to be &quot;varying&quot; control flow
statements in scopes that enclose a <tt class="docutils literal">goto</tt> statement.  An error is issued
if a <tt class="docutils literal">goto</tt> is used in this situation.</p>
<p>The syntax for adding labels to <tt class="docutils literal">ispc</tt> programs and jumping to them with
<tt class="docutils literal">goto</tt> is the same as in C.  The following code shows a <tt class="docutils literal">goto</tt> based
equivalent of a <tt class="docutils literal">for</tt> loop where the induction variable <tt class="docutils literal">i</tt> goes from
zero to ten.</p>
<pre class="literal-block">
  uniform int i = 0;
check:
  if (i &gt; 10)
      goto done;
  // loop body
  ++i;
  goto check;
done:
  // ...
</pre>
</div>
<div class="section" id="coherent-control-flow-statements-cif-and-friends">
<h2>&quot;Coherent&quot; Control Flow Statements: &quot;cif&quot; and Friends</h2>
<p><tt class="docutils literal">ispc</tt> provides variants of all of the standard control flow constructs
that allow you to supply a hint that control flow is expected to be
coherent at a particular point in the program's execution.  These
mechanisms provide the compiler a hint that it's worth emitting extra code
to check to see if the control flow is in fact coherent at run-time, in
which case a simpler code path can often be executed.</p>
<p>The first of these statements is <tt class="docutils literal">cif</tt>, indicating an <tt class="docutils literal">if</tt> statement
that is expected to be coherent.  The usage of <tt class="docutils literal">cif</tt> in code is just the
same as <tt class="docutils literal">if</tt>:</p>
<pre class="literal-block">
cif (x &lt; y) {
    ...
} else {
    ...
}
</pre>
<p><tt class="docutils literal">cif</tt> provides a hint to the compiler that you expect that most of the
executing SPMD programs will all have the same result for the <tt class="docutils literal">if</tt>
condition.</p>
<p>Along similar lines, <tt class="docutils literal">cfor</tt>, <tt class="docutils literal">cdo</tt>, and <tt class="docutils literal">cwhile</tt> check to see if all
program instances are running at the start of each loop iteration; if so,
they can run a specialized code path that has been optimized for the &quot;all
on&quot; execution mask case.</p>
</div>
<div class="section" id="functions-and-function-calls">
<h2>Functions and Function Calls</h2>
<p>Like C, functions must be declared in <tt class="docutils literal">ispc</tt> before they are called,
though a forward declaration can be used before the actual function
definition.  Also like C, arrays are passed to functions by reference.
Recursive function calls are legal:</p>
<pre class="literal-block">
int gcd(int a, int b) {
    if (a == 0)
        return b;
    else
        return gcd(b%a, a);
}
</pre>
<p>Functions can be declared with a number of qualifiers that affect their
visibility and capabilities.  As in C/C++, functions have global visibility
by default.  If a function is declared with a <tt class="docutils literal">static</tt> qualifier, then it
is only visible in the file in which it was declared.</p>
<pre class="literal-block">
static float lerp(float t, float a, float b) {
    return (1.-t)*a + t*b;
}
</pre>
<p>Any function that can be launched with the <tt class="docutils literal">launch</tt> construct in <tt class="docutils literal">ispc</tt>
must have a <tt class="docutils literal">task</tt> qualifier; see <a class="reference internal" href="#task-parallelism-launch-and-sync-statements">Task Parallelism: &quot;launch&quot; and &quot;sync&quot;
Statements</a> for more discussion of launching tasks in <tt class="docutils literal">ispc</tt>.</p>
<p>A function can also be given the <tt class="docutils literal">unmasked</tt> qualifier; this qualifier
indicates that all program instances should be made active at the start of
the function execution (or, equivalently, that the current execution mask
shouldn't be passed to the function from the function call site.)  If it is
known that a function will always be called when all program instances are
executing, adding this qualifier can slightly improve performance.  See the
Section <a class="reference internal" href="#re-establishing-the-execution-mask">Re-establishing The Execution Mask</a> for more discussion of
<tt class="docutils literal">unmasked</tt> program code.</p>
<p>Functions that are intended to be called from C/C++ application code must
have the <tt class="docutils literal">export</tt> qualifier.  This causes them to have regular C linkage
and to have their declarations included in header files, if the <tt class="docutils literal">ispc</tt>
compiler is directed to generate a C/C++ header file for the file it
compiled. By default, ISPC generates both C/C++ and ISPC versions of the
function with the <tt class="docutils literal">export</tt> qualifier. In cases when there are no calls from ISPC
code to the <tt class="docutils literal">export</tt> function, the ISPC version of the function is not needed
and can be removed either by using the <tt class="docutils literal"><span class="pre">-ffunction-sections</span></tt> compiler option
together with the linker-specific option that collects garbage sections or by
using <tt class="docutils literal"><span class="pre">__attribute__((external_only))</span></tt>.</p>
<pre class="literal-block">
export uniform float inc(uniform float v) {
    return v+1;
}
</pre>
<p>Finally, any function defined with an <tt class="docutils literal">inline</tt> qualifier will always be
inlined by <tt class="docutils literal">ispc</tt>; <tt class="docutils literal">inline</tt> is not a hint, but forces inlining.  The
compiler will opportunistically inline short functions depending on their
complexity, but any function that should always be inlined should have the
<tt class="docutils literal">inline</tt> qualifier. Similarly, any function defined with a <tt class="docutils literal">noinline</tt>
qualifier will never be inlined by <tt class="docutils literal">ispc</tt>. <tt class="docutils literal">noinline</tt> and <tt class="docutils literal">inline</tt>
cannot be used on the same function.</p>
</div>
<div class="section" id="function-overloading">
<h2>Function Overloading</h2>
<p>Functions can be overloaded by parameter type. Given multiple definitions
of a function, <tt class="docutils literal">ispc</tt> uses the following model to choose the best function:
each type conversion has an associated cost. <tt class="docutils literal">ispc</tt> tries to find the conversion
with the smallest cost. When <tt class="docutils literal">ispc</tt> cannot find any suitable conversion, the
function is rejected. <tt class="docutils literal">ispc</tt> then sums the costs for all arguments and
chooses the function with the smallest total cost. If the chosen function
has some arguments whose costs are greater than their costs in another function,
this is treated as ambiguous.
Type conversion costs are ordered from lowest to highest:</p>
<ol class="arabic simple">
<li>Parameter types match exactly.</li>
<li>Function parameter type is a reference and parameters match when reference-type parameters are considered equivalent to their underlying type.</li>
<li>Function parameter type is a const-reference and parameters match when reference-type parameters are considered equivalent to their underlying type, ignoring const attributes.</li>
<li>Parameters match exactly, except constant attributes. [NO CONSTANT ATTRIBUTES LATER]</li>
<li>Parameters match exactly, except reference attributes. [NO REFERENCES ATTRIBUTES LATER]</li>
<li>Parameters match with only type conversions that don't risk losing any information (for example, converting an int16 value to an int32 parameter value.)</li>
<li>Parameters match with only promotions from uniform to varying types.</li>
<li>Parameters match using arbitrary type conversion, without changing variability from uniform to varying (e.g., int to float, float to int.)</li>
<li>Parameters match with widening and promotions from uniform to varying types. (combination of &quot;6&quot; and &quot;7&quot;)</li>
<li>Parameters match using arbitrary type conversion, including also changing variability from uniform to varying.</li>
</ol>
<ul class="simple">
<li>If the function parameter type is a reference and neither &quot;2&quot; nor &quot;3&quot; is suitable, the function is not suitable</li>
<li>If &quot;10&quot; is not suitable, the function is not suitable</li>
</ul>
</div>
<div class="section" id="re-establishing-the-execution-mask">
<h2>Re-establishing The Execution Mask</h2>
<p>As discussed in <a class="reference internal" href="#functions-and-function-calls">Functions and Function Calls</a>, a function that is
declared with an <tt class="docutils literal">unmasked</tt> qualifier starts execution with all program
instances running, regardless of the execution mask at the site of the
function call.  A block of statements can also be enclosed with
<tt class="docutils literal">unmasked</tt> to have the same effect within a function:</p>
<pre class="literal-block">
int a = ..., b = ...;
if (a &lt; b) {
    // only program instances where a &lt; b are executing here
    unmasked {
        // now all program instances are executing
    }
    // and again only the a &lt; b instances
}
</pre>
<p><tt class="docutils literal">unmasked</tt> can be useful in cases where the programmer wants to &quot;change
the axis of parallelism&quot; or use nested parallelism, as shown in the
following code:</p>
<pre class="literal-block">
uniform WorkItem items[...] = ...;
foreach (itemNum = 0 ... numItems) {
    // do computation on items[itemNum] to determine if it needs
    // further processing...
    if (/* itemNum needs processing */) {
        foreach_active (i) {
            unmasked {
                uniform int uItemNum = extract(itemNum, i);
                // apply entire gang of program instances to uItemNum
            }
        }
    }
}
</pre>
<p>The general idea is that we are first using SPMD parallelism to determine
which of the items requires further processing, checking a gang's worth of
them concurrently inside the <tt class="docutils literal">foreach</tt> loop.  Assuming that only a subset
of them needs further processing, would be wasteful to do this work within
the <tt class="docutils literal">foreach</tt> loop in the same program instance that made the initial
determination of whether more work as needed; in this case, all of the
program instances corresponding to items that didn't need further
processing would be inactive, with corresponding unused computational
capability in the system.</p>
<p>In the above code, this issue is avoided by working on each of the items
requiring more processing in turn with <tt class="docutils literal">foreach_active</tt> and then using
<tt class="docutils literal">unmasked</tt> to re-establish execution of all of the program instances.
The entire gang can in turn be applied to the computation to be done for
each <tt class="docutils literal">items[itemNum]</tt>.</p>
<p>The <tt class="docutils literal">unmasked</tt> statement should be used with care; it can lead to a
number of surprising cases of undefined program behavior.  For example,
consider the following code:</p>
<pre class="literal-block">
void func(float);
float a = ...;
float b;
if (a &lt; 0) {
    b = 0;
    unmasked {
        if (b == 0)
            func(a);
    }
}
</pre>
<p>The variable <tt class="docutils literal">a</tt> is initialized to some value and <tt class="docutils literal">b</tt> is declared but
not initialized, and thus has an undefined value.  Within the <tt class="docutils literal">if</tt> test,
we have assigned zero to <tt class="docutils literal">b</tt>, though only for the program instances
currently executing--i.e. those where <tt class="docutils literal">a &lt; 0</tt>.  After re-establishing the
executing mask with <tt class="docutils literal">unmasked</tt>, we then compare <tt class="docutils literal">b</tt> to zero--this
comparison is well-defined (and &quot;true&quot;) for the program instances where <tt class="docutils literal">a
&lt; 0</tt>, but it is undefined for any program instances where that isn't the
case, since the value of <tt class="docutils literal">b</tt> is undefined for those program instances.
Similar surprising cases can arise when writing to <tt class="docutils literal">varying</tt> variables
within <tt class="docutils literal">unmasked</tt> code.</p>
<p>As a general rule, code within an <tt class="docutils literal">unmasked</tt> block, or a function with
the <tt class="docutils literal">unmasked</tt> qualifier should use great care when accessing <tt class="docutils literal">varying</tt>
variables that were declared in an outer scope.</p>
</div>
<div class="section" id="task-parallel-execution">
<h2>Task Parallel Execution</h2>
<p>In addition to the facilities for using SPMD for parallelism across the
SIMD lanes of one processing core, <tt class="docutils literal">ispc</tt> also provides facilities for
parallel execution across multiple cores though an asynchronous function
call mechanism via the <tt class="docutils literal">launch</tt> keyword.  A function called with
<tt class="docutils literal">launch</tt> executes as an asynchronous task, often on another core in the
system.</p>
</div>
<div class="section" id="task-parallelism-launch-and-sync-statements">
<h2>Task Parallelism: &quot;launch&quot; and &quot;sync&quot; Statements</h2>
<p>One option for combining task-parallelism with <tt class="docutils literal">ispc</tt> is to just use
regular task parallelism in the C/C++ application code (be it through
Intel® oneAPI Threading Building Blocks, OpenMP or another task system), and
for tasks to use <tt class="docutils literal">ispc</tt> for SPMD parallelism across the vector lanes as
appropriate.  Alternatively, <tt class="docutils literal">ispc</tt> also has support for launching tasks
from <tt class="docutils literal">ispc</tt> code.  (Check the <tt class="docutils literal">examples/mandelbrot_tasks</tt> example to
see how it is used.)</p>
<p>Any function that is launched as a task must be declared with the
<tt class="docutils literal">task</tt> qualifier:</p>
<pre class="literal-block">
task void func(uniform float a[], uniform int index) {
    ...
    a[index] = ....
}
</pre>
<p>Tasks must return <tt class="docutils literal">void</tt>; a compile time error is issued if a
non-<tt class="docutils literal">void</tt> task is defined.</p>
<p>Given a task declaration, a task can be launched with <tt class="docutils literal">launch</tt>:</p>
<pre class="literal-block">
uniform float a[...] = ...;
launch func(a, 1);
</pre>
<p>Program execution continues asynchronously after a <tt class="docutils literal">launch</tt> statement in
a function; thus, a function shouldn't access values written by a task it
has launched within the function without synchronization.  A function can
use a <tt class="docutils literal">sync</tt> statement to wait for all launched tasks to finish:</p>
<pre class="literal-block">
launch func(a, 1);
sync;
// now safe to use computed values in a[]...
</pre>
<p>Alternatively, any function that launches tasks has an automatically-added
implicit <tt class="docutils literal">sync</tt> statement before it returns, so that functions that call
a function that launches tasks don't have to worry about outstanding
asynchronous computation from that function.</p>
<p>The task generated by a <tt class="docutils literal">launch</tt> statement is a single gang's worth of
work.  The same program instances are respectively active and inactive at
the start of the task as were active and inactive when their <tt class="docutils literal">launch</tt>
statement executed.  To make all program instances in the launched gang be
active, the <tt class="docutils literal">unmasked</tt> construct can be used (see <a class="reference internal" href="#re-establishing-the-execution-mask">Re-establishing The
Execution Mask</a>.)</p>
<p>There are two ways to write code that launches multiple tasks.
First, one task can be launched at a time, with parameters passed to the
task to help it determine what part of the overall computation it's
responsible for:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; 100; ++i)
    launch func(a, i);
</pre>
<p>This code launches 100 tasks, each of which presumably does some
computation that is keyed off of the given value <tt class="docutils literal">i</tt>.  In general, one
should launch many more tasks than there are processors in the system to
ensure good load-balancing, but not so many that the overhead of scheduling
and running tasks dominates the computation.</p>
<p>Alternatively, a number of tasks may be launched from a single <tt class="docutils literal">launch</tt>
statement.  We might instead write the above example with a single
<tt class="docutils literal">launch</tt> like this:</p>
<pre class="literal-block">
launch[100] func2(a);
</pre>
<p>Where an integer value (not necessarily a compile-time constant) is
provided to the <tt class="docutils literal">launch</tt> keyword in square brackets; this number of tasks
will be enqueued to be run asynchronously.  Within each of the tasks, two
special built-in variables are available--<tt class="docutils literal">taskIndex</tt>, and <tt class="docutils literal">taskCount</tt>.
The first, <tt class="docutils literal">taskIndex</tt>, ranges from zero to one minus the number of tasks
provided to <tt class="docutils literal">launch</tt>, and <tt class="docutils literal">taskCount</tt> equals the number of launched
tasks.  Thus, in this example we might use <tt class="docutils literal">taskIndex</tt> in the
implementation of <tt class="docutils literal">func2</tt> to determine which array element to process.</p>
<pre class="literal-block">
task void func2(uniform float a[]) {
    ...
    a[taskIndex] = ...
}
</pre>
<p>Inside functions with the <tt class="docutils literal">task</tt> qualifier, two additional built-in
variables are provided in addition to <tt class="docutils literal">taskIndex</tt> and <tt class="docutils literal">taskCount</tt>:
<tt class="docutils literal">threadIndex</tt> and <tt class="docutils literal">threadCount</tt>.  <tt class="docutils literal">threadCount</tt> gives the total
number of hardware threads that have been launched by the task system.
<tt class="docutils literal">threadIndex</tt> provides an index between zero and <tt class="docutils literal"><span class="pre">threadCount-1</span></tt> that
gives a unique index that corresponds to the hardware thread that is
executing the current task.  The <tt class="docutils literal">threadIndex</tt> can be used for accessing
data that is private to the current thread and thus doesn't require
synchronization to access under parallel execution.</p>
<p>The tasking system also supports multi-dimensional partitioning (currently up
to three dimensions). To launch a 3D grid of tasks, for example with <tt class="docutils literal">N0</tt>,
<tt class="docutils literal">N1</tt>, and <tt class="docutils literal">N2</tt> tasks in the x-, y-, and z-dimensions respectively</p>
<pre class="literal-block">
float data[N2][N1][N0]
task void foo_task()
{
   data[taskIndex2][taskIndex1][threadIndex0] = taskIndex;
}
</pre>
<p>we use the following <tt class="docutils literal">launch</tt> expressions:</p>
<pre class="literal-block">
launch [N2][N1][N0] foo_task()
</pre>
<p>or</p>
<pre class="literal-block">
launch [N0,N1,N2] foo_task()
</pre>
<p>Value of <tt class="docutils literal">taskIndex</tt> is equal to <tt class="docutils literal">taskIndex0 + <span class="pre">taskCount0*(taskIndex1</span> +
taskCount1*taskIndex2)</tt> and it ranges from <tt class="docutils literal">0</tt> to  <tt class="docutils literal"><span class="pre">taskCount-1</span></tt>, where
<tt class="docutils literal">taskCount = taskCount0*taskCount1*taskCount2</tt>. If <tt class="docutils literal">N1</tt> and/or <tt class="docutils literal">N2</tt> are
not specified in the <tt class="docutils literal">launch</tt> expression, a value of <tt class="docutils literal">1</tt> is assumed.
Finally, for a one-dimensional grid of tasks, <tt class="docutils literal">taskIndex</tt> is equivalent to
<tt class="docutils literal">taskIndex0</tt> and <tt class="docutils literal">taskCount</tt> is equivalent to <tt class="docutils literal">taskCount0</tt>.</p>
</div>
<div class="section" id="task-parallelism-runtime-requirements">
<h2>Task Parallelism: Runtime Requirements</h2>
<p>If you use the task launch feature in <tt class="docutils literal">ispc</tt>, you must provide C/C++
implementations of three specific functions that manage launching and
synchronizing parallel tasks; these functions must be linked into your
executable.  Although these functions may be implemented in any
language, they must have &quot;C&quot; linkage (i.e. their prototypes must be
declared inside an <tt class="docutils literal">extern &quot;C&quot;</tt> block if they are defined in C++.)</p>
<p>By using user-supplied versions of these functions, <tt class="docutils literal">ispc</tt> programs can
easily interoperate with software systems that have existing task systems
for managing parallelism.  If you're using <tt class="docutils literal">ispc</tt> with a system that
isn't otherwise multi-threaded and don't want to write custom
implementations of them, you can use the implementations of these functions
provided in the <tt class="docutils literal">examples/common/tasksys.cpp</tt> file in the <tt class="docutils literal">ispc</tt>
distributions.</p>
<p>If you are implementing your own task system, the remainder of this section
discusses the requirements for these calls.  You will also likely want to
review the example task systems in <tt class="docutils literal">examples/common/tasksys.cpp</tt> for reference.
If you are not implementing your own task system, you can skip reading the
remainder of this section.</p>
<p>Here are the declarations of the three functions that must be provided to
manage tasks in <tt class="docutils literal">ispc</tt>:</p>
<pre class="literal-block">
void *ISPCAlloc(void **handlePtr, int64_t size, int32_t alignment);
void ISPCLaunch(void **handlePtr, void *f, void *data, int count0, int count1, int count2);
void ISPCSync(void *handle);
</pre>
<p>All three of these functions take an opaque handle (or a pointer to an
opaque handle) as their first parameter.  This handle allows the task
system runtime to distinguish between calls to these functions from
different functions in <tt class="docutils literal">ispc</tt> code.  In this way, the task system
implementation can efficiently wait for completion on just the tasks
launched from a single function.</p>
<p>The first time one of <tt class="docutils literal">ISPCLaunch()</tt> or <tt class="docutils literal">ISPCAlloc()</tt> is called in an
<tt class="docutils literal">ispc</tt> function, the <tt class="docutils literal">void *</tt> pointed to by the <tt class="docutils literal">handlePtr</tt> parameter
will be <tt class="docutils literal">NULL</tt>.  The implementations of these function should then
initialize <tt class="docutils literal">*handlePtr</tt> to a unique handle value of some sort.  (For
example, it might allocate a small structure to record which tasks were
launched by the current function.)  In subsequent calls to these functions
in the emitted <tt class="docutils literal">ispc</tt> code, the same value for <tt class="docutils literal">handlePtr</tt> will be
passed in, such that loading from <tt class="docutils literal">*handlePtr</tt> will retrieve the value
stored in the first call.</p>
<p>At function exit (or at an explicit <tt class="docutils literal">sync</tt> statement), a call to
<tt class="docutils literal">ISPCSync()</tt> will be generated if <tt class="docutils literal">*handlePtr</tt> is non-<tt class="docutils literal">NULL</tt>.
Therefore, the handle value is passed directly to <tt class="docutils literal">ISPCSync()</tt>, rather
than a pointer to it, as in the other functions.</p>
<p>The <tt class="docutils literal">ISPCAlloc()</tt> function is used to allocate small blocks of memory to
store parameters passed to tasks.  It should return a pointer to memory
with the given size and alignment.  Note that there is no explicit
<tt class="docutils literal">ISPCFree()</tt> call; instead, all memory allocated within an <tt class="docutils literal">ispc</tt>
function should be freed when <tt class="docutils literal">ISPCSync()</tt> is called.</p>
<p><tt class="docutils literal">ISPCLaunch()</tt> is called to launch one or more asynchronous
tasks.  Each <tt class="docutils literal">launch</tt> statement in <tt class="docutils literal">ispc</tt> code causes a call to
<tt class="docutils literal">ISPCLaunch()</tt> to be emitted in the generated code.  The three parameters
after the handle pointer to the function are relatively straightforward;
the <tt class="docutils literal">void *f</tt> parameter holds a pointer to a function to call to run the
work for this task, <tt class="docutils literal">data</tt> holds a pointer to data to pass to this
function, and <tt class="docutils literal">count0</tt>, <tt class="docutils literal">count1</tt> and <tt class="docutils literal">count2</tt> are the number of instances
of this function to enqueue for asynchronous execution.  (In other words,
<tt class="docutils literal">count0</tt>, <tt class="docutils literal">count1</tt> and <tt class="docutils literal">count2</tt> correspond to the value <tt class="docutils literal">n0</tt>, <tt class="docutils literal">n1</tt>
and <tt class="docutils literal">n2</tt> in a multiple-task launch statement like <tt class="docutils literal"><span class="pre">launch[n2][n1][n0]</span></tt> or
<tt class="docutils literal">launch [n0,n1,n2]</tt> respectively.)</p>
<p>The signature of the provided function pointer <tt class="docutils literal">f</tt> is</p>
<pre class="literal-block">
void (*TaskFuncPtr)(void *data, int threadIndex, int threadCount,
                    int taskIndex, int taskCount,
                    int taskIndex0, int taskIndex1, int taskIndex2,
                    int taskCount0, int taskCount1, int taskCount2);
</pre>
<p>When this function pointer is called by one of the hardware threads managed
by the task system, the <tt class="docutils literal">data</tt> pointer passed to <tt class="docutils literal">ISPCLaunch()</tt> should
be passed to it for its first parameter; <tt class="docutils literal">threadCount</tt> gives the total
number of hardware threads that have been spawned to run tasks and
<tt class="docutils literal">threadIndex</tt> should be an integer index between zero and <tt class="docutils literal">threadCount</tt>
uniquely identifying the hardware thread that is running the task.  (These
values can be used to index into thread-local storage.)</p>
<p>The value of <tt class="docutils literal">taskCount</tt> should be the total number of tasks launched in the
<tt class="docutils literal">launch</tt> statement (it must be equal to <tt class="docutils literal">taskCount0*taskCount1*taskCount2</tt>)
that caused the call to <tt class="docutils literal">ISPCLaunch()</tt> and each of the calls to this function
should be given a unique value of <tt class="docutils literal">taskIndex</tt>, <tt class="docutils literal">taskIndex0</tt>, <tt class="docutils literal">taskIndex1</tt>
and <tt class="docutils literal">taskIndex2</tt> between zero and <tt class="docutils literal">taskCount</tt>, <tt class="docutils literal">taskCount0</tt>,
<tt class="docutils literal">taskCount1</tt> and <tt class="docutils literal">taskCount2</tt> respectively,  with <tt class="docutils literal">taskIndex = taskIndex0
+ <span class="pre">taskCount0*(taskIndex1</span> + taskCount1*taskIndex2)</tt>, to distinguish which of
the instances of the set of launched tasks is running.</p>
</div>
<div class="section" id="llvm-intrinsic-functions">
<h2>LLVM Intrinsic Functions</h2>
<p><tt class="docutils literal">ispc</tt> has an experimental feature to call LLVM intrinsics directly from
<tt class="docutils literal">ispc</tt> source code.  It's strongly discouraged to use this feature in production
code, unless the consequences are well understood.  Specifically:</p>
<ul class="simple">
<li>Availability and naming of LLVM intrinsics depend on the specific LLVM
version used for <tt class="docutils literal">ispc</tt> build and may change without notice.</li>
<li>Only basic verification of availability of target-specific intrinsics
on the target CPU is performed. The attempt of using not supported
intrinsics may lead to compiler crash.</li>
</ul>
<p>Using LLVM intrinsics is encouraged for experiments and may be useful in the
following cases:</p>
<ul class="simple">
<li>If <tt class="docutils literal">ispc</tt> fails to generate specific instruction, which is necessary
for better performance.</li>
<li>If there's no higher level primitives (in standard library or language itself)
for some of instructions. For example, this might be the case with new
ISA extensions.</li>
</ul>
<p>If you found the case where the use of LLVM intrinsics is beneficial in your code,
please let us know by opening an issue in <tt class="docutils literal">ispc</tt> <a class="reference external" href="https://github.com/ispc/ispc/issues?state=open">bug tracker</a>.</p>
<p>To use this feature, <tt class="docutils literal"><span class="pre">--enable-llvm-intrinsics</span></tt> switch must be passed to <tt class="docutils literal">ispc</tt>.
The syntax is similar to a normal function call, but the name must start with <tt class="docutils literal">&#64;</tt> symbol.
For example:</p>
<pre class="literal-block">
transpose = &#64;llvm.matrix.transpose.v8f32.i32.i32(matrix, row, column);
</pre>
<p>To detect if this feature is enabled during compile time, check if <tt class="docutils literal">ISPC_LLVM_INTRINSICS_ENABLED</tt>
macro is defined.</p>
</div>
<div class="section" id="function-templates">
<h2>Function Templates</h2>
<p><tt class="docutils literal">ispc</tt> supports function templates with syntax and semantics similar to C++.
The feature is currently experimental and may change in future versions of
<tt class="docutils literal">ispc</tt>. Please report any issues or suggestions about this feature on the
<tt class="docutils literal">ispc</tt> <a class="reference external" href="https://github.com/ispc/ispc/issues?state=open">bug tracker</a> or <a class="reference external" href="https://github.com/ispc/ispc/discussions">GitHub Discussions</a>.</p>
<p>What is currently supported:</p>
<ul class="simple">
<li>Function templates definitions with template type parameters (i.e.
<tt class="docutils literal">template&lt;typename T&gt; T add(T a, T b) { return a + b;}</tt>).</li>
<li>Calling template functions through explicit template arguments specification
syntax (i.e. <tt class="docutils literal"><span class="pre">add&lt;int&gt;(1,</span> 2);</tt>).</li>
<li>Template argument deduction and calling template functions through regular
function call syntax (i.e. <tt class="docutils literal">add(1, 2);</tt>).</li>
<li>Explicit template function instantiations (i.e.
<tt class="docutils literal">template int <span class="pre">add&lt;int&gt;(int</span> a, int b);</tt>).</li>
<li>Explicit template function specializations (i.e.
<tt class="docutils literal">template&lt;&gt; int <span class="pre">add&lt;int&gt;(int</span> a, int b) { return a - b;}</tt>).</li>
<li>Non-type template parameters (integral, bool and enumeration types).</li>
</ul>
<p>What is currently not supported, but is planned to be supported:</p>
<ul class="simple">
<li>Default values for template parameters.</li>
<li>Template arguments deduction in template function specializations.</li>
</ul>
<p>While template argument deduction rules generally follow C++, there are some
differences caused by existence of <tt class="docutils literal">uniform</tt>, <tt class="docutils literal">varying</tt> and <tt class="docutils literal">unbound</tt>
types in <tt class="docutils literal">ispc</tt> type system.  The template type parameter may resolve only to
<tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt> types, but not to <tt class="docutils literal">unbound</tt> type. Consider the
following example:</p>
<pre class="literal-block">
template &lt;typename T&gt; T add(T a, T b) { return a + b; }

void foo() {
    // Note that these two lines call the same function:
    int i1 = add&lt;int&gt;(1, 2);                 // T = varying int
    varying int i2 = add&lt;varying int&gt;(1, 2); // T = varying int

    // And this call a uniform version:
    uniform int i3 = add&lt;uniform int&gt;(1, 2); // T = uniform int
}
</pre>
<p>The variability of template type parameter <tt class="docutils literal">T</tt> may be overwritten by
<tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt> keywords, so <tt class="docutils literal">uniform T</tt> and <tt class="docutils literal">varying T</tt>  are
always valid types. But when <tt class="docutils literal">uniform T</tt> and <tt class="docutils literal">varying T</tt> are used to specify
template function parameters it has an effect on template argument deduction
process.  If variability keyword is specified and the type was successfully
deduced, the default variability of type <tt class="docutils literal">T</tt> is assumed to be the opposite of
the variability keyword.  The logic behind it is that the keyword was specified
&quot;on purpose&quot; to changed the variability of the type <tt class="docutils literal">T</tt>. Consider the
following example:</p>
<pre class="literal-block">
template &lt;typename T&gt; void foo1(T t);
template &lt;typename T&gt; void foo2(uniform T t);
template &lt;typename T&gt; void foo3(varying T t);

void bar() {
    uniform int ui;
    varying int vi;
    foo1(ui); // T is uniform int
    foo1(vi); // T is varying int
    foo2(ui); // T is varying int!
    foo2(vi); // error: varying type cannot be passed to uniform parameter
    foo3(ui); // T is uniform int!
    foo3(vi); // T is uniform int!
}
</pre>
<p>Note, to get the insight of the results of template argument deduction, it might
be useful to specify <tt class="docutils literal"><span class="pre">--ast-dump</span></tt> flag to <tt class="docutils literal">ispc</tt> compiler.</p>
<p>ISPC supports template function specializations that can be used to provide alternative
implementations for a specific set of template parameters. To define template function
specialization, the primary template should be already present in the program. If specialization
is defined after it was used, the error will be issued. Template arguments deduction in
template function specializations is not yet supported. Consider the following example:</p>
<pre class="literal-block">
// primary template
template &lt;typename T&gt; int goo(T a1, T a2) {
  return a1 + a2;
}

// declaration of specialization for int type
template &lt;&gt; int goo&lt;int&gt;(int a1, int a2);

// error: no matching function template found for specialization.
template &lt;&gt; int goo&lt;float, int&gt;(float a1, int a2) {
  return a1 + a2;
}

// error: template arguments deduction is not yet supported in template function specialization.
template &lt;&gt; int goo(float a1, float a2) {
  return a1 + a2;
}

float foo(int a1, float a2) {
  float a = goo&lt;int&gt;(a1, (int)a2); //specialization for int type will be called
  double b = goo&lt;double&gt;((double)a1, (double)a2); //primary template will be instantiated for double type
  return a + b;
}

// definition of specialization for int type
template &lt;&gt; int goo&lt;int&gt;(int a1, int a2) {
  return a1 * a2;
}

// error: template function specialization was already defined
template &lt;&gt; int goo&lt;int&gt;(int a1, int a2) {
  return a1 * a2;
}
</pre>
<p>For non-type template parameters, the following rules apply:</p>
<ul>
<li><p class="first">Uniform integral (including bool) types and enum types can be used as non-type template parameters. Unbound types are treated as uniform.
For example:</p>
<pre class="literal-block">
template &lt;int N&gt; int foo(int a) { // N is uniform int
  return a * N;
}

int bar() {
  return foo&lt;2&gt;(3); // returns 6
}

enum AB { A = 1, B = 2 };
template &lt;AB ab&gt; int baz(int a) {
  return a * ab;
}

int qux() {
  return baz&lt;B&gt;(3); // returns 6
}
</pre>
</li>
<li><p class="first">Varying types are not allowed.</p>
</li>
<li><p class="first">Integral constants, enumeration constants and template parameters (in the context of the nested templates)
can be used as non-type template arguments. Constant expressions are not allowed.</p>
</li>
<li><p class="first">Partial specialization of function templates with non-type template parameters is not allowed.</p>
</li>
</ul>
<p>You can use limited number of function specifiers with function templates:</p>
<ul class="simple">
<li>The keywords <tt class="docutils literal">export</tt>, <tt class="docutils literal">task</tt>, <tt class="docutils literal">typedef</tt>, <tt class="docutils literal">extern &quot;C&quot;</tt> and <tt class="docutils literal">extern &quot;SYCL&quot;</tt>
are not allowed.</li>
<li>Calling conventions such as <tt class="docutils literal">__vectorcall</tt> and <tt class="docutils literal">__regcall</tt> must be used in conjunction
with <tt class="docutils literal">extern &quot;C&quot;</tt> or <tt class="docutils literal">extern &quot;SYCL&quot;</tt>, so they are not allowed as well.</li>
<li>Performance hints like <tt class="docutils literal">inline</tt> and <tt class="docutils literal">noinline</tt> are allowed. Primary template, template
specializations and explicit instantiations may have different <tt class="docutils literal">inline</tt> hints.</li>
<li>Storage types <tt class="docutils literal">extern</tt> and <tt class="docutils literal">static</tt> are allowed. Template specializations and explicit
instantiations must share the same storage type as the primary template.
If not specified, the storage type will be inherited from the primary template.</li>
<li><tt class="docutils literal">unmasked</tt> specifier is allowed. Template specializations and explicit instantiations
must maintain consistency with the primary template regarding the <tt class="docutils literal">unmasked</tt> specifier.
You cannot specify <tt class="docutils literal">unmasked</tt> for a template specialization if it was not previously
specified for the primary template. If unspecified, it will be inherited from the
primary template.</li>
</ul>
</div>
</div>
<div class="section" id="the-ispc-standard-library">
<h1>The ISPC Standard Library</h1>
<p><tt class="docutils literal">ispc</tt> has a standard library that is automatically available when
compiling <tt class="docutils literal">ispc</tt> programs. (To disable the standard library, pass the
<tt class="docutils literal"><span class="pre">--nostdlib</span></tt> command-line flag to the compiler.)
For a complete list of functions available in the standard library, consult the
<a class="reference external" href="https://github.com/ispc/ispc/tree/main/stdlib/include/stdlib.isph">stdlib.isph</a> header file. This file serves as the definitive reference for all
the function declarations provided by the standard library.</p>
<div class="section" id="basic-operations-on-data">
<h2>Basic Operations On Data</h2>
</div>
<div class="section" id="logical-and-selection-operations">
<h2>Logical and Selection Operations</h2>
<p>Recall from <a class="reference internal" href="#expressions">Expressions</a> that <tt class="docutils literal">ispc</tt> short-circuits the evaluation of
logical and selection operators: given an expression like <tt class="docutils literal">(index &lt; count
&amp;&amp; array[index] == 0)</tt>, then <tt class="docutils literal">array[index] == 0</tt> is only evaluated if
<tt class="docutils literal">index &lt; count</tt> is true.  This property is useful for writing expressions
like the preceding one, where the second expression may not be safe to
evaluate in some cases.</p>
<p>This short-circuiting can impose overhead in the generated code; additional
operations are required to test the first value and to conditionally jump
over the code that evaluates the second value.  The <tt class="docutils literal">ispc</tt> compiler does
try to mitigate this cost by detecting cases where it is both safe and
inexpensive to evaluate both expressions, and skips short-circuiting in the
generated code in this case (without there being any programmer-visible
change in program behavior.)</p>
<p>For cases where the compiler can't detect this case but the programmer
wants to avoid short-circuiting behavior, the standard library provides a
few helper functions.  First, <tt class="docutils literal">and()</tt> and <tt class="docutils literal">or()</tt> provide
non-short-circuiting logical AND and OR operations.</p>
<pre class="literal-block">
bool and(bool a, bool b)
bool or(bool a, bool b)
uniform bool and(uniform bool a, uniform bool b)
uniform bool or(uniform bool a, uniform bool b)
</pre>
<p>And there are three variants of <tt class="docutils literal">select()</tt> that select between two values
based on a boolean condition.  If condition <tt class="docutils literal">cond</tt> is true, <tt class="docutils literal">t</tt> is selected,
otherwise <tt class="docutils literal">f</tt>. These are the variants of <tt class="docutils literal">select()</tt> for the <tt class="docutils literal">int8</tt> type:</p>
<pre class="literal-block">
int8 select(bool cond, int8 t, int8 f)
int8 select(uniform bool cond, int8 t, int8 f)
uniform int8 select(uniform bool cond, uniform int8 t, uniform int8 f)
</pre>
<p>There are also variants for <tt class="docutils literal">int16</tt>, <tt class="docutils literal">int32</tt>, <tt class="docutils literal">int64</tt>, <tt class="docutils literal">uint8</tt>,
<tt class="docutils literal">uint16</tt>, <tt class="docutils literal">uint32</tt>, <tt class="docutils literal">uint64</tt>, <tt class="docutils literal">float</tt>, <tt class="docutils literal">float16</tt> and <tt class="docutils literal">double</tt> types.
Uniform short vector types are also supported with the basic types listed above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt;
uniform T&lt;N&gt; select(uniform bool cond, uniform T&lt;N&gt; t, uniform T&lt;N&gt; f)

template &lt;typename T, uint N&gt;
uniform T&lt;N&gt; select(uniform bool&lt;N&gt; cond, uniform T&lt;N&gt; t, uniform T&lt;N&gt; f)
</pre>
</div>
<div class="section" id="bit-operations">
<h2>Bit Operations</h2>
<p>The various variants of <tt class="docutils literal">popcnt()</tt> return the population count--the
number of bits set in the given value.</p>
<pre class="literal-block">
uniform int popcnt(uniform int v)
int popcnt(int v)
uniform int popcnt(bool v)
</pre>
<p>A few functions determine how many leading bits in the given value are zero
and how many of the trailing bits are zero; there are also <tt class="docutils literal">unsigned</tt>
variants of these functions and variants that take <tt class="docutils literal">int64</tt> and <tt class="docutils literal">unsigned
int64</tt> types.</p>
<pre class="literal-block">
int32 count_leading_zeros(int32 v)
uniform int32 count_leading_zeros(uniform int32 v)
int32 count_trailing_zeros(int32 v)
uniform int32 count_trailing_zeros(uniform int32 v)
</pre>
<p>Sometimes it's useful to convert a <tt class="docutils literal">bool</tt> value to an integer using sign
extension so that the integer's bits are all on if the <tt class="docutils literal">bool</tt> has the
value <tt class="docutils literal">true</tt> (rather than just having the value one).  The
<tt class="docutils literal">sign_extend()</tt> functions provide this functionality:</p>
<pre class="literal-block">
int sign_extend(bool value)
uniform int sign_extend(uniform bool value)
</pre>
<p>It is also possible to convert a <tt class="docutils literal">bool</tt> varying value to an integer using
the <tt class="docutils literal">packmask</tt> function.</p>
<pre class="literal-block">
uniform int packmask(bool value)
</pre>
<p>The <tt class="docutils literal">intbits()</tt>, <tt class="docutils literal">float16bits()</tt>, <tt class="docutils literal">floatbits()</tt> and <tt class="docutils literal">doublebits()</tt>
functions can be used to implement low-level floating-point bit twiddling.
For example, <tt class="docutils literal">intbits()</tt> returns an <tt class="docutils literal">unsigned int</tt> that is a bit-for-bit
copy of the given <tt class="docutils literal">float</tt> value.  (Note: it is <strong>not</strong> the same as <tt class="docutils literal">(int)a</tt>,
but corresponds to something like <tt class="docutils literal"><span class="pre">*((int</span> <span class="pre">*)&amp;a)</span></tt> in C.</p>
<pre class="literal-block">
float16 float16bits(unsigned int16 a);
uniform float16 float16bits(uniform unsigned int16 a);
float floatbits(unsigned int a);
uniform float floatbits(uniform unsigned int a);
double doublebits(unsigned int64 a);
uniform double doublebits(uniform unsigned int64 a);
unsigned int16 intbits(float16 a);
uniform unsigned int16 intbits(uniform float16 a);
unsigned int intbits(float a);
uniform unsigned int intbits(uniform float a);
unsigned int64 intbits(double a);
uniform unsigned int64 intbits(uniform double a);
</pre>
<p>The <tt class="docutils literal">intbits()</tt>, <tt class="docutils literal">float16bits()</tt>, <tt class="docutils literal">floatbits()</tt> and <tt class="docutils literal">doublebits()</tt>
functions have no cost at runtime; they just let the compiler know how to
interpret the bits of the given value.  They make it possible to efficiently
write functions that take advantage of the low-level bit representation of
floating-point values.</p>
<p>For example, the <tt class="docutils literal">abs()</tt> function in the standard library is implemented
as follows:</p>
<pre class="literal-block">
float abs(float a) {
    unsigned int i = intbits(a);
    i &amp;= 0x7fffffff;
    return floatbits(i);
}
</pre>
<p>This code directly clears the high order bit to ensure that the given
floating-point value is positive.  This compiles down to a single <tt class="docutils literal">andps</tt>
instruction when used with an Intel® SSE target, for example.</p>
</div>
<div class="section" id="math-functions">
<h2>Math Functions</h2>
<p>The math functions in the standard library provide a relatively standard
range of mathematical functionality.</p>
<p>A number of different implementations of the transcendental math functions
are available; the math library to use can be selected with the
<tt class="docutils literal"><span class="pre">--math-lib=</span></tt> command line argument.  The following values can be provided
for this argument.</p>
<ul class="simple">
<li><tt class="docutils literal">default</tt>: <tt class="docutils literal">ispc</tt>'s default built-in math functions.  These have
reasonably high precision. (e.g. <tt class="docutils literal">sin</tt> has a maximum absolute error of
approximately 1.45e-6 over the range -10pi to 10pi.)</li>
<li><tt class="docutils literal">fast</tt>: more efficient but lower accuracy versions of the default <tt class="docutils literal">ispc</tt>
implementations.</li>
<li><tt class="docutils literal">svml</tt>: use Intel &quot;Short Vector Math Library&quot;.  This is a proprietary
library shipped as part of Intel® oneAPI DPC++/C++ Compiler (<tt class="docutils literal">icx</tt>/<tt class="docutils literal">icpx</tt>)
and Intel® oneAPI C++ Compiler Classic (<tt class="docutils literal">icc</tt>/<tt class="docutils literal">icpc</tt>).  Use either of
them to link your final executable so that the appropriate libraries
are linked.</li>
<li><tt class="docutils literal">system</tt>: use the system's math library.  On many systems, these
functions are more accurate than both of <tt class="docutils literal">ispc</tt>'s implementations.
Using these functions may be quite
inefficient; the system math functions only compute one result at a time
(i.e. they aren't vectorized), so <tt class="docutils literal">ispc</tt> has to call them once per
active program instance.  (This is not the case for the other three
options.)</li>
</ul>
</div>
<div class="section" id="basic-math-functions">
<h2>Basic Math Functions</h2>
<p>In addition to an absolute value call, <tt class="docutils literal">abs()</tt>, <tt class="docutils literal">signbits()</tt> extracts
the sign bit of the given value, returning <tt class="docutils literal">0x80000000</tt> if the sign bit
is on (i.e. the value is negative) and zero if it is off.</p>
<pre class="literal-block">
float16 abs(float16 a)
float abs(float a)
double abs(double a)
int8 abs(int8 a)
int16 abs(int16 a)
int abs(int a)
int64 abs(int64 a)

uniform float16 abs(uniform float16 a)
uniform float abs(uniform float a)
uniform double abs(uniform double a)
uniform int8 abs(uniform int8 a)
uniform int16 abs(uniform int16 a)
uniform int abs(uniform int a)
uniform int64 abs(uniform int64 a)
</pre>
<pre class="literal-block">
unsigned int16 signbits(float16 x)
unsigned int signbits(float x)
unsigned int64 signbits(double x)

uniform unsigned int16 signbits(uniform float16 x)
uniform unsigned int signbits(uniform float x)
uniform unsigned int64 signbits(uniform double x)
</pre>
<p>The <tt class="docutils literal">abs</tt> functions also support short vector types with the basic types
listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; abs(T&lt;N&gt; a)
</pre>
<p>The standard library provides four rounding functions: <tt class="docutils literal">round</tt>, <tt class="docutils literal">floor</tt>,
<tt class="docutils literal">ceil</tt> and <tt class="docutils literal">trunc</tt> for <tt class="docutils literal">float16</tt>, <tt class="docutils literal">float</tt> and <tt class="docutils literal">double</tt> data types. On
machines that support Intel®SSE or Intel® AVX, these functions all map to a
single instruction, specifically a variant of the <tt class="docutils literal">roundss</tt> and <tt class="docutils literal">roundps</tt>
instructions. This offers enhanced performance, despite a minor semantic
difference in the <tt class="docutils literal">round</tt> function when compared to the <tt class="docutils literal">C</tt> math library
<tt class="docutils literal">round</tt> function. It computes the nearest integer value, rounding halfway
cases to nearest even integer, i.e., corresponds to the <tt class="docutils literal">C</tt> math library
<tt class="docutils literal">roundeven</tt> function. These function operate regardless of the current
rounding mode and do not signal precision exceptions.</p>
<pre class="literal-block">
float16 round(float16 x)
float round(float x)
double round(double x)
float16 floor(float16 x)
float floor(float x)
double floor(double x)
float16 ceil(float16 x)
float ceil(float x)
double ceil(double x)
float16 trunc(float16 x)
float trunc(float x)
double trunc(double x)

uniform float16 round(uniform float16 x)
uniform float round(uniform float x)
uniform double round(uniform double x)
uniform float16 floor(uniform float16 x)
uniform float floor(uniform float x)
uniform double floor(uniform double x)
uniform float16 ceil(uniform float16 x)
uniform float ceil(uniform float x)
uniform double ceil(uniform double x)
uniform float16 trunc(uniform float16 x)
uniform float trunc(uniform float x)
uniform double trunc(uniform double x)
</pre>
<p>These functions also support short vector types with the basic types listed
above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; round(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; floor(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; ceil(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; trunc(T&lt;N&gt; a)
</pre>
<p><tt class="docutils literal">rcp()</tt> computes an approximation to <tt class="docutils literal">1/v</tt>.  The amount of error is
different on different architectures.</p>
<pre class="literal-block">
float16 rcp(float16 v)
uniform float16 rcp(uniform float16 v)
float rcp(float v)
uniform float rcp(uniform float v)
double rcp(double v)
uniform double rcp(uniform double v)
</pre>
<p>ISPC also provides a version of <tt class="docutils literal">rcp()</tt> with less precision which doesn't
use Newton-Raphson.</p>
<pre class="literal-block">
float rcp_fast(float v)
uniform float rcp_fast(uniform float v)
double rcp_fast(double v)
uniform double rcp_fast(uniform double v)
</pre>
<p><tt class="docutils literal">rcp()</tt> and <tt class="docutils literal">rcp_fast()</tt> functions also support short vector types with the
basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; rcp(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; rcp_fast(T&lt;N&gt; a)
</pre>
<p>The <tt class="docutils literal">fmod()</tt> functions compute the floating-point remainder of the division
operation x/y. It's semantics is equivalent to C/C++ lib functions.</p>
<pre class="literal-block">
float16 fmod(float16 x, float16 y)
uniform float16 fmod(uniform float16 x, uniform float16 y)
float fmod(float x, float y)
uniform float fmod(uniform float x, uniform float y)
double fmod(double x, double y)
uniform double fmod(uniform double x, uniform double y)
</pre>
<p><tt class="docutils literal">fmod()</tt> also support short vector types with the basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; fmod(T&lt;N&gt; x, T&lt;N&gt; y)
</pre>
<p>A standard set of minimum and maximum functions is available for all ispc
standard types.  These functions also map to corresponding intrinsic functions.</p>
<pre class="literal-block">
float16 min(float16 a, float16 b);
float min(float a, float b)
double min(double a, double b);
unsigned int8 min(unsigned int8 a, unsigned int8 b);
int8 min(int8 a, int8 b);
unsigned int16 min(unsigned int16 a, unsigned int16 b);
int16 min(int16 a, int16 b);
unsigned int min(unsigned int a, unsigned int b);
int min(int a, int b);
unsigned int64 min(unsigned int64 a, unsigned int64 b);
int64 min(int64 a, int64 b);

uniform float16 min(uniform float16 a, uniform float16 b);
uniform float min(uniform float a, uniform float b)
uniform double min(uniform double a, uniform double b);
uniform unsigned int8 min(uniform unsigned int8 a, uniform unsigned int8 b);
uniform int8 min(uniform int8 a, uniform int8 b);
uniform unsigned int16 min(uniform unsigned int16 a, uniform unsigned int16 b);
uniform int16 min(uniform int16 a, uniform int16 b);
uniform unsigned int min(uniform unsigned int a, uniform unsigned int b);
uniform int min(uniform int a, uniform int b);
uniform unsigned int64 min(uniform unsigned int64 a, uniform unsigned int64 b);
uniform int64 min(uniform int64 a, uniform int64 b);
</pre>
<pre class="literal-block">
float16 max(float16 a, float16 b);
float max(float a, float b)
double max(double a, double b);
unsigned int8 max(unsigned int8 a, unsigned int8 b);
int8 max(int8 a, int8 b);
unsigned int16 max(unsigned int16 a, unsigned int16 b);
int16 max(int16 a, int16 b);
unsigned int max(unsigned int a, unsigned int b);
int max(int a, int b);
unsigned int64 max(unsigned int64 a, unsigned int64 b);
int64 max(int64 a, int64 b);

uniform float16 max(uniform float16 a, uniform float16 b);
uniform float max(uniform float a, uniform float b)
uniform double max(uniform double a, uniform double b);
uniform unsigned int8 max(uniform unsigned int8 a, uniform unsigned int8 b);
uniform int8 max(uniform int8 a, uniform int8 b);
uniform unsigned int16 max(uniform unsigned int16 a, uniform unsigned int16 b);
uniform int16 max(uniform int16 a, uniform int16 b);
uniform unsigned int max(uniform unsigned int a, uniform unsigned int b);
uniform int max(uniform int a, uniform int b);
uniform unsigned int64 max(uniform unsigned int64 a, uniform unsigned int64 b);
uniform int64 max(uniform int64 a, uniform int64 b);
</pre>
<p>The maximum and minimum functions also support short vector types with the
basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; min(T&lt;N&gt; a, T&lt;N&gt; b)
template &lt;typename T, uint N&gt; T&lt;N&gt; max(T&lt;N&gt; a, T&lt;N&gt; b)
</pre>
<p>The <tt class="docutils literal">clamp()</tt> functions clamp the provided value to the given range.
(Their implementations are based on <tt class="docutils literal">min()</tt> and <tt class="docutils literal">max()</tt> and are thus
quite efficient.)</p>
<pre class="literal-block">
float16 clamp(float16 v, float16 low, float16 high)
float clamp(float v, float low, float high)
double clamp(double v, double low, double high)
unsigned int8 clamp(unsigned int8 v, unsigned int8 low, unsigned int8 high)
int8 clamp(int8 v, int8 low, int8 high)
unsigned int16 clamp(unsigned int16 v, unsigned int16 low, unsigned int16 high)
int16 clamp(int16 v, int16 low, int16 high)
unsigned int clamp(unsigned int v, unsigned int low, unsigned int high)
int clamp(int v, int low, int high)
unsigned int64 clamp(unsigned int64 v, unsigned int64 low, unsigned int64 high)
int64 clamp(int64 v, int64 low, int64 high)

uniform float16 clamp(uniform float16 v, uniform float16 low, uniform float16 high)
uniform float clamp(uniform float v, uniform float low, uniform float high)
uniform double clamp(uniform double v, uniform double low, uniform double high)
uniform unsigned int8 clamp(uniform unsigned int8 v, uniform unsigned int8 low,
                            uniform unsigned int8 high)
uniform int8 clamp(uniform int8 v, uniform int8 low, uniform int8 high)
uniform unsigned int16 clamp(uniform unsigned int16 v, uniform unsigned int16 low,
                             uniform unsigned int16 high)
uniform int16 clamp(uniform int16 v, uniform int16 low, uniform int16 high)
uniform unsigned int clamp(uniform unsigned int v, uniform unsigned int low,
                           uniform unsigned int high)
uniform int clamp(uniform int v, uniform int low, uniform int high)
uniform unsigned int64 clamp(uniform unsigned int64 v, uniform unsigned int64 low,
                             uniform unsigned int64 high)
uniform int64 clamp(uniform int64 v, uniform int64 low, uniform int64 high)
</pre>
<p><tt class="docutils literal">clamp()</tt> also supports short vector types with the basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; clamp(T&lt;N&gt; v, T&lt;N&gt; low, T&lt;N&gt; high)
</pre>
<p>The <tt class="docutils literal">isnan()</tt> functions test whether the given value is a floating-point
&quot;not a number&quot; value:</p>
<pre class="literal-block">
bool isnan(float16 v)
uniform bool isnan(uniform float16 v)
bool isnan(float v)
uniform bool isnan(uniform float v)
bool isnan(double v)
uniform bool isnan(uniform double v)
</pre>
<p><tt class="docutils literal">isnan()</tt> also supports short vector types with the basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; uniform bool&lt;N&gt; isnan(uniform T&lt;N&gt; v)
template &lt;typename T, uint N&gt; varying bool&lt;N&gt; isnan(varying T&lt;N&gt; v)
</pre>
<p>The <tt class="docutils literal">isinf()</tt> and <tt class="docutils literal">isfinite()</tt> functions test whether the given value is
a floating-point infinity (please note that a &quot;not a number&quot; value is neither
considered finite nor infinite):</p>
<pre class="literal-block">
bool isinf(float16 v)
uniform bool isinf(uniform float16 v)
bool isinf(float v)
uniform bool isinf(uniform float v)
bool isinf(double v)
uniform bool isinf(uniform double v)
</pre>
<pre class="literal-block">
bool isfinite(float16 v)
uniform bool isfinite(uniform float16 v)
bool isfinite(float v)
uniform bool isfinite(uniform float v)
bool isfinite(double v)
uniform bool isfinite(uniform double v)
</pre>
<p>The <tt class="docutils literal">isinf()</tt> and <tt class="docutils literal">isfinite()</tt> functions also support short vector types
with the basic types listed above.</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; uniform bool&lt;N&gt; isinf(uniform T&lt;N&gt; v)
template &lt;typename T, uint N&gt; varying bool&lt;N&gt; isinf(varying T&lt;N&gt; v)
template &lt;typename T, uint N&gt; uniform bool&lt;N&gt; isfinite(uniform T&lt;N&gt; v)
template &lt;typename T, uint N&gt; varying bool&lt;N&gt; isfinite(varying T&lt;N&gt; v)
</pre>
<p>A number of functions are also available for performing operations on 8- and
16-bit quantities; these map to specialized instructions that perform these
operations on targets that support them.  <tt class="docutils literal">avg_up()</tt> computes the average
of the two values, rounding up if their average is halfway between two
integers (i.e., it computes <tt class="docutils literal"><span class="pre">(a+b+1)/2</span></tt>).</p>
<pre class="literal-block">
int8 avg_up(int8 a, int8 b)
unsigned int8 avg_up(unsigned int8 a, unsigned int8 b)
int16 avg_up(int16 a, int16 b)
unsigned int16 avg_up(unsigned int16 a, unsigned int16 b)
</pre>
<p><tt class="docutils literal">avg_down()</tt> computes the average of the two values, rounding down (i.e.,
it computes <tt class="docutils literal"><span class="pre">(a+b)/2</span></tt>).</p>
<pre class="literal-block">
int8 avg_down(int8 a, int8 b)
unsigned int8 avg_down(unsigned int8 a, unsigned int8 b)
int16 avg_down(int16 a, int16 b)
unsigned int16 avg_down(unsigned int16 a, unsigned int16 b)
</pre>
</div>
<div class="section" id="transcendental-functions">
<h2>Transcendental Functions</h2>
<p>The square root of a given value can be computed with <tt class="docutils literal">sqrt()</tt>, which
maps to hardware square root intrinsics when available.  An approximate
reciprocal square root, <tt class="docutils literal">1/sqrt(v)</tt> is computed by <tt class="docutils literal">rsqrt()</tt>.  Like
<tt class="docutils literal">rcp()</tt>, the error from this call is different on different
architectures.</p>
<pre class="literal-block">
float16 sqrt(float16 v)
uniform float16 sqrt(uniform float16 v)
float sqrt(float v)
uniform float sqrt(uniform float v)
double sqrt(double v)
uniform double sqrt(uniform double v)
</pre>
<pre class="literal-block">
float16 rsqrt(float16 v)
uniform float16 rsqrt(uniform float16 v)
float rsqrt(float v)
uniform float rsqrt(uniform float v)
double rsqrt(double v)
uniform double rsqrt(uniform double v)
</pre>
<p><tt class="docutils literal">sqrt()</tt> and <tt class="docutils literal">rsqrt()</tt> also supports short vector types with the basic
types listed above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; sqrt(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; rsqrt(T&lt;N&gt; a)
</pre>
<p>ISPC also provides a version of <tt class="docutils literal">rsqrt()</tt> with less precision which doesn't
use Newton-Raphson.</p>
<pre class="literal-block">
float rsqrt_fast(float v)
uniform float rsqrt_fast(uniform float v)
double rsqrt_fast(double v)
uniform double rsqrt_fast(uniform double v)
</pre>
<p><tt class="docutils literal">rsqrt_fast()</tt> also supports short vector types with the basic types listed
above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; rsqrt_fast(T&lt;N&gt; v)
</pre>
<p><tt class="docutils literal">ispc</tt> provides a standard variety of calls for trigonometric functions:</p>
<pre class="literal-block">
float16 sin(float16 x)
uniform float16 sin(uniform float16 x)
float sin(float x)
uniform float sin(uniform float x)
double sin(double x)
uniform double sin(uniform double x)
</pre>
<pre class="literal-block">
float16 cos(float16 x)
uniform float16 cos(uniform float16 x)
float cos(float x)
uniform float cos(uniform float x)
double cos(double x)
uniform double cos(uniform double x)
</pre>
<pre class="literal-block">
float16 tan(float16 x)
uniform float16 tan(uniform float16 x)
float tan(float x)
uniform float tan(uniform float x)
double tan(double x)
uniform double tan(uniform double x)
</pre>
<p>These functions also supports short vector types with the basic types listed
above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; sin(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; cos(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; tan(T&lt;N&gt; a)
</pre>
<p>The corresponding inverse functions are also available:</p>
<pre class="literal-block">
float16 asin(float16 x)
uniform float16 asin(uniform float16 x)
float asin(float x)
uniform float asin(uniform float x)
double asin(const double x)
uniform double asin(uniform double x)
</pre>
<pre class="literal-block">
float16 acos(float16 x)
uniform float16 acos(uniform float16 x)
float acos(float x)
uniform float acos(uniform float x)
double acos(const double x)
uniform double acos(const uniform double x)
</pre>
<pre class="literal-block">
float16 atan(float16 x)
uniform float16 atan(uniform float16 x)
float atan(float x)
uniform float atan(uniform float x)
double atan(double x)
uniform double atan(uniform double x)
</pre>
<pre class="literal-block">
float16 atan2(float16 y, float16 x)
uniform float16 atan2(uniform float16 y, uniform float16 x)
float atan2(float y, float x)
uniform float atan2(uniform float y, uniform float x)
double atan2(double y, double x)
uniform double atan2(uniform double y, uniform double x)
</pre>
<p>The inverse functions also support short vector types with the basic types
listed above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; asin(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; acos(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; atan(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; atan2(T&lt;N&gt; a, T&lt;N&gt; b)
</pre>
<p>If both sine and cosine are needed, then the <tt class="docutils literal">sincos()</tt> call computes
both more efficiently than two calls to the respective individual
functions:</p>
<pre class="literal-block">
void sincos(float16 x, varying float16 * uniform s, varying float16 * uniform c)
void sincos(uniform float16 x, uniform float16 * uniform s,
            uniform float16 * uniform c)
void sincos(float x, varying float * uniform s, varying float * uniform c)
void sincos(uniform float x, uniform float * uniform s,
            uniform float * uniform c)
void sincos(double x, varying double * uniform s, varying double * uniform c)
void sincos(uniform double x, uniform double * uniform s,
            uniform double * uniform c)
</pre>
<p>The usual exponential and logarithmic functions are provided.</p>
<pre class="literal-block">
float16 exp(float16 x)
uniform float16 exp(uniform float16 x)
float exp(float x)
uniform float exp(uniform float x)
double exp(double x)
uniform double exp(uniform double x)
</pre>
<pre class="literal-block">
float16 log(float16 x)
uniform float16 log(uniform float16 x)
float log(float x)
uniform float log(uniform float x)
double log(double x)
uniform double log(uniform double x)
</pre>
<pre class="literal-block">
float16 pow(float16 a, float16 b)
uniform float16 pow(uniform float16 a, uniform float16 b)
float pow(float a, float b)
uniform float pow(uniform float a, uniform float b)
double pow(double a, double b)
uniform double pow(uniform double a, uniform double b)
</pre>
<p>These functions also support short vector types with the basic types listed
above:</p>
<pre class="literal-block">
template &lt;typename T, uint N&gt; T&lt;N&gt; exp(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; log(T&lt;N&gt; a)
template &lt;typename T, uint N&gt; T&lt;N&gt; pow(T&lt;N&gt; a, T&lt;N&gt; b)
</pre>
<p>The cube root function <tt class="docutils literal">cbrt</tt> is provided for <tt class="docutils literal">float</tt>, <tt class="docutils literal">double</tt> types and
for short vector of these types:</p>
<pre class="literal-block">
float cbrt(float x)
uniform float cbrt(uniform float x)
double cbrt(double x)
uniform double cbrt(uniform double x)
template &lt;typename T, uint N&gt; T&lt;N&gt; cbrt(T&lt;N&gt; a)
</pre>
<p>A few functions that end up doing low-level manipulation of the
floating-point representation in memory are available.  As in the standard
math library, <tt class="docutils literal">ldexp()</tt> multiplies the value <tt class="docutils literal">x</tt> by 2^n, and
<tt class="docutils literal">frexp()</tt> directly returns the normalized mantissa and returns the
normalized exponent as a power of two in the <tt class="docutils literal">pw2</tt> parameter.</p>
<pre class="literal-block">
float16 ldexp(float16 x, int n)
uniform float16 ldexp(uniform float16 x, uniform int n)
float ldexp(float x, int n)
uniform float ldexp(uniform float x, uniform int n)
double ldexp(double x, int n)
uniform double ldexp(uniform double x, uniform int n)
</pre>
<pre class="literal-block">
float16 frexp(float16 x, varying int *uniform pw2)
uniform float16 frexp(uniform float16 x, uniform int *uniform pw2)
float frexp(float x, varying int *uniform pw2)
uniform float frexp(uniform float x, uniform int *uniform pw2)
double frexp(double x, varying int *uniform pw2)
uniform double frexp(uniform double x, uniform int *uniform pw2)
</pre>
</div>
<div class="section" id="saturating-arithmetic">
<h2>Saturating Arithmetic</h2>
<p>A saturation (no overflow possible) addition, subtraction, multiplication and
division of all integer types are provided by the <tt class="docutils literal">ispc</tt> standard library.</p>
<pre class="literal-block">
int8 saturating_add(uniform int8 a, uniform int8 b)
int8 saturating_add(varying int8 a, varying int8 b)
unsigned int8 saturating_add(uniform unsigned int8 a, uniform unsigned int8 b)
unsigned int8 saturating_add(varying unsigned int8 a, varying unsigned int8 b)

int8 saturating_sub(uniform int8 a, uniform int8 b)
int8 saturating_sub(varying int8 a, varying int8 b)
unsigned int8 saturating_sub(uniform unsigned int8 a, uniform unsigned int8 b)
unsigned int8 saturating_sub(varying unsigned int8 a, varying unsigned int8 b)

int8 saturating_mul(uniform int8 a, uniform int8 b)
int8 saturating_mul(varying int8 a, varying int8 b)
unsigned int8 saturating_mul(uniform unsigned int8 a, uniform unsigned int8 b)
unsigned int8 saturating_mul(varying unsigned int8 a, varying unsigned int8 b)

int8 saturating_div(uniform int8 a, uniform int8 b)
int8 saturating_div(varying int8 a, varying int8 b)
unsigned int8 saturating_div(uniform unsigned int8 a, uniform unsigned int8 b)
unsigned int8 saturating_div(varying unsigned int8 a,varying unsigned int8 b)
</pre>
<p>In addition to the <tt class="docutils literal">int8</tt> variants of saturating arithmetic functions listed
above, there are versions that supports <tt class="docutils literal">int16</tt>, <tt class="docutils literal">int32</tt> and <tt class="docutils literal">int64</tt>
values as well.</p>
</div>
<div class="section" id="dot-product">
<h2>Dot product</h2>
<p>ISPC supports dot product operations for both unsigned and signed int8 and int16 data types,
utilizing the AVX-VNNI, AVX512-VNNI, and AARCH64 instruction sets. The ISPC targets that
include native dot product instruction support are <tt class="docutils literal"><span class="pre">avx2vnni-i32x*</span></tt>, <tt class="docutils literal"><span class="pre">avx512icl-i32x*</span></tt>,
<tt class="docutils literal"><span class="pre">avx512spr-i32x*</span></tt> and newer targets on x86, as well as <tt class="docutils literal"><span class="pre">neon-i32x*</span></tt> on ARM hardware with
native dot product capabilities.</p>
<p>Please note that not all combinations of signed and unsigned data types are supported on these
targets. For instance, some versions of ARMv8 natively supports only signed/signed and
unsigned/unsigned int8 dot product operations, while AVX2-VNNI and AVX512-VNNI provide support
solely for mixed-sign int8 operations.</p>
<p>If the selected target or platform lacks native dot product support, these operations are emulated.</p>
<p>These dot product operations are specifically designed to operate on <em>packed</em> input vectors,
necessitating proper packing or casting of input vectors by the programmer before use. For example:</p>
<pre class="literal-block">
uniform uint8 a[4] = {1, 2, 3, 4};
uniform int8 b[4] = {4, 3, 2, 1};
int accumulator = 1;
int result = dot4add_u8i8packed(*((uniform uint*)&amp;a[0]), *((uniform uint*)&amp;b[0]), accumulator);
</pre>
<p>For 8-bit Integer Vectors:</p>
<p>The functions below multiply groups of four unsigned 8-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
four signed 8-bit integers packed in <tt class="docutils literal">b</tt>, resulting in four intermediate unsigned 16-bit values.
The sum of these values, in combination with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying int32 dot4add_u8i8packed(varying uint32 a, varying uint32 b,
                                 varying int32 acc)
varying int32 dot4add_u8i8packed_sat(varying uint32 a, varying uint32 b,
                                     varying int32 acc) // saturate the result
</pre>
<p>The functions below multiply groups of four unsigned 8-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
four unsigned 8-bit integers packed in <tt class="docutils literal">b</tt>, resulting in four intermediate unsigned 16-bit values.
The sum of these values, in combination with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying uint32 dot4add_u8u8packed(varying uint32 a, varying uint32 b,
                                 varying uint32 acc)
varying uint32 dot4add_u8u8packed_sat(varying uint32 a, varying uint32 b,
                                     varying uint32 acc) // saturate the result
</pre>
<p>The functions below multiply groups of four signed 8-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
four signed 8-bit integers packed in <tt class="docutils literal">b</tt>, resulting in four intermediate signed 16-bit values.
The sum of these values, in combination with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying int32 dot4add_i8i8packed(varying uint32 a, varying uint32 b,
                                 varying int32 acc)
varying int32 dot4add_i8i8packed_sat(varying uint32 a, varying uint32 b,
                                     varying int32 acc) // saturate the result
</pre>
<p>For 16-bit Integer Vectors:</p>
<p>The functions below multiply groups of two unsigned 16-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
two signed 16-bit integers packed in <tt class="docutils literal">b</tt>, resulting in two intermediate signed 32-bit values.
The sum of these values, in combination with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying int32 dot2add_u16i16packed(varying uint32 a, varying uint32 b,
                                  varying int32 acc)
varying int32 dot2add_u16i16packed_sat(varying uint32 a, varying uint32 b,
                                      varying int32 acc) // saturate the result
</pre>
<p>The functions below multiply groups of two unsigned 16-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
two unsigned 16-bit integers packed in <tt class="docutils literal">b</tt>, resulting in two intermediate unsigned 32-bit values.
The sum of these values, in combination with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying uint32 dot2add_u16u16packed(varying uint32 a, varying uint32 b,
                                   varying uint32 acc)
varying uint32 dot2add_u16u16packed_sat(varying uint32 a, varying uint32 b,
                                       varying uint32 acc) // saturate the result
</pre>
<p>The functions below multiply groups of two signed 16-bit integers packed in <tt class="docutils literal">a</tt> with corresponding
two signed 16-bit integers packed in <tt class="docutils literal">b</tt>, yielding two intermediate signed 32-bit results.
The sum of these results, combined with the <tt class="docutils literal">acc</tt> accumulator, is then returned as the final result.</p>
<pre class="literal-block">
varying int32 dot2add_i16i16packed(varying uint32 a, varying uint32 b,
                                varying int32 acc)
varying int32 dot2add_i16i16packed_sat(varying uint32 a, varying uint32 b,
                                    varying int32 acc) // saturate the result
</pre>
</div>
<div class="section" id="pseudo-random-numbers">
<h2>Pseudo-Random Numbers</h2>
<p>A simple random number generator is provided by the <tt class="docutils literal">ispc</tt> standard
library.  State for the RNG is maintained in an instance of the
<tt class="docutils literal">RNGState</tt> structure, which is seeded with <tt class="docutils literal">seed_rng()</tt>.</p>
<pre class="literal-block">
struct RNGState;
void seed_rng(varying RNGState * uniform state, varying int seed)
void seed_rng(uniform RNGState * uniform state, uniform int seed)
</pre>
<p>Note that if the same <tt class="docutils literal">varying</tt> seed value is used for all of the program
instances (e.g. <tt class="docutils literal">RNGState state; <span class="pre">seed_rng(&amp;state,</span> 1);</tt>), then all of the
program instances in the gang will see the same sequence of pseudo-random
numbers.  If this behavior isn't desired, you may want to add the
<tt class="docutils literal">programIndex</tt> value to the provided seed or otherwise ensure that the
seed has a unique value for each program instance.</p>
<p>After the RNG is seeded, the <tt class="docutils literal">random()</tt> function can be used to get a
pseudo-random <tt class="docutils literal">unsigned int32</tt> value and the <tt class="docutils literal">frandom()</tt> function can
be used to get a pseudo-random <tt class="docutils literal">float</tt> value.</p>
<pre class="literal-block">
unsigned int32 random(varying RNGState * uniform state)
float frandom(varying RNGState * uniform state)
uniform unsigned int32 random(RNGState * uniform state)
uniform float frandom(uniform RNGState * uniform state)
</pre>
</div>
<div class="section" id="random-numbers">
<h2>Random Numbers</h2>
<p>Some recent CPUs (including those based on the Intel® Ivy Bridge
micro-architecture), provide support for generating true random numbers.  A
few standard library functions make this functionality available:</p>
<pre class="literal-block">
bool rdrand(uniform int32 * uniform ptr)
bool rdrand(varying int32 * uniform ptr)
bool rdrand(uniform int32 * varying ptr)
</pre>
<p>If the processor doesn't have sufficient entropy to generate a random
number, then this function fails and returns <tt class="docutils literal">false</tt>.  Otherwise, if the
processor is successful, the random value is stored in the given pointer
and <tt class="docutils literal">true</tt> is returned.  Therefore, this function should generally be
used as follows, called repeatedly until it is successful:</p>
<pre class="literal-block">
int r;
while (rdrand(&amp;r) == false)
    ; // empty loop body
</pre>
<p>In addition to the <tt class="docutils literal">int32</tt> variants of <tt class="docutils literal">rdrand()</tt> listed above, there
are versions that return <tt class="docutils literal">int16</tt>, <tt class="docutils literal">float</tt>, and <tt class="docutils literal">int64</tt> values as
well.</p>
<p>Note that when compiling to targets older than <tt class="docutils literal">avx2</tt>, the
<tt class="docutils literal">rdrand()</tt> functions always return <tt class="docutils literal">false</tt>.</p>
</div>
<div class="section" id="output-functions">
<h2>Output Functions</h2>
<p><tt class="docutils literal">ispc</tt> has a simple <tt class="docutils literal">print</tt> statement for printing values during
program execution.  In the following short <tt class="docutils literal">ispc</tt> program, there are
three uses of the <tt class="docutils literal">print</tt> statement:</p>
<pre class="literal-block">
export void foo(uniform float f[4], uniform int i) {
    float x = f[programIndex];
    print(&quot;i = %, x = %\n&quot;, i, x);
    if (x &lt; 2) {
        ++x;
        print(&quot;added to x = %\n&quot;, x);
    }
    print(&quot;last print of x = %\n&quot;, x);
}
</pre>
<p>There are a few things to note.  First, the function is called <tt class="docutils literal">print</tt>,
not <tt class="docutils literal">printf</tt> (unlike C).  Second, the formatting string passed to this
function only uses a single percent sign to denote where the corresponding
value should be printed.  You don't need to match the types of formatting
operators with the types being passed.  However, you can't currently use
the rich data formatting options that <tt class="docutils literal">printf</tt> provides (e.g. constructs
like <tt class="docutils literal">%.10f</tt>.).</p>
<p>If this function is called with the array of floats (0,1,2,3) passed in for
the <tt class="docutils literal">f</tt> parameter and the value <tt class="docutils literal">10</tt> for the <tt class="docutils literal">i</tt> parameter, it
generates the following output on a four-wide compilation target:</p>
<pre class="literal-block">
i = 10, x = [0.000000,1.000000,2.000000,3.000000]
added to x = [1.000000,2.000000,((2.000000)),((3.000000))]
last print of x = [1.000000,2.000000,2.000000,3.000000]
</pre>
<p>When a varying variable is printed, the values for program instances that
aren't currently executing are printed inside double parenthesis,
indicating inactive program instances.  The elements for inactive program
instances may have garbage values, though in some circumstances it can be
useful to see their values.</p>
</div>
<div class="section" id="assertions">
<h2>Assertions</h2>
<p>The <tt class="docutils literal">ispc</tt> standard library includes a mechanism for adding <tt class="docutils literal">assert()</tt>
statements to <tt class="docutils literal">ispc</tt> program code.  Like <tt class="docutils literal">assert()</tt> in C, the
<tt class="docutils literal">assert()</tt> function takes a single boolean expression as an argument.  If
the expression evaluates to false at runtime, then a diagnostic error
message printed and the <tt class="docutils literal">abort()</tt> function is called.</p>
<p>When called with a <tt class="docutils literal">varying</tt> quantity, an assertion triggers if the
expression evaluates to false for any of the executing program instances
at the point where it is called.  Thus, given code like:</p>
<pre class="literal-block">
int x = programIndex - 2;  // (-2, -1, 0, ... )
if (x &gt; 0)
    assert(x &gt; 0);
</pre>
<p>The <tt class="docutils literal">assert()</tt> statement will not trigger, since the condition isn't true
for any of the executing program instances at that point.  (If this
<tt class="docutils literal">assert()</tt> statement was outside of this <tt class="docutils literal">if</tt>, then it would of course
trigger.)</p>
<p>To disable all of the assertions in a file that is being compiled (e.g.,
for an optimized release build), use the <tt class="docutils literal"><span class="pre">--opt=disable-assertions</span></tt>
command-line argument.</p>
</div>
<div class="section" id="compiler-optimization-hints">
<h2>Compiler Optimization Hints</h2>
<p>The <tt class="docutils literal">ispc</tt> standard library includes a mechanism for adding <tt class="docutils literal">assume()</tt>
statements to <tt class="docutils literal">ispc</tt> program code. The <tt class="docutils literal">assume()</tt> function takes a
single uniform boolean expression as an argument. This expression is
assumed to be <tt class="docutils literal">true</tt> and this information will be used for optimization
when possible.</p>
<p>The condition used in an <tt class="docutils literal">assume()</tt> statement will not generate code and
does not imply runtime checks. It will be used solely as an optimization hint
if the compiler is able to use this information.</p>
<p>Below are some basic examples of this functionality.</p>
<pre class="literal-block">
inline uniform int bar1(uniform int a, uniform int b) {
    if (a &lt; b)
        return 2;
    return 5;
}
uniform int foo1(uniform int a, uniform int b) {
    assume(a &lt; b);
    return bar1(a, b);
}
</pre>
<p>The <tt class="docutils literal">assume()</tt> hint allows the compiler to resolve <tt class="docutils literal">a &lt; b</tt> during compile
time in <tt class="docutils literal">bar1()</tt> and return <tt class="docutils literal">2</tt> thus removing the additional branch.</p>
<pre class="literal-block">
inline void bar2(uniform int * uniform a) {
    if (a != NULL) {
        a[2] = 9;
    }
 }
 void foo2(uniform int a[]) {
    assume(a != NULL);
    bar2(a);
 }
</pre>
<p>The <tt class="docutils literal">assume()</tt> hint allows the compiler to remove <tt class="docutils literal">a != NULL</tt> during compile
time in <tt class="docutils literal">bar2()</tt> thus removing the additional check.</p>
<pre class="literal-block">
int foo3(uniform int a[], uniform int count) {
    int ret = 0;
    assume(count % programCount == 0);
    foreach (i = 0 ... count) {
        ret += a[i];
    }
    return ret;
}
</pre>
<p>The <tt class="docutils literal">assume()</tt> hint informs the compiler that <tt class="docutils literal">count</tt> is a multiple of
<tt class="docutils literal">programCount</tt> at compile time. This results in removal of the remainder
loop usually required for <tt class="docutils literal">foreach</tt>.</p>
<pre class="literal-block">
typedef float&lt;TARGET_WIDTH&gt; AlignedFloat;
unmasked void foo4(uniform float Result[], const uniform float Source1[], const uniform unsigned int Iterations)
{
     assume(((uniform uint64)((void*)Source1) &amp; (32 * TARGET_WIDTH)-1) == 0);
     assume(((uniform uint64)((void*)Result) &amp; (32 * TARGET_WIDTH)-1) == 0);
     uniform AlignedFloat S1;
     S1[programIndex] = Source1[programIndex];
     const uniform AlignedFloat R = S1;
     Result[programIndex] = R[programIndex];
}
</pre>
<p>The <tt class="docutils literal">assume()</tt> hint informs the compiler that memory locations used by
loads and stores are aligned. This results in aligned instructions instead
of unaligned instructions.</p>
<p>The <tt class="docutils literal">ispc</tt> preprocessor <tt class="docutils literal">#pragma unroll</tt> and <tt class="docutils literal">#pragma nounroll</tt> directives provide loop unrolling optimization hints to the compiler.
The pragma is placed immediately before a loop statement.
Currently, this functionality is limited to <tt class="docutils literal">foreach</tt> and uniform <tt class="docutils literal">for</tt> and <tt class="docutils literal"><span class="pre">do-while</span></tt>.
Varying <tt class="docutils literal">for</tt> is also supported, but generates sub-optimal code compared to <tt class="docutils literal">foreach</tt> and outputs a performance warning.</p>
<table border="1" class="docutils">
<caption><tt class="docutils literal">#pragma unroll</tt> and <tt class="docutils literal">#pragma nounroll</tt> directives and their functions:</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">#pragma</tt> name</td>
<td>Use</td>
</tr>
<tr><td><tt class="docutils literal">#pragma unroll COUNT</tt></td>
<td>Directs the loop unroller to unroll the loop <tt class="docutils literal">COUNT</tt> times.
The parameter may optionally be enclosed in parentheses:  <tt class="docutils literal">#pragma unroll (COUNT)</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">#pragma unroll</tt></td>
<td>Directs the loop unroller to fully unroll the loop if possible.</td>
</tr>
<tr><td><tt class="docutils literal">#pragma nounroll</tt></td>
<td>Directs the loop unroller to not unroll the loop.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cross-program-instance-operations">
<h2>Cross-Program Instance Operations</h2>
<p><tt class="docutils literal">ispc</tt> programs are often used to express independently-executing
programs performing computation on separate data elements (i.e., pure
data-parallelism). However, it's often useful for the
program instances to cooperate in computing results.  The
cross-lane operations described in this section provide primitives for
communication between the running program instances in the gang.</p>
<p>The <tt class="docutils literal">lanemask()</tt> function returns an integer that encodes which of the
current SPMD program instances are currently executing.  The i'th bit is
set if the i'th program instance lane is currently active.</p>
<pre class="literal-block">
uniform unsigned int64 lanemask()
</pre>
<p>To broadcast a value from one program instance to all of the others, a
<tt class="docutils literal">broadcast()</tt> function is available.  It broadcasts the value of the
<tt class="docutils literal">value</tt> parameter for the program instance given by <tt class="docutils literal">index</tt> to all of
the running program instances.</p>
<pre class="literal-block">
int8 broadcast(int8 value, uniform int index)
unsigned int8 broadcast(unsigned int8 value, uniform int index)
int16 broadcast(int16 value, uniform int index)
unsigned int16 broadcast(unsigned int16 value, uniform int index)
int32 broadcast(int32 value, uniform int index)
unsigned int32 broadcast(unsigned int32 value, uniform int index)
int64 broadcast(int64 value, uniform int index)
unsigned int64 broadcast(unsigned int64 value, uniform int index)
float16 broadcast(float16 value, uniform int index)
float broadcast(float value, uniform int index)
double broadcast(double value, uniform int index)
</pre>
<p>The <tt class="docutils literal">rotate()</tt> function allows each program instance to find the value of
the given value that their neighbor <tt class="docutils literal">offset</tt> steps away has.  For
example, on an 8-wide target, if <tt class="docutils literal">value</tt> has the value (1, 2, 3, 4, 5,
6, 7, 8) across the gang of running program instances, then <tt class="docutils literal">rotate(value,
<span class="pre">-1)</span></tt> causes the first program instance to get the value 8, the second
program instance to get the value 1, the third 2, and so forth.  The
provided offset value can be positive or negative, and may be greater than
the size of the gang (it is masked to ensure valid offsets).</p>
<pre class="literal-block">
unsigned int8 rotate(unsigned int8 value, uniform int offset)
int8 rotate(int8 value, uniform int offset)
unsigned int16 rotate(unsigned int16 value, uniform int offset)
int16 rotate(int16 value, uniform int offset)
unsigned int32 rotate(unsigned int32 value, uniform int offset)
int32 rotate(int32 value, uniform int offset)
unsigned int64 rotate(unsigned int64 value, uniform int offset)
int64 rotate(int64 value, uniform int offset)
float16 rotate(float16 value, uniform int offset)
float rotate(float value, uniform int offset)
double rotate(double value, uniform int offset)
</pre>
<p>The <tt class="docutils literal">shift()</tt> function allows each program instance to find the value of
the given value that their neighbor <tt class="docutils literal">offset</tt> steps away has.  This is similar
to <tt class="docutils literal">rotate()</tt> with the exception that values are not circularly shifted.
Instead, zeroes are shifted in where appropriate.</p>
<pre class="literal-block">
int8 shift(int8 value, uniform int offset)
unsigned int8 shift(unsigned int8 value, uniform int offset)
int16 shift(int16 value, uniform int offset)
unsigned int16 shift(unsigned int16 value, uniform int offset)
int32 shift(int32 value, uniform int offset)
unsigned int32 shift(unsigned int32 value, uniform int offset)
int64 shift(int64 value, uniform int offset)
unsigned int64 shift(unsigned int64 value, uniform int offset)
float16 shift(float16 value, uniform int offset)
float shift(float value, uniform int offset)
double shift(double value, uniform int offset)
</pre>
<p>Finally, the <tt class="docutils literal">shuffle()</tt> functions allow two variants of fully general
shuffling of values among the program instances.  For the first version,
each program instance's value of permutation gives the program instance
from which to get the value of <tt class="docutils literal">value</tt>.  The provided values for
<tt class="docutils literal">permutation</tt> must all be between 0 and the gang size.</p>
<pre class="literal-block">
int8 shuffle(int8 value, int permutation)
unsigned int8 shuffle(unsigned int8 value, int permutation)
int16 shuffle(int16 value, int permutation)
unsigned int16 shuffle(unsigned int16 value, int permutation)
int32 shuffle(int32 value, int permutation)
unsigned int32 shuffle(unsigned int32 value, int permutation)
int64 shuffle(int64 value, int permutation)
unsigned int64 shuffle(unsigned int64 value, int permutation)
float16 shuffle(float16 value, int permutation)
float shuffle(float value, int permutation)
double shuffle(double value, int permutation)
</pre>
<p>The second variant of <tt class="docutils literal">shuffle()</tt> permutes over the extended vector that
is the concatenation of the two provided values.  In other words, a value
of 0 in an element of <tt class="docutils literal">permutation</tt> corresponds to the first element of
<tt class="docutils literal">value0</tt>, the value of two times the gang size, minus one corresponds to
the last element of <tt class="docutils literal">value1</tt>, etc.)</p>
<pre class="literal-block">
int8 shuffle(int8 value0, int8 value1, int permutation)
unsigned int8 shuffle(unsigned int8 value0, unsigned int8 value1, int permutation)
int16 shuffle(int16 value0, int16 value1, int permutation)
unsigned int16 shuffle(unsigned int16 value0, unsigned int16 value1, int permutation)
int32 shuffle(int32 value0, int32 value1, int permutation)
unsigned int32 shuffle(unsigned int32 value0, unsigned int32 value1, int permutation)
int64 shuffle(int64 value0, int64 value1, int permutation)
unsigned int64 shuffle(unsigned int64 value0, unsigned int64 value1, int permutation)
float16 shuffle(float16 value0, float16 value1, int permutation)
float shuffle(float value0, float value1, int permutation)
double shuffle(double value0, double value1, int permutation)
</pre>
<p>Finally, there are primitive operations that extract and set values in the
SIMD lanes.  You can implement all of the broadcast, rotate, shift, and shuffle
operations described above in this section from these routines, though in
general, not as efficiently.  These routines are useful for implementing
other reductions and cross-lane communication that isn't included in the
above, though.  Given a <tt class="docutils literal">varying</tt> value, <tt class="docutils literal">extract()</tt> returns the i'th
element of it as a single <tt class="docutils literal">uniform</tt> value.</p>
<pre class="literal-block">
uniform bool extract(bool x, uniform int i)
uniform int8 extract(int8 x, uniform int i)
uniform unsigned int8 extract(unsigned int8 x, uniform int i)
uniform int16 extract(int16 x, uniform int i)
uniform unsigned int16 extract(unsigned int16 x, uniform int i)
uniform int32 extract(int32 x, uniform int i)
uniform unsigned int32 extract(unsigned int32 x, uniform int i)
uniform int64 extract(int64 x, uniform int i)
uniform unsigned int64 extract(unsigned int64 x, uniform int i)
uniform float16 extract(float16 x, uniform int i)
uniform float extract(float x, uniform int i)
uniform double extract(double x, uniform int i)
</pre>
<p>Similarly, <tt class="docutils literal">insert</tt> returns a new value
where the <tt class="docutils literal"><span class="pre">i``th</span> element of ``x</tt> has been replaced with the value <tt class="docutils literal">v</tt>.</p>
<pre class="literal-block">
bool insert(bool x, uniform int i, uniform bool v)
int8 insert(int8 x, uniform int i, uniform int8 v)
unsigned int8 insert(unsigned int8 x, uniform int i, uniform unsigned int8 v)
int16 insert(int16 x, uniform int i, uniform int16 v)
unsigned int16 insert(unsigned int16 x, uniform int i, uniform unsigned int16 v)
int32 insert(int32 x, uniform int i, uniform int32 v)
unsigned int32 insert(unsigned int32 x, uniform int i, uniform unsigned int32 v)
int64 insert(int64 x, uniform int i, uniform int64 v)
unsigned int64 insert(unsigned int64 x, uniform int i, uniform unsigned int64 v)
float16 insert(float16 x, uniform int i, uniform float16 v)
float insert(float x, uniform int i, uniform float v)
double insert(double x, uniform int i, uniform double v)
</pre>
</div>
<div class="section" id="reductions">
<h2>Reductions</h2>
<p>A number of routines are available to evaluate conditions across the
running program instances.  For example, <tt class="docutils literal">any()</tt> returns <tt class="docutils literal">true</tt> if
the given value <tt class="docutils literal">v</tt> is <tt class="docutils literal">true</tt> for any of the SPMD program
instances currently running, <tt class="docutils literal">all()</tt> returns <tt class="docutils literal">true</tt> if it is true
for all of them, and <tt class="docutils literal">none()</tt> returns <tt class="docutils literal">true</tt> if <tt class="docutils literal">v</tt> is always
<tt class="docutils literal">false</tt>.</p>
<pre class="literal-block">
uniform bool any(bool v)
uniform bool all(bool v)
uniform bool none(bool v)
</pre>
<p>You can also compute a variety of reductions across the program instances.
For example, the values of the given value in each of the active program
instances are added together by the <tt class="docutils literal">reduce_add()</tt> function.</p>
<pre class="literal-block">
uniform int16 reduce_add(int8 x)
uniform unsigned int16 reduce_add(unsigned int8 x)
uniform int32 reduce_add(int16 x)
uniform unsigned int32 reduce_add(unsigned int16 x)
uniform int64 reduce_add(int32 x)
uniform unsigned int64 reduce_add(unsigned int32 x)
uniform int64 reduce_add(int64 x)
uniform unsigned int64 reduce_add(unsigned int64 x)

uniform float16 reduce_add(float16 x)
uniform float reduce_add(float x)
uniform double reduce_add(double x)
</pre>
<p>You can also use functions to compute the minimum value of the given value
across all of the currently-executing program instances.</p>
<pre class="literal-block">
uniform int8 reduce_min(int8 a)
uniform unsigned int8 reduce_min(unsigned int8 a)
uniform int16 reduce_min(int16 a)
uniform unsigned int16 reduce_min(unsigned int16 a)
uniform int32 reduce_min(int32 a)
uniform unsigned int32 reduce_min(unsigned int32 a)
uniform int64 reduce_min(int64 a)
uniform unsigned int64 reduce_min(unsigned int64 a)

uniform float16 reduce_min(float16 a)
uniform float reduce_min(float a)
uniform double reduce_min(double a)
</pre>
<p>Equivalent functions are available to compute the maximum of the given
varying variable over the active program instances.</p>
<pre class="literal-block">
uniform int8 reduce_max(int8 a)
uniform unsigned int8 reduce_max(unsigned int8 a)
uniform int16 reduce_max(int16 a)
uniform unsigned int16 reduce_max(unsigned int16 a)
uniform int32 reduce_max(int32 a)
uniform unsigned int32 reduce_max(unsigned int32 a)
uniform int64 reduce_max(int64 a)
uniform unsigned int64 reduce_max(unsigned int64 a)

uniform float16 reduce_max(float16 a)
uniform float reduce_max(float a)
uniform double reduce_max(double a)
</pre>
<p>Finally, you can check to see if a particular value has the same value in
all of the currently-running program instances:</p>
<pre class="literal-block">
uniform bool reduce_equal(int8 v)
uniform bool reduce_equal(unsigned int8 v)
uniform bool reduce_equal(int16 v)
uniform bool reduce_equal(unsigned int16 v)
uniform bool reduce_equal(int32 v)
uniform bool reduce_equal(unsigned int32 v)
uniform bool reduce_equal(int64 v)
uniform bool reduce_equal(unsigned int64 v)

uniform bool reduce_equal(float16 v)
uniform bool reduce_equal(float v)
uniform bool reduce_equal(double)
</pre>
<p>There are also variants of these functions that return the value as a
<tt class="docutils literal">uniform</tt> in the case where the values are all the same.  (There is
discussion of an application of this variant to improve memory access
performance in the <a class="reference external" href="perfguide.html#understanding-gather-and-scatter">Performance Guide</a>.</p>
<pre class="literal-block">
uniform bool reduce_equal(int8 v, uniform int8 * uniform sameval)
uniform bool reduce_equal(unsigned int8 v,
                          uniform unsigned int8 * uniform sameval)
uniform bool reduce_equal(int16 v, uniform int16 * uniform sameval)
uniform bool reduce_equal(unsigned int16 v,
                          uniform unsigned int16 * uniform sameval)
uniform bool reduce_equal(int32 v, uniform int32 * uniform sameval)
uniform bool reduce_equal(unsigned int32 v,
                          uniform unsigned int32 * uniform sameval)
uniform bool reduce_equal(int64 v, uniform int64 * uniform sameval)
uniform bool reduce_equal(unsigned int64 v,
                          uniform unsigned int64 * uniform sameval)

uniform bool reduce_equal(float16 v, uniform float16 * uniform sameval)
uniform bool reduce_equal(float v, uniform float * uniform sameval)
uniform bool reduce_equal(double, uniform double * uniform sameval)
</pre>
<p>If called when none of the program instances are running,
<tt class="docutils literal">reduce_equal()</tt> will return <tt class="docutils literal">false</tt>.</p>
<p>There are also a number of functions to compute &quot;scan&quot;s of values across
the program instances.  For example, the <tt class="docutils literal">exclusive_scan_add()</tt> function
computes, for each program instance, the sum of the given value over all of
the preceding program instances.  (The scans currently available in
<tt class="docutils literal">ispc</tt> are all so-called &quot;exclusive&quot; scans, meaning that the value
computed for a given element does not include the value provided for that
element.)  In C code, an exclusive add scan over an array might be
implemented as:</p>
<pre class="literal-block">
void scan_add(int *in_array, int *result_array, int count) {
    result_array[0] = 0;
    for (int i = 1; i &lt; count; ++i)
        result_array[i] = result_array[i-1] + in_array[i-1];
}
</pre>
<p><tt class="docutils literal">ispc</tt> provides the following scan functions--addition, bitwise-and, and
bitwise-or are available:</p>
<pre class="literal-block">
int8 exclusive_scan_add(int8 v)
unsigned int8 exclusive_scan_add(unsigned int8 v)
int16 exclusive_scan_add(int16 v)
unsigned int16 exclusive_scan_add(unsigned int16 v)
int32 exclusive_scan_add(int32 v)
unsigned int32 exclusive_scan_add(unsigned int32 v)
float16 exclusive_scan_add(float16 v)
float exclusive_scan_add(float v)
int64 exclusive_scan_add(int64 v)
unsigned int64 exclusive_scan_add(unsigned int64 v)
double exclusive_scan_add(double v)
int8 exclusive_scan_and(int8 v)
unsigned int8 exclusive_scan_and(unsigned int8 v)
int16 exclusive_scan_and(int16 v)
unsigned int16 exclusive_scan_and(unsigned int16 v)
int32 exclusive_scan_and(int32 v)
unsigned int32 exclusive_scan_and(unsigned int32 v)
int64 exclusive_scan_and(int64 v)
unsigned int64 exclusive_scan_and(unsigned int64 v)
int8 exclusive_scan_or(int8 v)
unsigned int8 exclusive_scan_or(unsigned int8 v)
int16 exclusive_scan_or(int16 v)
unsigned int16 exclusive_scan_or(unsigned int16 v)
int32 exclusive_scan_or(int32 v)
unsigned int32 exclusive_scan_or(unsigned int32 v)
int64 exclusive_scan_or(int64 v)
unsigned int64 exclusive_scan_or(unsigned int64 v)
</pre>
<p>The returned value for the first program instance will be <tt class="docutils literal">0</tt> for
<tt class="docutils literal">exclusive_scan_add</tt> and <tt class="docutils literal">exclusive_scan_or</tt>, and have all bits set to
<tt class="docutils literal">1</tt> for <tt class="docutils literal">exclusive_scan_and</tt>.</p>
<p>The use of exclusive scan to generate variable amounts of output from
program instances into a compact output buffer is <a class="reference external" href="faq.html#how-can-a-gang-of-program-instances-generate-variable-amounts-of-output-efficiently">discussed in the FAQ</a>.</p>
</div>
<div class="section" id="stack-memory-allocation">
<h2>Stack Memory Allocation</h2>
<p>The <tt class="docutils literal">ispc</tt> standard library includes an <tt class="docutils literal">alloca()</tt> function that can be
used to allocate memory on the stack.</p>
<pre class="literal-block">
void * uniform alloca(uniform size_t size);
</pre>
<p>The <tt class="docutils literal">alloca()</tt> function allocates <tt class="docutils literal">size</tt> bytes of space in the stack
frame of the caller.  This temporary space is automatically freed
when the function that called <tt class="docutils literal">alloca()</tt> returns to its caller.</p>
</div>
<div class="section" id="data-movement">
<h2>Data Movement</h2>
</div>
<div class="section" id="setting-and-copying-values-in-memory">
<h2>Setting and Copying Values In Memory</h2>
<p>There are a few functions for copying blocks of memory and initializing
values in memory.  Along the lines of the equivalently-named routines in
the C Standard library, <tt class="docutils literal">memcpy</tt> copies a given number of bytes starting
from a source location in memory to a destination location, where the two
regions of memory are guaranteed by the caller to be non-overlapping.
Alternatively, <tt class="docutils literal">memmove</tt> can be used to copy data if the buffers may
overlap.</p>
<pre class="literal-block">
void memcpy(void * uniform dst, void * uniform src, uniform int32 count)
void memmove(void * uniform dst, void * uniform src, uniform int32 count)
void memcpy(void * varying dst, void * varying src, int32 count)
void memmove(void * varying dst, void * varying src, int32 count)
</pre>
<p>Note that there are variants of these functions that take both <tt class="docutils literal">uniform</tt>
and <tt class="docutils literal">varying</tt> pointers.  Also note that <tt class="docutils literal">sizeof(float)</tt> and
<tt class="docutils literal">sizeof(uniform float)</tt> return different values, so programmers should
take care when calculating <tt class="docutils literal">count</tt>.</p>
<p>To initialize values in memory, the <tt class="docutils literal">memset</tt> routine can be used.  (It
also behaves like the function of the same name in the C Standard Library.)
It sets the given number of bytes of memory starting at the given location
to the value provided.</p>
<pre class="literal-block">
void memset(void * uniform ptr, uniform int8 val, uniform int32 count)
void memset(void * varying ptr, int8 val, int32 count)
</pre>
<p>There are also variants of all of these functions that take 64-bit values
for the number of bytes of memory to operate on:</p>
<pre class="literal-block">
void memcpy64(void * uniform dst, void * uniform src, uniform int64 count)
void memcpy64(void * varying dst, void * varying src, int64 count)
void memmove64(void * uniform dst, void * uniform src, uniform int64 count)
void memmove64(void * varying dst, void * varying src, int64 count)
void memset64(void * uniform ptr, uniform int8 val, uniform int64 count)
void memset64(void * varying ptr, int8 val, int64 count)
</pre>
</div>
<div class="section" id="packed-load-and-store-operations">
<h2>Packed Load and Store Operations</h2>
<p>The standard library also offers routines for writing out and reading in
values from linear memory locations for the active program instances.  The
<tt class="docutils literal">packed_load_active()</tt> functions load consecutive values starting at the
given location, loading one consecutive value for each currently-executing
program instance and storing it into that program instance's <tt class="docutils literal">val</tt>
variable.  They return the total number of values loaded.</p>
<pre class="literal-block">
uniform int packed_load_active(uniform int8 * uniform base,
                               varying int8 * uniform val)
uniform int packed_load_active(uniform unsigned int8 * uniform base,
                               varying unsigned int8 * uniform val)
uniform int packed_load_active(uniform int16 * uniform base,
                               varying int16 * uniform val)
uniform int packed_load_active(uniform unsigned int16 * uniform base,
                               varying unsigned int16 * uniform val)
uniform int packed_load_active(uniform int * uniform base,
                               varying int * uniform val)
uniform int packed_load_active(uniform unsigned int * uniform base,
                               varying unsigned int * uniform val)
uniform int packed_load_active(uniform int64 * uniform base,
                               varying int64 * uniform val)
uniform int packed_load_active(uniform unsigned int64 * uniform base,
                               varying unsigned int64 * uniform val)
uniform int packed_load_active(uniform float16 * uniform base,
                               varying float16 * uniform val)
uniform int packed_load_active(uniform float * uniform base,
                               varying float * uniform val)
uniform int packed_load_active(uniform double * uniform base,
                               varying double * uniform val)
</pre>
<p>Similarly, the <tt class="docutils literal">packed_store_active()</tt> functions store the <tt class="docutils literal">val</tt> values
for each program instances that executed the <tt class="docutils literal">packed_store_active()</tt>
call, storing the results consecutively starting at the given location.
They return the total number of values stored.</p>
<pre class="literal-block">
uniform int packed_store_active(uniform int8 * uniform base,
                                int8 val)
uniform int packed_store_active(uniform unsigned int8* uniform base,
                                unsigned int8 val)
uniform int packed_store_active(uniform int16 * uniform base,
                                int16 val)
uniform int packed_store_active(uniform unsigned int16 * uniform base,
                                unsigned int16 val)
uniform int packed_store_active(uniform int * uniform base,
                                int val)
uniform int packed_store_active(uniform unsigned int * uniform base,
                                unsigned int val)
uniform int packed_store_active(uniform int64 * uniform base,
                                int64 val)
uniform int packed_store_active(uniform unsigned int64 * uniform base,
                                unsigned int64 val)
uniform int packed_store_active(uniform float16 * uniform base,
                                float16 val)
uniform int packed_store_active(uniform float * uniform base,
                                float val)
uniform int packed_store_active(uniform double * uniform base,
                                double val)
</pre>
<p>There are also <tt class="docutils literal">packed_store_active2()</tt> functions with exactly the same
signatures and the same semantic except that they may write one extra
element to the output array (but still returning the same value as
<tt class="docutils literal">packed_store_active()</tt>). These functions suggest different branch free
implementation on most of supported targets, which usually (but not always)
performs better than <tt class="docutils literal">packed_store_active()</tt>. It's advised to test function
performance on user's scenarios on particular target hardware before using it.</p>
<p>As an example of how these functions can be used, the following code shows
the use of <tt class="docutils literal">packed_store_active()</tt>.</p>
<pre class="literal-block">
uniform int negative_indices(uniform float a[], uniform int length,
                             uniform int indices[]) {
    uniform int numNeg = 0;
    foreach (i = 0 ... length) {
        if (a[i] &lt; 0.)
            numNeg += packed_store_active(&amp;indices[numNeg], i);
    }
    return numNeg;
}
</pre>
<p>The function takes an array of floating point values <tt class="docutils literal">a</tt>, with length
given by the <tt class="docutils literal">length</tt> parameter.  This function also takes an output
array, <tt class="docutils literal">indices</tt>, which is assumed to be at least as long as <tt class="docutils literal">length</tt>.
It then loops over all of the elements of <tt class="docutils literal">a</tt> and, for each element that
is less than zero, stores that element's offset into the <tt class="docutils literal">indices</tt> array.
It returns the total number of negative values.  For example, given an
input array <tt class="docutils literal">a[8] = { 10, <span class="pre">-20,</span> 30, <span class="pre">-40,</span> <span class="pre">-50,</span> <span class="pre">-60,</span> 70, 80 }</tt>, it returns a count
of four negative values, and initializes the first four elements of
<tt class="docutils literal">indices[]</tt> to the values <tt class="docutils literal">{ 1, 3, 4, 5 }</tt> corresponding to the array
indices where <tt class="docutils literal">a[i]</tt> was less than zero.</p>
</div>
<div class="section" id="streaming-load-and-store-operations">
<h2>Streaming Load and Store Operations</h2>
<p>The standard library offers routines for streaming load and streaming store
operations. The implementation serves as both a streaming as well as a non-temporal
operation. There are separate routines to be used depending on whether you are
loading from and storing to a uniform variable or a varying variable.</p>
<p>The different available variants of streaming store are given below.</p>
<p>For storing to array from varying variable:</p>
<pre class="literal-block">
void streaming_store(uniform unsigned int8 a[], unsigned int8 vals)
void streaming_store(uniform int8 a[], int8 vals)
void streaming_store(uniform unsigned int16 a[], unsigned int16 vals)
void streaming_store(uniform int16 a[], int16 vals)
void streaming_store(uniform unsigned int a[], unsigned int vals)
void streaming_store(uniform int a[], int vals)
void streaming_store(uniform unsigned int64 a[], unsigned int64 vals)
void streaming_store(uniform int64 a[], int64 vals)
void streaming_store(uniform float16 a[], float16 vals)
void streaming_store(uniform float a[], float vals)
void streaming_store(uniform double a[], double vals)
</pre>
<p>For storing to array from uniform variable:</p>
<pre class="literal-block">
void streaming_store(uniform unsigned int8 a[], uniform unsigned int8 vals)
void streaming_store(uniform int8 a[], uniform int8 vals)
void streaming_store(uniform unsigned int16 a[], uniform unsigned int16 vals)
void streaming_store(uniform int16 a[], uniform int16 vals)
void streaming_store(uniform unsigned int a[], uniform unsigned int vals)
void streaming_store(uniform int a[], uniform int vals)
void streaming_store(uniform unsigned int64 a[], uniform unsigned int64 vals)
void streaming_store(uniform int64 a[], uniform int64 vals)
void streaming_store(uniform float16 a[], uniform float16 vals)
void streaming_store(uniform float a[], uniform float vals)
void streaming_store(uniform double a[], uniform double vals)
</pre>
<p>The different available variants of streaming load are given below.</p>
<p>For loading as varying from array:</p>
<pre class="literal-block">
varying unsigned int8 streaming_load(uniform unsigned int8 a[])
varying int8 streaming_load(uniform int8 a[])
varying unsigned int16 streaming_load(uniform unsigned int16 a[])
varying int16 streaming_load(uniform int16 a[])
varying unsigned int streaming_load(uniform unsigned int a[])
varying int streaming_load(uniform int a[])
varying unsigned int64 streaming_load(uniform unsigned int64 a[])
varying int64 streaming_load(uniform int64 a[])
varying float16 streaming_load(uniform float16 a[])
varying float streaming_load(uniform float a[])
varying double streaming_load(uniform double a[])
</pre>
<p>For loading as uniform from array:</p>
<pre class="literal-block">
uniform unsigned int8 streaming_load_uniform(uniform unsigned int8 a[])
uniform int8 streaming_load_uniform(uniform int8 a[])
uniform unsigned int16 streaming_load_uniform(uniform unsigned int16 a[])
uniform int16 streaming_load_uniform(uniform int16 a[])
uniform unsigned int streaming_load_uniform(uniform unsigned int a[])
uniform int streaming_load_uniform(uniform int a[])
uniform unsigned int64 streaming_load_uniform(uniform unsigned int64 a[])
uniform int64 streaming_load_uniform(uniform int64 a[])
uniform float16 streaming_load_uniform(uniform float16 a[])
uniform float streaming_load_uniform(uniform float a[])
uniform double streaming_load_uniform(uniform double a[])
</pre>
</div>
<div class="section" id="data-conversions">
<h2>Data Conversions</h2>
</div>
<div class="section" id="converting-between-array-of-structures-and-structure-of-arrays-layout">
<h2>Converting Between Array-of-Structures and Structure-of-Arrays Layout</h2>
<p>Applications often lay data out in memory in &quot;array of structures&quot; form.
Though convenient in C/C++ code, this layout can make <tt class="docutils literal">ispc</tt> programs
less efficient than they would be if the data was laid out in &quot;structure of
arrays&quot; form.  (See the section <a class="reference external" href="perfguide.html#use-structure-of-arrays-layout-when-possible">Use &quot;Structure of Arrays&quot; Layout When
Possible</a> in the performance guide for extended discussion of this topic.)</p>
<p>The standard library does provide a few functions that efficiently convert
between these two formats, for cases where it's not possible to change the
application to use &quot;structure of arrays layout&quot;.  Consider an array of 3D
(x,y,z) position data laid out in a C array like:</p>
<pre class="literal-block">
// C++ code
float pos[] = { x0, y0, z0, x1, y1, z1, x2, ... };
</pre>
<p>In an <tt class="docutils literal">ispc</tt> program, we might want to load a set of (x,y,z) values and
do a computation based on them.  The natural expression of this:</p>
<pre class="literal-block">
extern uniform float pos[];
uniform int base = ...;
float x = pos[base + 3 * programIndex];     // x = { x0 x1 x2 ... }
float y = pos[base + 1 + 3 * programIndex]; // y = { y0 y1 y2 ... }
float z = pos[base + 2 + 3 * programIndex]; // z = { z0 z1 z2 ... }
</pre>
<p>leads to irregular memory accesses and reduced performance.  Alternatively,
the <tt class="docutils literal">aos_to_soa3()</tt> standard library function could be used:</p>
<pre class="literal-block">
extern uniform float pos[];
uniform int base = ...;
float x, y, z;
aos_to_soa3(&amp;pos[base], &amp;x, &amp;y, &amp;z);
</pre>
<p>This routine loads three times the gang size values from the given array
starting at the given offset, returning three <tt class="docutils literal">varying</tt> results.  There
are <tt class="docutils literal">int32</tt>, <tt class="docutils literal">int64</tt>, <tt class="docutils literal">float</tt> and <tt class="docutils literal">double</tt> variants of this function:</p>
<pre class="literal-block">
void aos_to_soa3(uniform float a[], varying float * uniform v0,
                 varying float * uniform v1, varying float * uniform v2)
void aos_to_soa3(uniform int32 a[], varying int32 * uniform v0,
                 varying int32 * uniform v1, varying int32 * uniform v2)
void aos_to_soa3(uniform double a[], varying double * uniform v0,
                 varying double * uniform v1, varying double * uniform v2)
void aos_to_soa3(uniform int64 a[], varying int64 * uniform v0,
                 varying int64 * uniform v1, varying int64 * uniform v2)
</pre>
<p>After computation is done, corresponding functions convert back from the
SoA values in <tt class="docutils literal">ispc</tt> <tt class="docutils literal">varying</tt> variables and write the values back to
the given array, starting at the given offset.</p>
<pre class="literal-block">
extern uniform float pos[];
uniform int base = ...;
float x, y, z;
aos_to_soa3(&amp;pos[base], &amp;x, &amp;y, &amp;z);
// do computation with x, y, z
soa_to_aos3(x, y, z, &amp;pos[base]);
</pre>
<pre class="literal-block">
void soa_to_aos3(float v0, float v1, float v2, uniform float a[])
void soa_to_aos3(int32 v0, int32 v1, int32 v2, uniform int32 a[])
void soa_to_aos3(double v0, double v1, double v2, uniform double a[])
void soa_to_aos3(int64 v0, int64 v1, int64 v2, uniform int64 a[])
</pre>
<p>Note that these functions do not take the current program execution mask into account; they
unconditionally read and write three times the gang size. Hence, if the iteration count
is not an integer multiple of the program count, <tt class="docutils literal">aos_to_soa3()</tt> will read past the end of
the input data and <tt class="docutils literal">soa_to_aos3()</tt> will write past the end of the output data. To avoid memory
corruption in this case, one of the following approaches can be taken:</p>
<ul class="simple">
<li>Ensure that the data buffers have a size that is a multiple of <tt class="docutils literal">programCount</tt>, so that
the read/write overflow does not cause memory corruption</li>
<li>For the main loop, mask the iteration count to be a multiple of <tt class="docutils literal">programCount</tt> and add
a manual &quot;remainder&quot; loop (which will probably use a gather/scatter) for the remaining
iterations</li>
</ul>
<p>There are also variants of these functions that convert 4-wide values
and 2-wide values between AoS and SoA layouts.
In other words, <tt class="docutils literal">aos_to_soa4()</tt> converts AoS data in memory laid out like
<tt class="docutils literal">r0 g0 b0 a0 r1 g1 b1 a1 ...</tt> to four <tt class="docutils literal">varying</tt> variables with values
<tt class="docutils literal">r0 <span class="pre">r1...</span></tt>, <tt class="docutils literal">g0 <span class="pre">g1...</span></tt>, <tt class="docutils literal">b0 <span class="pre">b1...</span></tt>, and <tt class="docutils literal">a0 <span class="pre">a1...</span></tt>, reading a total
of four times the gang size values from the given array, starting at the given offset.</p>
<pre class="literal-block">
void aos_to_soa4(uniform float a[], varying float * uniform v0,
                 varying float * uniform v1, varying float * uniform v2,
                 varying float * uniform v3)
void aos_to_soa4(uniform int32 a[], varying int32 * uniform v0,
                 varying int32 * uniform v1, varying int32 * uniform v2,
                 varying int32 * uniform v3)
void soa_to_aos4(float v0, float v1, float v2, float v3, uniform float a[])
void soa_to_aos4(int32 v0, int32 v1, int32 v2, int32 v3, uniform int32 a[])
</pre>
<p>The following 2-wide variant of these functions are also supported.</p>
<pre class="literal-block">
void aos_to_soa2(uniform float a[], varying float * uniform v0,
                 varying float * uniform v1)
void aos_to_soa2(uniform int32 a[], varying int32 * uniform v0,
                 varying int32 * uniform v1)
void soa_to_aos2(float v0, float v1, uniform float a[])
void soa_to_aos2(int32 v0, int32 v1, uniform int32 a[])
</pre>
</div>
<div class="section" id="conversions-to-and-from-half-precision-floats">
<h2>Conversions To and From Half-Precision Floats</h2>
<p>There are functions to convert to and from the IEEE 16-bit floating-point
format.  Note that there is a <tt class="docutils literal">float16</tt> data-type in <tt class="docutils literal">ispc</tt>, which has
full language and standard library support, but only on the targets with
hardware support for this type.
The following functions facilitate converting to and from half-format
data in memory and are primarily targeted for the use on the targets
without native support for <tt class="docutils literal">float16</tt> in the hardware.</p>
<p>To use them, half-format data should be loaded into an <tt class="docutils literal">int16</tt> and the
<tt class="docutils literal">half_to_float()</tt> function used to convert it to a 32-bit floating point
value.  To store a value to memory in half format, the <tt class="docutils literal">float_to_half()</tt>
function returns the 16 bits that are the closest match to the given
<tt class="docutils literal">float</tt>, in half format.</p>
<pre class="literal-block">
float half_to_float(unsigned int16 h)
uniform float half_to_float(uniform unsigned int16 h)
int16 float_to_half(float f)
uniform int16 float_to_half(uniform float f)
</pre>
<p>There are also faster versions of these functions that don't worry about
handling floating point infinity, &quot;not a number&quot; and denormalized numbers
correctly.  These are faster than the above functions, but are less
precise.</p>
<pre class="literal-block">
float half_to_float_fast(unsigned int16 h)
uniform float half_to_float_fast(uniform unsigned int16 h)
int16 float_to_half_fast(float f)
uniform int16 float_to_half_fast(uniform float f)
</pre>
</div>
<div class="section" id="converting-from-to-srgb8">
<h2>Converting from/to sRGB8</h2>
<p>The sRGB color space is used in many applications in graphics and imaging;
see the <a class="reference external" href="http://en.wikipedia.org/wiki/SRGB">Wikipedia page on sRGB</a> for more information.  The <tt class="docutils literal">ispc</tt>
standard library provides four conversions functions: two for converting
floating-point color values to 8-bit values in the sRGB space, and 2 for the
reverse operation.</p>
<pre class="literal-block">
int float_to_srgb8(float v)
uniform int float_to_srgb8(uniform float v)
</pre>
<pre class="literal-block">
float srgb8_to_float(int v)
uniform float srgb8_to_float(uniform int v)
</pre>
</div>
<div class="section" id="systems-programming-support">
<h2>Systems Programming Support</h2>
</div>
<div class="section" id="atomic-operations-and-memory-fences">
<h2>Atomic Operations and Memory Fences</h2>
<p>The standard set of atomic memory operations are provided by the standard
library, including variants to handle both uniform and varying
types as well as &quot;local&quot; and &quot;global&quot; atomics.</p>
<p>Local atomics provide atomic behavior across the program instances in a
gang, but not across multiple gangs or memory operations in different
hardware threads.  To see why they are needed, consider a histogram
calculation where each program instance in the gang computes which bucket a
value lies in and then increments a corresponding counter.  If the code is
written like this:</p>
<pre class="literal-block">
uniform int count[N_BUCKETS] = ...;
float value = ...;
int bucket = clamp(value / N_BUCKETS, 0, N_BUCKETS);
++count[bucket];  // ERROR: undefined behavior if collisions
</pre>
<p>then the program's behavior is undefined: whenever multiple program
instances have values that map to the same value of <tt class="docutils literal">bucket</tt>, then the
effect of the increment is undefined.  (See the discussion in the <a class="reference internal" href="#data-races-within-a-gang">Data
Races Within a Gang</a> section; in the case here, there isn't a sequence
point between one program instance updating <tt class="docutils literal">count[bucket]</tt> and the other
program instance reading its value.)</p>
<p>The <tt class="docutils literal">atomic_add_local()</tt> function can be used in this case; as a local
atomic it is atomic across the gang of program instances, such that the
expected result is computed.</p>
<pre class="literal-block">
...
int bucket = clamp(value / N_BUCKETS, 0, N_BUCKETS);
atomic_add_local(&amp;count[bucket], 1);
</pre>
<p>It uses this variant of the 32-bit integer atomic add routine:</p>
<pre class="literal-block">
int32 atomic_add_local(uniform int32 * uniform ptr, int32 delta)
</pre>
<p>The semantics of this routine are typical for an atomic add function: the
pointer here points to a single location in memory (the same one for all
program instances), and for each executing program instance, the value
stored in the location that <tt class="docutils literal">ptr</tt> points to has that program instance's
value &quot;delta&quot; added to it atomically, and the old value at that location is
returned from the function.</p>
<p>One thing to note is that the type of the value being added to is a
<tt class="docutils literal">uniform</tt> integer, while the increment amount and the return value are
<tt class="docutils literal">varying</tt>.  In other words, the semantics of this call are that each
running program instance individually issues the atomic operation with its
own <tt class="docutils literal">delta</tt> value and gets the previous value back in return.  The
atomics for the running program instances may be issued in arbitrary order;
it's not guaranteed that they will be issued in <tt class="docutils literal">programIndex</tt> order, for
example.</p>
<p>Global atomics are more powerful than local atomics; they are atomic across
both the program instances in the gang as well as atomic across different
gangs and different hardware threads.  For example, for the global variant
of the atomic used above,</p>
<pre class="literal-block">
int32 atomic_add_global(uniform int32 * uniform ptr, int32 delta)
</pre>
<p>if multiple processors simultaneously issue atomic adds to the same memory
location, the adds will be serialized by the hardware so that the correct
result is computed in the end.</p>
<p>Here are the declarations of the <tt class="docutils literal">int32</tt> variants of these functions.
There are also <tt class="docutils literal">int64</tt> equivalents as well as variants that take
<tt class="docutils literal">unsigned</tt> <tt class="docutils literal">int32</tt> and <tt class="docutils literal">int64</tt> values.</p>
<pre class="literal-block">
int32 atomic_add_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_subtract_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_min_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_max_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_and_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_or_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_xor_{local,global}(uniform int32 * uniform ptr, int32 value)
int32 atomic_swap_{local,global}(uniform int32 * uniform ptr, int32 value)
</pre>
<p>Support for <tt class="docutils literal">float</tt> and <tt class="docutils literal">double</tt> types is also available.  For local
and global atomics, all but the logical operations are available.  (There are
corresponding <tt class="docutils literal">double</tt> variants of these, not listed here.)</p>
<pre class="literal-block">
float atomic_add_{local,global}(uniform float * uniform ptr, float value)
float atomic_subtract_{local,global}(uniform float * uniform ptr, float value)
float atomic_min_{local,global}(uniform float * uniform ptr, float value)
float atomic_max_{local,global}(uniform float * uniform ptr, float value)
float atomic_swap_{local,global}(uniform float * uniform ptr, float value)
</pre>
<p>Finally, &quot;swap&quot; (but none of these other atomics) is available for pointer
types:</p>
<pre class="literal-block">
void *atomic_swap_{local,global}(void * * uniform ptr, void * value)
</pre>
<p>There are also variants of the atomic that take <tt class="docutils literal">uniform</tt> values for the
operand and return a <tt class="docutils literal">uniform</tt> result.  These correspond to a single
atomic operation being performed for the entire gang of program instances,
rather than one per program instance.</p>
<pre class="literal-block">
uniform int32 atomic_add_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_subtract_{local,global}(uniform int32 * uniform ptr,
                                             uniform int32 value)
uniform int32 atomic_min_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_max_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_and_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_or_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_xor_{local,global}(uniform int32 * uniform ptr,
                                        uniform int32 value)
uniform int32 atomic_swap_{local,global}(uniform int32 * uniform ptr,
                                         uniform int32 newval)
</pre>
<p>And similarly for pointers:</p>
<pre class="literal-block">
uniform void *atomic_swap_{local,global}(void * * uniform ptr,
                                         void *newval)
</pre>
<p>Be careful that you use the atomic function that you mean to; consider the
following code:</p>
<pre class="literal-block">
extern uniform int32 counter;
int32 myCounter = atomic_add_global(&amp;counter, 1);
</pre>
<p>One might write code like this with the intent that each running program
instance increments the counter by one and gets the old value of the
counter (for example, to store results into unique locations in an array).
However, the above code calls the second variant of
<tt class="docutils literal">atomic_add_global()</tt>, which takes a <tt class="docutils literal">uniform int</tt> value to add to the
counter and only performs one atomic operation.  The counter will be
increased by just one, and all program instances will receive the same
value back (thanks to the <tt class="docutils literal">uniform int32</tt> return value being silently
converted to a <tt class="docutils literal">varying int32</tt>.)  Writing the code this way, for example,
will cause the desired atomic add function to be called.</p>
<pre class="literal-block">
extern uniform int32 counter;
int32 myCounter = atomic_add_global(&amp;counter, (varying int32)1);
</pre>
<p>There is a third variant of each of these atomic functions that takes a
<tt class="docutils literal">varying</tt> pointer; this allows each program instance to issue an atomic
operation to a possibly-different location in memory.  (Of course, the
proper result is still returned if some or all of them happen to point to
the same location in memory!)</p>
<pre class="literal-block">
int32 atomic_add_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_subtract_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_min_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_max_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_and_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_or_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_xor_{local,global}(uniform int32 * varying ptr, int32 value)
int32 atomic_swap_{local,global}(uniform int32 * varying ptr, int32 value)
</pre>
<p>And:</p>
<pre class="literal-block">
void *atomic_swap_{local,global}(void * * ptr, void *value)
</pre>
<p>There are also atomic &quot;compare and exchange&quot; functions.  Compare and
exchange atomically compares the value in &quot;val&quot; to &quot;compare&quot;--if they
match, it assigns &quot;newval&quot; to &quot;val&quot;.  In either case, the old value of
&quot;val&quot; is returned.  (As with the other atomic operations, there are also
<tt class="docutils literal">unsigned</tt> and 64-bit variants of this function.  Furthermore, there are
<tt class="docutils literal">float</tt>, <tt class="docutils literal">double</tt>, and <tt class="docutils literal">void *</tt> variants as well.)</p>
<pre class="literal-block">
int32 atomic_compare_exchange_{local,global}(uniform int32 * uniform ptr,
                                             int32 compare, int32 newval)
uniform int32 atomic_compare_exchange_{local,global}(uniform int32 * uniform ptr,
                                uniform int32 compare, uniform int32 newval)
</pre>
<p><tt class="docutils literal">ispc</tt> also has a standard library routine that inserts a memory barrier
into the code; it ensures that all memory reads and writes prior to the
barrier complete before any reads or writes after the barrier are issued.
See the <a class="reference external" href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">Linux kernel documentation on memory barriers</a> for an excellent
writeup on the need for and the use of memory barriers in multi-threaded
code.</p>
<pre class="literal-block">
void memory_barrier();
</pre>
<p>Note that this barrier is <em>not</em> needed for coordinating reads and writes
among the program instances in a gang; it's only needed for coordinating
between multiple hardware threads running on different cores.  See the
section <a class="reference internal" href="#data-races-within-a-gang">Data Races Within a Gang</a> for the guarantees provided about
memory read/write ordering across a gang.</p>
</div>
<div class="section" id="prefetches">
<h2>Prefetches</h2>
<p>The standard library has a variety of functions to prefetch data into the
processor's cache.  While modern CPUs have automatic prefetchers that do a
reasonable job of prefetching data to the cache before its needed, high
performance applications may find it helpful to prefetch data before it's
needed.</p>
<p>For example, this code shows how to prefetch data to the processor's L1
cache while iterating over the items in an array.</p>
<pre class="literal-block">
uniform int32 array[...];
for (uniform int i = 0; i &lt; count; ++i) {
    // do computation with array[i]
    prefetch_l1(&amp;array[i+32]);
}
</pre>
<p>The standard library has routines to prefetch to the L1, L2, and L3
caches.  It also has a variant, <tt class="docutils literal">prefetch_nt()</tt>, that indicates that the
value being prefetched isn't expected to be used more than once (so should
be high priority to be evicted from the cache).  Furthermore, it has
versions of these functions that take both <tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt>
pointer types.</p>
<pre class="literal-block">
void prefetch_{l1,l2,l3,nt}(void * uniform ptr)
void prefetch_{l1,l2,l3,nt}(void * varying ptr)
</pre>
<p>The standard library also has routines to prefetch to the L1, L2, and L3
caches in anticipation of a write:</p>
<pre class="literal-block">
void prefetchw_{l1,l2,l3}(void * uniform ptr)
void prefetchw_{l1,l2,l3}(void * varying ptr)
</pre>
<p>On GPU prefetches are supported on some targets, including Intel Xe HPC and
Intel Xe HPG architectures.  It is required to pass the size of data being
prefetched. The valid values are: 1 (for int8), 2 (for int16), 4 (for int32,
float) and 8 (for int64, double).  If data size argument is not passed, the
standard library will use 4 by default.  There is no L2 cache on GPU so
<tt class="docutils literal">prefetch_l2()</tt> is mapped to <tt class="docutils literal">prefetch_l3()</tt> and <tt class="docutils literal">prefetch_nt()</tt>
reads-invalidates on L1 loads and caches in L3.</p>
<pre class="literal-block">
void prefetch_{l1,l2,l3,nt}(void * uniform ptr, uniform int8 datasize)
void prefetch_{l1,l2,l3,nt}(void * varying ptr, uniform int8 datasize)
</pre>
</div>
<div class="section" id="system-information">
<h2>System Information</h2>
<p>The value of a  high-precision hardware clock counter is returned by the
<tt class="docutils literal">clock()</tt> routine; its value increments by one each processor cycle.
Thus, taking the difference between the values returned by <tt class="docutils literal">clock()</tt> at
different points in program execution gives the number of cycles between
those points in the program.</p>
<pre class="literal-block">
uniform int64 clock()
</pre>
<p>Note that <tt class="docutils literal">clock()</tt> flushes the processor pipeline.  It has an overhead
of a hundred or so cycles, so for very fine-grained measurements, it may be
worthwhile to measure the cost of calling <tt class="docutils literal">clock()</tt> and subtracting that
value from reported results.</p>
<p>A routine is also available to find the number of CPU cores available in
the system:</p>
<pre class="literal-block">
uniform int num_cores()
</pre>
<p>This value can be useful for adapting the granularity of parallel task
decomposition depending on the number of processors in the system.</p>
</div>
</div>
<div class="section" id="interoperability-with-the-application">
<h1>Interoperability with the Application</h1>
<p>One of <tt class="docutils literal">ispc</tt>'s key goals is to make it easy to interoperate between the
C/C++ application code and parallel code written in <tt class="docutils literal">ispc</tt>.  This
section describes the details of how this works and describes a number of
the pitfalls.</p>
<div class="section" id="interoperability-overview">
<h2>Interoperability Overview</h2>
<p>As described in <a class="reference internal" href="#compiling-and-running-a-simple-ispc-program">Compiling and Running a Simple ISPC Program</a> it's
relatively straightforward to call <tt class="docutils literal">ispc</tt> code from C/C++.  First, any
<tt class="docutils literal">ispc</tt> functions to be called should be defined with the <tt class="docutils literal">export</tt>
keyword:</p>
<pre class="literal-block">
export void foo(uniform float a[]) {
    ...
}
</pre>
<p>This function corresponds to the following C-callable function:</p>
<pre class="literal-block">
void foo(float a[]);
</pre>
<p>(Recall from the <a class="reference internal" href="#uniform-and-varying-qualifiers">&quot;uniform&quot; and &quot;varying&quot; Qualifiers</a> section
that <tt class="docutils literal">uniform</tt> types correspond to a single instances of the
corresponding type in C/C++.)</p>
<p>In addition to variables passed from the application to <tt class="docutils literal">ispc</tt> in the
function call, you can also share global variables between the application
and <tt class="docutils literal">ispc</tt>.  To do so, just declare the global variable as usual (in
either <tt class="docutils literal">ispc</tt> or application code), and add an <tt class="docutils literal">extern</tt> declaration on
the other side.</p>
<p>For example, given this <tt class="docutils literal">ispc</tt> code:</p>
<pre class="literal-block">
// ispc code
uniform float foo;
extern uniform float bar[10];
</pre>
<p>And this C++ code:</p>
<pre class="literal-block">
// C++ code
extern &quot;C&quot; {
  extern float foo;
  float bar[10];
}
</pre>
<p>Both the <tt class="docutils literal">foo</tt> and <tt class="docutils literal">bar</tt> global variables can be accessed on each
side.  Note that the <tt class="docutils literal">extern &quot;C&quot;</tt> declaration is necessary from C++,
since <tt class="docutils literal">ispc</tt> uses C linkage for functions and global variables.</p>
<p><tt class="docutils literal">ispc</tt> code can also call back to C/C++.  On the <tt class="docutils literal">ispc</tt> side, any
application functions to be called must be declared with the <tt class="docutils literal">extern &quot;C&quot;</tt>
qualifier.</p>
<pre class="literal-block">
extern &quot;C&quot; void foo(uniform float f, uniform float g);
</pre>
<p>Unlike in C++, <tt class="docutils literal">extern &quot;C&quot;</tt> does not use braces to delineate
multiple function declarations; therefore, multiple C functions to be called
from <tt class="docutils literal">ispc</tt> must be declared individually as follows:</p>
<pre class="literal-block">
extern &quot;C&quot; void foo(uniform float f, uniform float g);
extern &quot;C&quot; uniform int bar(uniform int a);
</pre>
<p>It is illegal to overload functions declared with <tt class="docutils literal">extern &quot;C&quot;</tt> linkage;
<tt class="docutils literal">ispc</tt> issues an error in this case.</p>
<p>Functions declared with <tt class="docutils literal">extern &quot;C&quot;</tt> linkage can be made to follow
<tt class="docutils literal">__vectorcall</tt> calling convention on Windows by using <tt class="docutils literal">__vectorcall</tt>
qualifier.</p>
<pre class="literal-block">
extern &quot;C&quot; __vectorcall void foo(uniform float f, uniform float g);
</pre>
<p><tt class="docutils literal">__vectorcall</tt> can only be used for <tt class="docutils literal">extern &quot;C&quot;</tt> function declarations and
on Windows OS.</p>
<p><tt class="docutils literal">extern &quot;C&quot;</tt> functions can also be marked with the <tt class="docutils literal">__regcall</tt> calling convention.
This calling convention causes return values and function arguments to be passed through
registers in most cases. Note that a <tt class="docutils literal">__regcall3__</tt> prefix will be added to the
function name.</p>
<p><strong>Only a single function call is made back to C++ for the entire gang of
running program instances</strong>. Furthermore, function calls back to C/C++ are not
made if none of the program instances need to make the call.  For example,
given code like:</p>
<pre class="literal-block">
uniform float foo = ...;
float x = ...;
if (x != 0)
    foo = appFunc(foo);
</pre>
<p><tt class="docutils literal">appFunc()</tt> will only be called if one or more of the running program
instances evaluates <tt class="docutils literal">true</tt> for <tt class="docutils literal">x != 0</tt>.  If the application code would
like to determine which of the running program instances want to make the
call, a mask representing the active SIMD lanes can be passed to the
function.</p>
<pre class="literal-block">
extern &quot;C&quot; float appFunc(uniform float x,
                         uniform int activeLanes);
</pre>
<p>If the function is then called as:</p>
<pre class="literal-block">
...
x = appFunc(x, lanemask());
</pre>
<p>The <tt class="docutils literal">activeLanes</tt> parameter will have the value one in the 0th bit if the
first program instance is running at this point in the code, one in the
first bit for the second instance, and so forth.  (The <tt class="docutils literal">lanemask()</tt>
function is documented in <a class="reference internal" href="#cross-program-instance-operations">Cross-Program Instance Operations</a>.)
Application code can thus be written as:</p>
<pre class="literal-block">
float appFunc(float x, int activeLanes) {
    for (int i = 0; i &lt; programCount; ++i)
        if ((activeLanes &amp; (1 &lt;&lt; i)) != 0) {
            // do computation for i'th SIMD lane
        }
}
</pre>
<p>In some cases, it can be desirable to generate a single call for each
executing program instance, rather than one call for a gang.  For example,
the code below shows how one might call an existing math library routine
that takes a scalar parameter.</p>
<pre class="literal-block">
extern &quot;C&quot; uniform double erf(uniform double);
double v = ...;
double result;
foreach_active (instance) {
    uniform double r = erf(extract(v, instance));
    result = insert(result, instance, r);
}
</pre>
<p>This code calls <tt class="docutils literal">erf()</tt> once for each active program instance, passing it
the program instance's value of <tt class="docutils literal">v</tt> and storing the result in the
instance's <tt class="docutils literal">result</tt> value.</p>
<p><tt class="docutils literal">extern &quot;C&quot;</tt> function may also have a definition. On GPU it is intended to make
a function (not a kernel!) callable from a different module. On CPU it is not
advised to have <tt class="docutils literal">extern &quot;C&quot;</tt> functions with definitions and to use <tt class="docutils literal">export</tt>
functions instead, which are designed to be entry points from C/C++.</p>
<p>On GPU ISPC experimentally supports calls to SYCL/DPC++ device functions using
<cite>invoke_sycl</cite> construct. <cite>invoke_sycl</cite> accepts only functions declared as <tt class="docutils literal">extern &quot;SYCL&quot;</tt>.
<tt class="docutils literal">extern &quot;SYCL&quot;</tt> declaration is similar to <tt class="docutils literal">extern &quot;C&quot;</tt>, but in addition it means
that function signature will be modified if needed to align with SYCL/DPC++ backend (IGC) ABI.</p>
<p>Below is a comparison between <tt class="docutils literal">export</tt>, <tt class="docutils literal">extern</tt>, <tt class="docutils literal">extern &quot;C&quot;</tt> and <tt class="docutils literal">extern &quot;SYCL&quot;</tt> functions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="12%" />
<col width="14%" />
<col width="17%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr><td>Feature</td>
<td><tt class="docutils literal">export</tt></td>
<td><tt class="docutils literal">extern &quot;C&quot;</tt></td>
<td><tt class="docutils literal">extern &quot;SYCL&quot;</tt></td>
<td><tt class="docutils literal">extern</tt></td>
</tr>
<tr><td>Varying parameters support</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr><td>Dispatch function for multi-target compilation</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr><td>Mangled name</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr><td>Mask parameter</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr><td>Calling convention specifier support</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr><td>Declaration in header file</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr><td>SYCL/DPC++ backend ABI compliance</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="data-layout">
<h2>Data Layout</h2>
<p>In general, <tt class="docutils literal">ispc</tt> tries to ensure that <tt class="docutils literal">struct</tt> types and other
complex data types are laid out in the same way in memory as they are in
C/C++.  Matching structure layout is important for easy interoperability
between C/C++ code and <tt class="docutils literal">ispc</tt> code.</p>
<p>The main complexity in sharing data between <tt class="docutils literal">ispc</tt> and C/C++ often comes
from reconciling data structures between <tt class="docutils literal">ispc</tt> code and application
code; it can be useful to declare the shared structures in <tt class="docutils literal">ispc</tt> code
and then examine the generated header file (which will have the C/C++
equivalents of them.)  For example, given a structure in <tt class="docutils literal">ispc</tt>:</p>
<pre class="literal-block">
// ispc code
struct Node {
   int count;
   float pos[3];
};
</pre>
<p>If a <tt class="docutils literal">uniform Node</tt> structure is used in the parameters to an <tt class="docutils literal">export</tt>
ed function, then the header file generated by the <tt class="docutils literal">ispc</tt> compiler will
have a declaration like:</p>
<pre class="literal-block">
// C/C++ code
struct Node {
   int count;
   float pos[3];
};
</pre>
<p>Because <tt class="docutils literal">varying</tt> types have size that depends on the size of the gang of
program instances, <tt class="docutils literal">ispc</tt> has restrictions on using varying types in
parameters to functions with the <tt class="docutils literal">export</tt> qualifier.  <tt class="docutils literal">ispc</tt> prohibits
parameters to exported functions to have varying type unless the parameter is
of pointer type.  (That is, <tt class="docutils literal">varying float</tt> isn't allowed, but <tt class="docutils literal">varying float * uniform</tt>
(uniform pointer to varying float) is permitted.)  Care must be taken
by the programmer to ensure that the data being accessed through any
pointers to varying data has the correct organization.</p>
<p>Similarly, <tt class="docutils literal">struct</tt> types shared with the application can also have
embedded pointers.</p>
<pre class="literal-block">
// C code
struct Foo {
    float *foo, *bar;
};
</pre>
<p>On the <tt class="docutils literal">ispc</tt> side, the corresponding <tt class="docutils literal">struct</tt> declaration is:</p>
<pre class="literal-block">
// ispc
struct Foo {
    float * uniform foo, * uniform bar;
};
</pre>
<p>If a pointer to a varying <tt class="docutils literal">struct</tt> type appears in an exported function,
the generated header file will have a definition like (for 8-wide SIMD):</p>
<pre class="literal-block">
// C/C++ code
struct Node {
  int count[8];
  float pos[3][8];
};
</pre>
<p>In the case of multiple target compilation, <tt class="docutils literal">ispc</tt> will generate multiple
header files and a &quot;general&quot; header file with definitions for multiple sizes.
Any pointers to varying variables in exported functions will be rewritten as <tt class="docutils literal">void *</tt>.
At runtime, the <tt class="docutils literal">ispc</tt> dispatch mechanism will cast these pointers to the appropriate
types.  Programmers can
provide C/C++ code with a mechanism to determine the gang width used
at runtime by <tt class="docutils literal">ispc</tt> by creating an exported function that simply
returns the value of <tt class="docutils literal">programCount</tt>.  An example of such a function
is provided in the file <tt class="docutils literal">examples/util/util.isph</tt> included in the <tt class="docutils literal">ispc</tt>
distribution.</p>
<p>There is one subtlety related to data layout to be aware of: <tt class="docutils literal">ispc</tt>
stores <tt class="docutils literal">uniform</tt> short-vector types in memory with their first element at
the machine's natural vector alignment (i.e., 16 bytes for a target that is
using Intel® SSE, and so forth.)  This implies that these types will have
different layout on different compilation targets.  As such, applications
should in general avoid accessing <tt class="docutils literal">uniform</tt> short vector types from C/C++
application code if possible.</p>
</div>
<div class="section" id="data-alignment-and-aliasing">
<h2>Data Alignment and Aliasing</h2>
<p>There are two important constraints that must be adhered to when
passing pointers from the application to <tt class="docutils literal">ispc</tt> programs.</p>
<p>The first is that it is required that it be valid to read memory at the
first element of any array that is passed to <tt class="docutils literal">ispc</tt>.  In practice, this
should just happen naturally, but it does mean that it is illegal to pass a
<tt class="docutils literal">NULL</tt> pointer as a parameter to an <tt class="docutils literal">ispc</tt> function called from the
application.</p>
<p>The second constraint is that pointers and references in <tt class="docutils literal">ispc</tt> programs
must not alias.  The <tt class="docutils literal">ispc</tt> compiler assumes that different pointers
can't end up pointing to the same memory location, either due to having the
same initial value, or through array indexing in the program as it
executed.</p>
<p>This aliasing constraint also applies to <tt class="docutils literal">reference</tt> parameters to
functions.  Given a function like:</p>
<pre class="literal-block">
void func(int &amp;a, int &amp;b) {
    a = 0;
    if (b == 0) { ... }
}
</pre>
<p>Then the same variable must not be passed to <tt class="docutils literal">func()</tt>.  This is
another case of aliasing, and if the caller calls the function as <tt class="docutils literal">func(x,
x)</tt>, it's not guaranteed that the <tt class="docutils literal">if</tt> test will evaluate to true, due
to the compiler's requirement of no aliasing.</p>
<p>(In the future, <tt class="docutils literal">ispc</tt> will have a mechanism to indicate that pointers
may alias.)</p>
</div>
<div class="section" id="restructuring-existing-programs-to-use-ispc">
<h2>Restructuring Existing Programs to Use ISPC</h2>
<p><tt class="docutils literal">ispc</tt> is designed to enable you to incorporate
SPMD parallelism into existing code with minimal modification; features
like the ability to share memory and data structures between C/C++ and
<tt class="docutils literal">ispc</tt> code and the ability to directly call back and forth between
<tt class="docutils literal">ispc</tt> and C/C++ are motivated by this.  These features also make it
easy to incrementally transform a program to use <tt class="docutils literal">ispc</tt>; the most
computationally-intensive localized parts of the computation can be
transformed into <tt class="docutils literal">ispc</tt> code while the remainder of the system is left
as is.</p>
<p>For a given section of code to be transitioned to run in <tt class="docutils literal">ispc</tt>, the
next question is how to parallelize the computation.  Generally, there will
be obvious loops inside which a large amount of computation is done (&quot;for
each ray&quot;, &quot;for each pixel&quot;, etc.)  Mapping these to the SPMD computational
style is often effective.</p>
<p>Carefully choose how to do the exact mapping of computation to SPMD program
instances.  This choice can impact the mix of gather/scatter memory access
versus coherent memory access, for example.  (See more on this topic in the
<a class="reference external" href="http://ispc.github.io/perfguide.html">ispc Performance Tuning Guide</a>.)  This decision can also impact the
coherence of control flow across the running SPMD program instances, which
can also have a significant effect on performance; in general, creating
groups of work that will tend to do similar computation across the SPMD
program instances improves performance.</p>
</div>
</div>
<div class="section" id="notices-disclaimers">
<h1>Notices &amp; Disclaimers</h1>
<p>Performance varies by use, configuration and other factors. Learn more at
www.intel.com/PerformanceIndex.</p>
</div>
      </article>

      <aside class="sidebar">
        <div class="sidebar-section">
          <h3>Resources</h3>
          <ul class="resource-links">
            <li><a href="http://github.com/ispc/ispc">GitHub Repository</a></li>
            <li><a href="https://github.com/ispc/ispc/discussions">Community Discussions</a></li>
            <li><a href="http://github.com/ispc/ispc/issues">Report Issues</a></li>
            <li><a href="https://github.com/orgs/ispc/projects/1">Release Planning</a></li>
            <li><a href="https://github.com/ispc/ispc/blob/main/CONTRIBUTING.md">Contributing Guide</a></li>
            <li><a href="http://github.com/ispc/ispc/wiki">Documentation Wiki</a></li>
          </ul>
        </div>
      </aside>
    </div>
  </main>

  <footer class="site-footer">
    <div class="footer-content">
      <p>&copy; <strong>Intel Corporation</strong> | <a href="http://validator.w3.org/check?uri=referer">Valid HTML</a> | <a href="http://jigsaw.w3.org/css-validator/check/referer">Valid CSS</a></p>
    </div>
  </footer>
</div>
</body>
</html>
