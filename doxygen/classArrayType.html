<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Intel SPMD Program Compiler: ArrayType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classArrayType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArrayType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>One-dimensional array type.  
 <a href="classArrayType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ArrayType:</div>
<div class="dyncontent">
<div class="center"><img src="classArrayType__inherit__graph.png" border="0" usemap="#ArrayType_inherit__map" alt="Inheritance graph"/></div>
<map name="ArrayType_inherit__map" id="ArrayType_inherit__map">
<area shape="rect" id="node2" href="classSequentialType.html" title="Abstract base class for types that represent sequences." alt="" coords="5,155,115,181"/><area shape="rect" id="node4" href="classCollectionType.html" title="Abstract base class for types that represent collections of other types." alt="" coords="7,80,113,107"/><area shape="rect" id="node6" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="35,5,85,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ArrayType:</div>
<div class="dyncontent">
<div class="center"><img src="classArrayType__coll__graph.png" border="0" usemap="#ArrayType_coll__map" alt="Collaboration graph"/></div>
<map name="ArrayType_coll__map" id="ArrayType_coll__map">
<area shape="rect" id="node2" href="classSequentialType.html" title="Abstract base class for types that represent sequences." alt="" coords="59,264,169,291"/><area shape="rect" id="node4" href="classCollectionType.html" title="Abstract base class for types that represent collections of other types." alt="" coords="59,173,165,200"/><area shape="rect" id="node6" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="27,96,77,123"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36104aa58c4d94a6810ae2a0d49a9d9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a36104aa58c4d94a6810ae2a0d49a9d9e">ArrayType</a> (const <a class="el" href="classType.html">Type</a> *elementType, int <a class="el" href="classArrayType.html#ac2acdf267a6afa67a9f8cd9633c3b621">numElements</a>)</td></tr>
<tr class="memitem:af3929b2fa58e010b70259b6c4fa0baff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#af3929b2fa58e010b70259b6c4fa0baff">GetVariability</a> () const </td></tr>
<tr class="memitem:a445fc4c07127683e522813ea39d2b578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a445fc4c07127683e522813ea39d2b578">IsBoolType</a> () const </td></tr>
<tr class="memitem:a7ecfafe295e93746c5c2ec4ca9423996"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a7ecfafe295e93746c5c2ec4ca9423996">IsFloatType</a> () const </td></tr>
<tr class="memitem:a9528bb4122b02bbe6ce983aa2ee5a866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a9528bb4122b02bbe6ce983aa2ee5a866">IsIntType</a> () const </td></tr>
<tr class="memitem:a92bafc4b556538aebdeee86208086ec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a92bafc4b556538aebdeee86208086ec9">IsUnsignedType</a> () const </td></tr>
<tr class="memitem:ac92ce0d837498af90182fe77542f064f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#ac92ce0d837498af90182fe77542f064f">IsConstType</a> () const </td></tr>
<tr class="memitem:ac2a42e35be81b43993d2daefc02d5926"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#ac2a42e35be81b43993d2daefc02d5926">GetBaseType</a> () const </td></tr>
<tr class="memitem:a7714386d2eb5ad482ab1b8b7bfd320a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a7714386d2eb5ad482ab1b8b7bfd320a3">GetAsVaryingType</a> () const </td></tr>
<tr class="memitem:a742c7dc11c86929c494d62925f777ef7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a742c7dc11c86929c494d62925f777ef7">GetAsUniformType</a> () const </td></tr>
<tr class="memitem:a74047c9b386eb3aa6a7ccda9e2dfdcff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a74047c9b386eb3aa6a7ccda9e2dfdcff">GetAsUnboundVariabilityType</a> () const </td></tr>
<tr class="memitem:aa5b78c416edcb8055b35447407596597"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#aa5b78c416edcb8055b35447407596597">GetAsSOAType</a> (int width) const </td></tr>
<tr class="memitem:a1feee4a977b72a7f06bc9e510809ec27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a1feee4a977b72a7f06bc9e510809ec27">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const </td></tr>
<tr class="memitem:a92ea81190e61ea34ca0c28690f29d821"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a92ea81190e61ea34ca0c28690f29d821">GetAsUnsignedType</a> () const </td></tr>
<tr class="memitem:a4ccb17ee3b649a2816ab8168b64e811b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a4ccb17ee3b649a2816ab8168b64e811b">GetAsConstType</a> () const </td></tr>
<tr class="memitem:af0a6bb7ec4db0bbd03e1adf6fc8c304f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#af0a6bb7ec4db0bbd03e1adf6fc8c304f">GetAsNonConstType</a> () const </td></tr>
<tr class="memitem:a9f0552ee4585f298ab98f108a7aab890"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a9f0552ee4585f298ab98f108a7aab890">GetString</a> () const </td></tr>
<tr class="memitem:aa5978b1550276038bbf17b09bccbffc3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#aa5978b1550276038bbf17b09bccbffc3">Mangle</a> () const </td></tr>
<tr class="memitem:a9101977af94bebe6ef2b7ca36debff3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a9101977af94bebe6ef2b7ca36debff3f">GetCDeclaration</a> (const std::string &amp;name) const </td></tr>
<tr class="memitem:aeb6c08334ad91a2801d89b45d00eec28"><td class="memItemLeft" align="right" valign="top">llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#aeb6c08334ad91a2801d89b45d00eec28">GetDIType</a> (llvm::DIDescriptor scope) const </td></tr>
<tr class="memitem:ad3b3f414bb6461097d0ff8ed21f97791"><td class="memItemLeft" align="right" valign="top">llvm::ArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#ad3b3f414bb6461097d0ff8ed21f97791">LLVMType</a> (llvm::LLVMContext *ctx) const </td></tr>
<tr class="memitem:accb48932e380af236d45c9d0f338f8ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#accb48932e380af236d45c9d0f338f8ff">TotalElementCount</a> () const </td></tr>
<tr class="memitem:abd41c2442a7dc53f404399d746d0c6e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#abd41c2442a7dc53f404399d746d0c6e8">GetElementCount</a> () const </td></tr>
<tr class="memitem:a0c07b5af9127e3dfc4626782f4227377"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a0c07b5af9127e3dfc4626782f4227377">GetElementType</a> () const </td></tr>
<tr class="memitem:af67c31c425bd3fbba9e00befd213e437"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArrayType.html">ArrayType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#af67c31c425bd3fbba9e00befd213e437">GetSizedArray</a> (int length) const </td></tr>
<tr class="inherit_header pub_methods_classSequentialType"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSequentialType')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classSequentialType.html">SequentialType</a></td></tr>
<tr class="memitem:a8249646c6a409fc1de2a9f23d20638b4 inherit pub_methods_classSequentialType"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequentialType.html#a8249646c6a409fc1de2a9f23d20638b4">GetElementType</a> (int index) const </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3339e248b1eda7a5bf5cb61e25ee77b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#ab3339e248b1eda7a5bf5cb61e25ee77b">SizeUnsizedArrays</a> (const <a class="el" href="classType.html">Type</a> *type, <a class="el" href="classExpr.html">Expr</a> *initExpr)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a147895cdaa4b3af5afd3321fe378dbd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#a147895cdaa4b3af5afd3321fe378dbd2">child</a></td></tr>
<tr class="memitem:ac2acdf267a6afa67a9f8cd9633c3b621"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArrayType.html#ac2acdf267a6afa67a9f8cd9633c3b621">numElements</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classType"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classType')"><img src="closed.png" alt="-"/>&nbsp;Public Attributes inherited from <a class="el" href="classType.html">Type</a></td></tr>
<tr class="memitem:ab1d91eeddf01faa36a8cccddb5bb2a06 inherit pub_attribs_classType"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab1d91eeddf01faa36a8cccddb5bb2a06">typeId</a></td></tr>
<tr class="inherit_header pro_methods_classSequentialType"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSequentialType')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="classSequentialType.html">SequentialType</a></td></tr>
<tr class="memitem:ac4726b22e3c9461fc0a586b8085ad3e2 inherit pro_methods_classSequentialType"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequentialType.html#ac4726b22e3c9461fc0a586b8085ad3e2">SequentialType</a> (<a class="el" href="type_8h.html#ae3b8b91f7f6754d1ef7fd67c1bdaa501">TypeId</a> id)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>One-dimensional array type. </p>
<p><a class="el" href="classArrayType.html" title="One-dimensional array type.">ArrayType</a> represents a one-dimensional array of instances of some other type. (Multi-dimensional arrays are represented by ArrayTypes that in turn hold ArrayTypes as their child types.) </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00537">537</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a36104aa58c4d94a6810ae2a0d49a9d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayType::ArrayType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An <a class="el" href="classArrayType.html" title="One-dimensional array type.">ArrayType</a> is created by providing the type of the elements that it stores, and the SOA width to use in laying out the array in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementType</td><td><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> of the array elements </td></tr>
    <tr><td class="paramname">numElements</td><td>Total number of elements in the array. This parameter may be zero, in which case this is an "unsized" array type. (Arrays of specific size can be converted to unsized arrays to be passed to functions that take array parameters, for example). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01210">1210</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8cpp_source.html#l03332">Type::Equal()</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01344">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01354">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l01314">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01304">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l01294">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01334">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l01284">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01473">GetSizedArray()</a>, <a class="el" href="type_8cpp_source.html#l01324">ResolveUnboundVariability()</a>, and <a class="el" href="type_8cpp_source.html#l01480">SizeUnsizedArrays()</a>.</p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a4ccb17ee3b649a2816ab8168b64e811b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01344">1344</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type::GetAsConstType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="af0a6bb7ec4db0bbd03e1adf6fc8c304f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01354">1354</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type::GetAsNonConstType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="aa5b78c416edcb8055b35447407596597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01314">1314</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type::GetAsSOAType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="a74047c9b386eb3aa6a7ccda9e2dfdcff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implements <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01304">1304</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type::GetAsUnboundVariabilityType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="a742c7dc11c86929c494d62925f777ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01294">1294</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type::GetAsUniformType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="a92ea81190e61ea34ca0c28690f29d821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a signed integer type, return the unsigned version of the type. Otherwise, return the original type. </p>

<p>Reimplemented from <a class="el" href="classType.html#a127bfce35f03cb94bd25fbe07efb941a">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01334">1334</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="type_8cpp_source.html#l03021">Type::GetAsUnsignedType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="a7714386d2eb5ad482ab1b8b7bfd320a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01284">1284</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type::GetAsVaryingType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a42e35be81b43993d2daefc02d5926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * ArrayType::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implements <a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01271">1271</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00600">child</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01417">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01376">GetString()</a>, and <a class="el" href="expr_8cpp_source.html#l06547">TypeCastExpr::GetValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a9101977af94bebe6ef2b7ca36debff3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ArrayType::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implements <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01417">1417</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01271">GetBaseType()</a>, <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type::GetCDeclaration()</a>, <a class="el" href="type_8h_source.html#l00160">Type::GetSOAWidth()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, <a class="el" href="type_8h_source.html#l00602">numElements</a>, and <a class="el" href="parse_8yy_source.html#l38083">s</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6c08334ad91a2801d89b45d00eec28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DIType ArrayType::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implements <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01461">1461</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l00083">lCreateDIArray()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00511">AtomicType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01169">PointerType::GetDIType()</a>, and <a class="el" href="type_8cpp_source.html#l01703">VectorType::GetDIType()</a>.</p>

</div>
</div>
<a class="anchor" id="abd41c2442a7dc53f404399d746d0c6e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ArrayType::GetElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of elements in the collection. </p>

<p>Implements <a class="el" href="classCollectionType.html#abc5eb48e176e4abb0fa405d41ae99381">CollectionType</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01364">1364</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02591">ReferenceType::GetCDeclaration()</a>, <a class="el" href="decl_8cpp_source.html#l00658">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l06547">TypeCastExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l03230">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00196">lDoTypeConv()</a>, <a class="el" href="stmt_8cpp_source.html#l00134">lHasUnsizedArrays()</a>, and <a class="el" href="type_8cpp_source.html#l01480">SizeUnsizedArrays()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c07b5af9127e3dfc4626782f4227377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * ArrayType::GetElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> of the elements that the sequence stores; for SequentialTypes, all elements have the same type . </p>

<p>Implements <a class="el" href="classSequentialType.html#a923d9a8ec402a9880b6d149b8f372916">SequentialType</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01370">1370</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00600">child</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02591">ReferenceType::GetCDeclaration()</a>, <a class="el" href="decl_8cpp_source.html#l00294">Declarator::InitFromType()</a>, <a class="el" href="type_8cpp_source.html#l03230">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l00196">lDoTypeConv()</a>, <a class="el" href="module_8cpp_source.html#l01104">lGetElementStructType()</a>, <a class="el" href="module_8cpp_source.html#l01275">lGetExportedTypes()</a>, <a class="el" href="stmt_8cpp_source.html#l00134">lHasUnsizedArrays()</a>, <a class="el" href="expr_8cpp_source.html#l03952">lVaryingStructHasUniformMember()</a>, and <a class="el" href="type_8cpp_source.html#l01480">SizeUnsizedArrays()</a>.</p>

</div>
</div>
<a class="anchor" id="af67c31c425bd3fbba9e00befd213e437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::GetSizedArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new array of the same child type, but with the given length. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01473">1473</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01480">SizeUnsizedArrays()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f0552ee4585f298ab98f108a7aab890"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ArrayType::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implements <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01376">1376</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="type_8cpp_source.html#l01271">GetBaseType()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, <a class="el" href="type_8h_source.html#l00602">numElements</a>, and <a class="el" href="parse_8yy_source.html#l38083">s</a>.</p>

</div>
</div>
<a class="anchor" id="af3929b2fa58e010b70259b6c4fa0baff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVariability.html">Variability</a> ArrayType::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implements <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01235">1235</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type::GetVariability()</a>, and <a class="el" href="type_8h_source.html#l00059">Variability::Uniform</a>.</p>

</div>
</div>
<a class="anchor" id="a445fc4c07127683e522813ea39d2b578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArrayType::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implements <a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01259">1259</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac92ce0d837498af90182fe77542f064f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArrayType::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implements <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01265">1265</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00600">child</a>, and <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type::IsConstType()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ecfafe295e93746c5c2ec4ca9423996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArrayType::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implements <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01241">1241</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9528bb4122b02bbe6ce983aa2ee5a866"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArrayType::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implements <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01247">1247</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92bafc4b556538aebdeee86208086ec9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ArrayType::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implements <a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01253">1253</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3b3f414bb6461097d0ff8ed21f97791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::ArrayType * ArrayType::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implements <a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01219">1219</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="classType.html#a04eb42d850a697fc181b388688b6393e">Type::LLVMType()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="type_8h_source.html#l00602">numElements</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00471">AtomicType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l00782">EnumType::LLVMType()</a>, and <a class="el" href="type_8cpp_source.html#l01108">PointerType::LLVMType()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5978b1550276038bbf17b09bccbffc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ArrayType::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implements <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01401">1401</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type::Mangle()</a>, <a class="el" href="type_8h_source.html#l00602">numElements</a>, and <a class="el" href="parse_8yy_source.html#l38083">s</a>.</p>

</div>
</div>
<a class="anchor" id="a1feee4a977b72a7f06bc9e510809ec27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayType.html">ArrayType</a> * ArrayType::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01324">1324</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, <a class="el" href="type_8h_source.html#l00602">numElements</a>, and <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type::ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3339e248b1eda7a5bf5cb61e25ee77b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * ArrayType::SizeUnsizedArrays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExpr.html">Expr</a> *&#160;</td>
          <td class="paramname"><em>initExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the given type is a (possibly multi-dimensional) array type and the initializer expression is an expression list, set the size of any array dimensions that are unsized according to the number of elements in the corresponding sectoin of the initializer expression. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01480">1480</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="ispc_8h_source.html#l00159">Assert</a>, <a class="el" href="util_8cpp_source.html#l00387">Error()</a>, <a class="el" href="module_8h_source.html#l00144">Module::errorCount</a>, <a class="el" href="expr_8h_source.html#l00240">ExprList::exprs</a>, <a class="el" href="type_8cpp_source.html#l01364">GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01370">GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l01473">GetSizedArray()</a>, <a class="el" href="ispc_8cpp_source.html#l00083">m</a>, and <a class="el" href="ispc_8cpp_source.html#l00807">Union()</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00401">Module::AddGlobalVariable()</a>, and <a class="el" href="stmt_8cpp_source.html#l00147">DeclStmt::EmitCode()</a>.</p>

</div>
</div>
<a class="anchor" id="accb48932e380af236d45c9d0f338f8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArrayType::TotalElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the total number of elements in the array, including all dimensions if this is a multidimensional array. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01451">1451</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00600">child</a>, <a class="el" href="type_8h_source.html#l00602">numElements</a>, and <a class="el" href="type_8cpp_source.html#l01451">TotalElementCount()</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00401">Module::AddGlobalVariable()</a>, and <a class="el" href="type_8cpp_source.html#l01451">TotalElementCount()</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a147895cdaa4b3af5afd3321fe378dbd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* const ArrayType::child</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> of the elements of the array. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00600">600</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01344">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01354">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l01314">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01304">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l01294">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01334">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l01284">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01271">GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l01417">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01461">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01370">GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l01473">GetSizedArray()</a>, <a class="el" href="type_8cpp_source.html#l01376">GetString()</a>, <a class="el" href="type_8cpp_source.html#l01235">GetVariability()</a>, <a class="el" href="type_8cpp_source.html#l01265">IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01219">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01401">Mangle()</a>, <a class="el" href="type_8cpp_source.html#l01324">ResolveUnboundVariability()</a>, and <a class="el" href="type_8cpp_source.html#l01451">TotalElementCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2acdf267a6afa67a9f8cd9633c3b621"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int ArrayType::numElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of elements in the array. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00602">602</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01210">ArrayType()</a>, <a class="el" href="type_8cpp_source.html#l01344">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01354">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l01314">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01304">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l01294">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01334">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l01284">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01417">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01461">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01364">GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01473">GetSizedArray()</a>, <a class="el" href="type_8cpp_source.html#l01376">GetString()</a>, <a class="el" href="type_8cpp_source.html#l01219">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01401">Mangle()</a>, <a class="el" href="type_8cpp_source.html#l01324">ResolveUnboundVariability()</a>, and <a class="el" href="type_8cpp_source.html#l01451">TotalElementCount()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 11 2013 20:28:51 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
