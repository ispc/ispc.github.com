<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Intel SPMD Program Compiler: FunctionSymbolExpr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctionSymbolExpr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FunctionSymbolExpr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Expression representing a function symbol in the program (generally used for a function call).  
 <a href="classFunctionSymbolExpr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="expr_8h_source.html">expr.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FunctionSymbolExpr:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionSymbolExpr__inherit__graph.png" border="0" usemap="#FunctionSymbolExpr_inherit__map" alt="Inheritance graph"/></div>
<map name="FunctionSymbolExpr_inherit__map" id="FunctionSymbolExpr_inherit__map">
<area shape="rect" id="node2" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement..." alt="" coords="51,80,97,107"/><area shape="rect" id="node4" href="classASTNode.html" title="Abstract base class for nodes in the abstract syntax tree (AST)." alt="" coords="35,5,113,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FunctionSymbolExpr:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionSymbolExpr__coll__graph.png" border="0" usemap="#FunctionSymbolExpr_coll__map" alt="Collaboration graph"/></div>
<map name="FunctionSymbolExpr_coll__map" id="FunctionSymbolExpr_coll__map">
<area shape="rect" id="node2" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement..." alt="" coords="146,320,192,347"/><area shape="rect" id="node16" href="classConstExpr.html" title="Expression representing a compile&#45;time constant value." alt="" coords="704,421,784,448"/><area shape="rect" id="node4" href="classASTNode.html" title="Abstract base class for nodes in the abstract syntax tree (AST)." alt="" coords="135,229,213,256"/><area shape="rect" id="node54" href="classStmt.html" title="Interface class for statements in the ispc language." alt="" coords="11,371,61,397"/><area shape="rect" id="node6" href="structSourcePos.html" title="Representation of a range of positions in a source file." alt="" coords="132,139,217,165"/><area shape="rect" id="node14" href="classSymbol.html" title="Representation of a program symbol." alt="" coords="765,525,829,552"/><area shape="rect" id="node51" href="classFunction.html" title="Function" alt="" coords="147,763,219,789"/><area shape="rect" id="node35" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="1149,320,1200,347"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc3511eb43f830bc07269437e5f985d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#adc3511eb43f830bc07269437e5f985d3">FunctionSymbolExpr</a> (const char *<a class="el" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a>, const std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;candFuncs, <a class="el" href="structSourcePos.html">SourcePos</a> <a class="el" href="classASTNode.html#a8484df258e27b6bf805437c11112824c">pos</a>)</td></tr>
<tr class="memitem:a1eee5a80543e4a51b2ccb6c41396ccc5"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a1eee5a80543e4a51b2ccb6c41396ccc5">GetValue</a> (<a class="el" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) const </td></tr>
<tr class="memitem:a36c54fa6b3874295878880e92e90575b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a36c54fa6b3874295878880e92e90575b">GetType</a> () const </td></tr>
<tr class="memitem:a7f6831ce09b79f8cdca14365d11a5bb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a7f6831ce09b79f8cdca14365d11a5bb1">GetBaseSymbol</a> () const </td></tr>
<tr class="memitem:ad44e613dd2071288a93a8487aacbcdf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExpr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#ad44e613dd2071288a93a8487aacbcdf8">TypeCheck</a> ()</td></tr>
<tr class="memitem:a16727f6e846c7a554f823c397a1a6149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExpr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a16727f6e846c7a554f823c397a1a6149">Optimize</a> ()</td></tr>
<tr class="memitem:a754a28381847e8d9eb7772cbc56c6774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a754a28381847e8d9eb7772cbc56c6774">Print</a> () const </td></tr>
<tr class="memitem:a7a69453705486679ffa3e991a748733b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a7a69453705486679ffa3e991a748733b">EstimateCost</a> () const </td></tr>
<tr class="memitem:aa165c8f40585c2cc1aa6dce5b788f5d0"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#aa165c8f40585c2cc1aa6dce5b788f5d0">GetConstant</a> (const <a class="el" href="classType.html">Type</a> *type) const </td></tr>
<tr class="memitem:aceb7cd318b78f800b7aa3b0b81672fd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#aceb7cd318b78f800b7aa3b0b81672fd1">ResolveOverloads</a> (<a class="el" href="structSourcePos.html">SourcePos</a> argPos, const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;argTypes, const std::vector&lt; bool &gt; *argCouldBeNULL=NULL, const std::vector&lt; bool &gt; *argIsConstant=NULL)</td></tr>
<tr class="memitem:a279cba96c85ccb8bec2c4d188641804b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a279cba96c85ccb8bec2c4d188641804b">GetMatchingFunction</a> ()</td></tr>
<tr class="inherit_header pub_methods_classExpr"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classExpr')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classExpr.html">Expr</a></td></tr>
<tr class="memitem:a2b863b1ee3b938b67f5b067142e94b96 inherit pub_methods_classExpr"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExpr.html#a2b863b1ee3b938b67f5b067142e94b96">Expr</a> (<a class="el" href="structSourcePos.html">SourcePos</a> p)</td></tr>
<tr class="memitem:a9d3baf6e5f52fff8e916f3c0b5139c2e inherit pub_methods_classExpr"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExpr.html#a9d3baf6e5f52fff8e916f3c0b5139c2e">GetLValue</a> (<a class="el" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) const </td></tr>
<tr class="memitem:a9893c01e9872f3f07c43f0f67abecad2 inherit pub_methods_classExpr"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExpr.html#a9893c01e9872f3f07c43f0f67abecad2">GetLValueType</a> () const </td></tr>
<tr class="inherit_header pub_methods_classASTNode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classASTNode')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classASTNode.html">ASTNode</a></td></tr>
<tr class="memitem:adacd1e72bdef50169988993850670db5 inherit pub_methods_classASTNode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASTNode.html#adacd1e72bdef50169988993850670db5">ASTNode</a> (<a class="el" href="structSourcePos.html">SourcePos</a> p)</td></tr>
<tr class="memitem:a41a691f37fa038eb183280effeb8ba4e inherit pub_methods_classASTNode"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASTNode.html#a41a691f37fa038eb183280effeb8ba4e">~ASTNode</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad0a510cd40937d0ccbc7d4859ae4e378"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#ad0a510cd40937d0ccbc7d4859ae4e378">getCandidateFunctions</a> (int argCount) const </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a72d0f0dfd7852df5ae8d595ec42b0270"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a72d0f0dfd7852df5ae8d595ec42b0270">computeOverloadCost</a> (const <a class="el" href="classFunctionType.html">FunctionType</a> *ftype, const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;argTypes, const std::vector&lt; bool &gt; *argCouldBeNULL, const std::vector&lt; bool &gt; *argIsConstant, int *cost)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a23dc665e0c2734daea7439ba42c75f45"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a></td></tr>
<tr class="memitem:a78f5eb40094e572c102215fd9e9c8d9a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a78f5eb40094e572c102215fd9e9c8d9a">candidateFunctions</a></td></tr>
<tr class="memitem:ada53c1fccabda44ceb4a65faa9b8fc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#ada53c1fccabda44ceb4a65faa9b8fc8a">matchingFunc</a></td></tr>
<tr class="memitem:a71400218b7f4dedb4d339358b05c525a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionSymbolExpr.html#a71400218b7f4dedb4d339358b05c525a">triedToResolve</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classASTNode"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classASTNode')"><img src="closed.png" alt="-"/>&nbsp;Public Attributes inherited from <a class="el" href="classASTNode.html">ASTNode</a></td></tr>
<tr class="memitem:a8484df258e27b6bf805437c11112824c inherit pub_attribs_classASTNode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASTNode.html#a8484df258e27b6bf805437c11112824c">pos</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Expression representing a function symbol in the program (generally used for a function call). </p>

<p>Definition at line <a class="el" href="expr_8h_source.html#l00601">601</a> of file <a class="el" href="expr_8h_source.html">expr.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adc3511eb43f830bc07269437e5f985d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionSymbolExpr::FunctionSymbolExpr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>candFuncs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l07985">7985</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l00647">candidateFunctions</a>, <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>, <a class="el" href="expr_8h_source.html#l00642">name</a>, and <a class="el" href="expr_8h_source.html#l00652">triedToResolve</a>.</p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a72d0f0dfd7852df5ae8d595ec42b0270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FunctionSymbolExpr::computeOverloadCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFunctionType.html">FunctionType</a> *&#160;</td>
          <td class="paramname"><em>ftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>argCouldBeNULL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>argIsConstant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes the value of a cost function that represents the cost of calling a function of the given type with arguments of the given types. If it's not possible to call the function, regardless of any type conversions applied, a cost of -1 is returned. </p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08188">8188</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="expr_8cpp_source.html#l00587">CanConvertTypes()</a>, <a class="el" href="type_8cpp_source.html#l03427">Type::Equal()</a>, <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type::GetAsNonConstType()</a>, <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l03078">FunctionType::GetParameterType()</a>, <a class="el" href="type_8cpp_source.html#l03109">Type::GetReferenceTarget()</a>, <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type::IsConstType()</a>, <a class="el" href="type_8h_source.html#l00145">Type::IsUniformType()</a>, <a class="el" href="type_8h_source.html#l00150">Type::IsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l08169">lArgIsPointerType()</a>, and <a class="el" href="expr_8cpp_source.html#l08099">lIsMatchWithTypeWidening()</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a69453705486679ffa3e991a748733b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FunctionSymbolExpr::EstimateCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the execution cost of the node (not including the cost of the children. The value returned should be based on the COST_* enumerant values defined in <a class="el" href="ispc_8h.html" title="Main ispc.header file. Defines Target, Globals and Opt classes.">ispc.h</a>. </p>

<p>Implements <a class="el" href="classASTNode.html#add2ef84b57f0cda15ae3c7ad983ff909">ASTNode</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08033">8033</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f6831ce09b79f8cdca14365d11a5bb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * FunctionSymbolExpr::GetBaseSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For expressions that have values based on a symbol (e.g. regular symbol references, array indexing, etc.), this returns a pointer to that symbol. </p>

<p>Reimplemented from <a class="el" href="classExpr.html#a4219def5afcedd6551acf0954d2fa2de">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08015">8015</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>.</p>

</div>
</div>
<a class="anchor" id="ad0a510cd40937d0ccbc7d4859ae4e378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; FunctionSymbolExpr::getCandidateFunctions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argCount</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08144">8144</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00166">AssertPos</a>, <a class="el" href="expr_8h_source.html#l00647">candidateFunctions</a>, <a class="el" href="type_8h_source.html#l00892">FunctionType::GetNumParameters()</a>, and <a class="el" href="type_8cpp_source.html#l03085">FunctionType::GetParameterDefault()</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<a class="anchor" id="aa165c8f40585c2cc1aa6dce5b788f5d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * FunctionSymbolExpr::GetConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is a constant expression that can be converted to a constant of the given type, this method should return the corresponding llvm::Constant value. Otherwise it should return NULL. </p>

<p>Reimplemented from <a class="el" href="classExpr.html#a0409d1bd3dae14b118bea8b8c28321db">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08050">8050</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l03427">Type::Equal()</a>, <a class="el" href="util_8cpp_source.html#l00387">Error()</a>, <a class="el" href="sym_8h_source.html#l00076">Symbol::function</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>, and <a class="el" href="sym_8h_source.html#l00084">Symbol::type</a>.</p>

</div>
</div>
<a class="anchor" id="a279cba96c85ccb8bec2c4d188641804b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * FunctionSymbolExpr::GetMatchingFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08427">8427</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>.</p>

</div>
</div>
<a class="anchor" id="a36c54fa6b3874295878880e92e90575b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionSymbolExpr::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> of the expression. </p>

<p>Implements <a class="el" href="classExpr.html#a8451d4988f430bea94e354dc44e6b094">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l07997">7997</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="util_8cpp_source.html#l00387">Error()</a>, <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>, <a class="el" href="expr_8h_source.html#l00642">name</a>, <a class="el" href="expr_8h_source.html#l00652">triedToResolve</a>, and <a class="el" href="sym_8h_source.html#l00084">Symbol::type</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l08039">Print()</a>.</p>

</div>
</div>
<a class="anchor" id="a1eee5a80543e4a51b2ccb6c41396ccc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * FunctionSymbolExpr::GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFunctionEmitContext.html">FunctionEmitContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main method for <a class="el" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> implementations to implement. It should call methods in the <a class="el" href="classFunctionEmitContext.html">FunctionEmitContext</a> to emit LLVM IR instructions to the current basic block in order to generate an llvm::Value that represents the expression's value. </p>

<p>Implements <a class="el" href="classExpr.html#a2bc3d2bff41746985dd2b07d0637d7e8">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08009">8009</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00076">Symbol::function</a>, and <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>.</p>

</div>
</div>
<a class="anchor" id="a16727f6e846c7a554f823c397a1a6149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExpr.html">Expr</a> * FunctionSymbolExpr::Optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should perform early optimizations of the expression (constant folding, etc.) and return a pointer to the resulting expression. If an error is encountered during optimization, NULL should be returned. </p>

<p>Implements <a class="el" href="classExpr.html#aeffa58fc4e9b2b058c1d3931caed2ae4">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08027">8027</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a754a28381847e8d9eb7772cbc56c6774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FunctionSymbolExpr::Print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the expression to standard output (used for debugging). </p>

<p>Implements <a class="el" href="classExpr.html#ac8d62a881604e554c36ec30738163423">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08039">8039</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="expr_8cpp_source.html#l07997">GetType()</a>, <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>, <a class="el" href="sym_8h_source.html#l00071">Symbol::name</a>, and <a class="el" href="ispc_8cpp_source.html#l01161">SourcePos::Print()</a>.</p>

</div>
</div>
<a class="anchor" id="aceb7cd318b78f800b7aa3b0b81672fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionSymbolExpr::ResolveOverloads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>argPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>argCouldBeNULL</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>argIsConstant</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the types of the function arguments, in the presence of function overloading, this method resolves which actual function the arguments match best. If the argCouldBeNULL parameter is non-NULL, each element indicates whether the corresponding argument is the number zero, indicating that it could be a NULL pointer, and if argIsConstant is non-NULL, each element indicates whether the corresponding argument is a compile-time constant value. Both of these parameters may be NULL (for cases where overload resolution is being done just given type information without the parameter argument expressions being available. This function returns true on success. </p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08316">8316</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00166">AssertPos</a>, <a class="el" href="expr_8h_source.html#l00647">candidateFunctions</a>, <a class="el" href="expr_8cpp_source.html#l08188">computeOverloadCost()</a>, <a class="el" href="util_8cpp_source.html#l00387">Error()</a>, <a class="el" href="expr_8cpp_source.html#l08144">getCandidateFunctions()</a>, <a class="el" href="expr_8cpp_source.html#l08070">lGetOverloadCandidateMessage()</a>, <a class="el" href="expr_8h_source.html#l00650">matchingFunc</a>, <a class="el" href="expr_8h_source.html#l00642">name</a>, <a class="el" href="expr_8h_source.html#l00652">triedToResolve</a>, and <a class="el" href="util_8cpp_source.html#l00412">Warning()</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03747">FunctionCallExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l00615">PossiblyResolveFunctionOverloads()</a>, and <a class="el" href="expr_8cpp_source.html#l03785">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ad44e613dd2071288a93a8487aacbcdf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExpr.html">Expr</a> * FunctionSymbolExpr::TypeCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should perform type checking of the expression and return a pointer to the resulting expression. If an error is encountered, NULL should be returned. </p>

<p>Implements <a class="el" href="classExpr.html#acf568bb978a23556c8e40f2662715190">Expr</a>.</p>

<p>Definition at line <a class="el" href="expr_8cpp_source.html#l08021">8021</a> of file <a class="el" href="expr_8cpp_source.html">expr.cpp</a>.</p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a78f5eb40094e572c102215fd9e9c8d9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSymbol.html">Symbol</a> *&gt; FunctionSymbolExpr::candidateFunctions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All of the functions with the name given in the function call; there may be more then one, in which case we need to resolve which overload is the best match. </p>

<p>Definition at line <a class="el" href="expr_8h_source.html#l00647">647</a> of file <a class="el" href="expr_8h_source.html">expr.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l07985">FunctionSymbolExpr()</a>, <a class="el" href="expr_8cpp_source.html#l08144">getCandidateFunctions()</a>, and <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<a class="anchor" id="ada53c1fccabda44ceb4a65faa9b8fc8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a>* FunctionSymbolExpr::matchingFunc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual matching function found after overload resolution. </p>

<p>Definition at line <a class="el" href="expr_8h_source.html#l00650">650</a> of file <a class="el" href="expr_8h_source.html">expr.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l07985">FunctionSymbolExpr()</a>, <a class="el" href="expr_8cpp_source.html#l08015">GetBaseSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l08050">GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l08427">GetMatchingFunction()</a>, <a class="el" href="expr_8cpp_source.html#l07997">GetType()</a>, <a class="el" href="expr_8cpp_source.html#l08009">GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l08039">Print()</a>, and <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<a class="anchor" id="a23dc665e0c2734daea7439ba42c75f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionSymbolExpr::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name of the function that is being called. </p>

<p>Definition at line <a class="el" href="expr_8h_source.html#l00642">642</a> of file <a class="el" href="expr_8h_source.html">expr.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l07985">FunctionSymbolExpr()</a>, <a class="el" href="expr_8cpp_source.html#l07997">GetType()</a>, and <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<a class="anchor" id="a71400218b7f4dedb4d339358b05c525a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionSymbolExpr::triedToResolve</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="expr_8h_source.html#l00652">652</a> of file <a class="el" href="expr_8h_source.html">expr.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l07985">FunctionSymbolExpr()</a>, <a class="el" href="expr_8cpp_source.html#l07997">GetType()</a>, and <a class="el" href="expr_8cpp_source.html#l08316">ResolveOverloads()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="expr_8h_source.html">expr.h</a></li>
<li><a class="el" href="expr_8cpp_source.html">expr.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 18 2014 18:28:38 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
