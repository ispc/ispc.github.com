<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Intel® ISPC User's Guide - Complete documentation for the high-performance SIMD compiler">
<link rel="icon" type="image/png" href="favicon.png">
<link rel="stylesheet" href="css/style.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Frequently Asked Questions About Intel® ISPC</title>
</head>
<body>
<div class="container">
  <header class="site-header">
    <nav class="main-nav">
      <div class="nav-brand">
        <h1>Intel® ISPC</h1>
      </div>
      <ul class="nav-menu">
        <li class="nav-item"><a href="index.html">Overview</a></li>
        <li class="nav-item"><a href="features.html">Features</a></li>
        <li class="nav-item"><a href="downloads.html">Downloads</a></li>
        <li class="nav-item active"><a href="documentation.html">Documentation</a></li>
        <li class="nav-item"><a href="perf.html">Performance</a></li>
        <li class="nav-item"><a href="contrib.html">Contributors</a></li>
      </ul>
    </nav>
  </header>

  <main class="main-content">
    <div class="content-grid">
      <article class="content-main">
<h1 class="title">Frequently Asked Questions About Intel® ISPC</h1>

<p>This document includes a number of frequently (and not frequently) asked
questions about ispc, the Intel® Implicit SPMD Program Compiler (Intel® ISPC).
The source to this document is in the file <tt class="docutils literal">docs/faq.rst</tt> in the <tt class="docutils literal">ispc</tt> source
distribution.</p>
<ul class="simple">
<li>Understanding ispc's Output<ul>
<li><a class="reference internal" href="#how-can-i-see-the-assembly-language-generated-by-ispc">How can I see the assembly language generated by ispc?</a></li>
<li><a class="reference internal" href="#how-can-i-have-the-assembly-output-be-printed-using-intel-assembly-syntax">How can I have the assembly output be printed using Intel assembly syntax?</a></li>
<li><a class="reference internal" href="#why-are-there-multiple-versions-of-exported-ispc-functions-in-the-assembly-output">Why are there multiple versions of exported ispc functions in the assembly output?</a></li>
<li><a class="reference internal" href="#how-can-i-more-easily-see-gathers-and-scatters-in-generated-assembly">How can I more easily see gathers and scatters in generated assembly?</a></li>
</ul>
</li>
<li>Language Details<ul>
<li><a class="reference internal" href="#what-is-the-difference-between-int-foo-and-int-foo">What is the difference between &quot;int *foo&quot; and &quot;int foo[]&quot;?</a></li>
<li><a class="reference internal" href="#why-are-pointed-to-types-uniform-by-default">Why are pointed-to types &quot;uniform&quot; by default?</a></li>
<li><a class="reference internal" href="#why-am-i-getting-an-error-about-assigning-a-varying-lvalue-to-a-reference-type">Why am I getting an error about assigning a varying lvalue to a reference type?</a></li>
</ul>
</li>
<li>Interoperability<ul>
<li><a class="reference internal" href="#how-can-i-supply-an-initial-execution-mask-in-the-call-from-the-application">How can I supply an initial execution mask in the call from the application?</a></li>
<li><a class="reference internal" href="#how-can-i-generate-a-single-binary-executable-with-support-for-multiple-instruction-sets">How can I generate a single binary executable with support for multiple instruction sets?</a></li>
<li><a class="reference internal" href="#how-can-i-determine-at-run-time-which-vector-instruction-set-s-instructions-were-selected-to-execute">How can I determine at run-time which vector instruction set's instructions were selected to execute?</a></li>
<li><a class="reference internal" href="#is-it-possible-to-inline-ispc-functions-in-c-c-code">Is it possible to inline ispc functions in C/C++ code?</a></li>
<li><a class="reference internal" href="#why-is-it-illegal-to-pass-varying-values-from-c-c-to-ispc-functions">Why is it illegal to pass &quot;varying&quot; values from C/C++ to ispc functions?</a></li>
</ul>
</li>
<li>Programming Techniques<ul>
<li><a class="reference internal" href="#what-primitives-are-there-for-communicating-between-spmd-program-instances">What primitives are there for communicating between SPMD program instances?</a></li>
<li><a class="reference internal" href="#how-can-a-gang-of-program-instances-generate-variable-amounts-of-output-efficiently">How can a gang of program instances generate variable amounts of output efficiently?</a></li>
<li><a class="reference internal" href="#is-it-possible-to-use-ispc-for-explicit-vector-programming">Is it possible to use ispc for explicit vector programming?</a></li>
<li><a class="reference internal" href="#how-can-i-debug-my-ispc-programs-using-valgrind">How can I debug my ispc programs using Valgrind?</a></li>
<li><a class="reference internal" href="#foreach-statements-generate-more-complex-assembly-than-i-d-expect-what-s-going-on">foreach statements generate more complex assembly than I'd expect; what's going on?</a></li>
<li><a class="reference internal" href="#how-do-i-launch-an-individual-task-for-each-active-program-instance">How do I launch an individual task for each active program instance?</a></li>
</ul>
</li>
</ul>
<div class="section" id="understanding-ispc-s-output">
<h1>Understanding ispc's Output</h1>
<div class="section" id="how-can-i-see-the-assembly-language-generated-by-ispc">
<h2>How can I see the assembly language generated by ispc?</h2>
<p>The <tt class="docutils literal"><span class="pre">--emit-asm</span></tt> flag causes assembly output to be generated.  If the
<tt class="docutils literal"><span class="pre">-o</span></tt> command-line flag is also supplied, the assembly is stored in the
given file, or printed to standard output if <tt class="docutils literal">-</tt> is specified for the
filename.  For example, given the simple <tt class="docutils literal">ispc</tt> program:</p>
<pre class="literal-block">
export uniform int foo(uniform int a, uniform int b) {
    return a+b;
}
</pre>
<p>If the SSE4 target is used, then the following assembly is printed:</p>
<pre class="literal-block">
_foo:
        addl    %esi, %edi
        movl    %edi, %eax
        ret
</pre>
</div>
<div class="section" id="how-can-i-have-the-assembly-output-be-printed-using-intel-assembly-syntax">
<h2>How can I have the assembly output be printed using Intel assembly syntax?</h2>
<p>The <tt class="docutils literal">ispc</tt> compiler supports both AT&amp;T and Intel assembly syntax. By
default, AT&amp;T syntax is used, where the destination operand is the last
operand after an instruction. To use Intel syntax instead, use the
<tt class="docutils literal"><span class="pre">--x86-asm-syntax=intel</span></tt> command-line option:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.s --emit-asm --x86-asm-syntax=intel
</pre>
<p>The available options are <tt class="docutils literal"><span class="pre">--x86-asm-syntax=att</span></tt> (default) and
<tt class="docutils literal"><span class="pre">--x86-asm-syntax=intel</span></tt>.</p>
</div>
<div class="section" id="why-are-there-multiple-versions-of-exported-ispc-functions-in-the-assembly-output">
<h2>Why are there multiple versions of exported ispc functions in the assembly output?</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Upcoming change:</strong> In a future ISPC release, <tt class="docutils literal">export</tt> functions will
generate only a single external (C/C++-callable) version by default.
Starting in ISPC 1.29, the compiler issues a warning when an exported
function is called from ISPC code to help identify code that will be
affected. To prepare for this change, use non-exported functions for
ISPC-to-ISPC calls, or use <tt class="docutils literal"><span class="pre">__attribute__((external_only))</span></tt> to opt
into the new behavior early.</p>
</div>
<p>Two versions of all functions qualified with <tt class="docutils literal">export</tt> are generated:
one for being called by other <tt class="docutils literal">ispc</tt> functions, and the other to be
called by the application. The application-callable function has the
original function's name, while the <tt class="docutils literal">ispc</tt>-callable function has a
mangled name that encodes the types of the function's parameters.</p>
<p>The crucial difference between these two functions is that the
application-callable function doesn't take a parameter encoding the current
execution mask, while <tt class="docutils literal">ispc</tt>-callable functions have a hidden mask
parameter. An implication of this difference is that the <tt class="docutils literal">export</tt>
function starts with the execution mask &quot;all on&quot;. This allows a number of
improvements in the generated code, particularly on architectures that
don't have support for masked load and store instructions.</p>
<p>With the <tt class="docutils literal"><span class="pre">__attribute__((external_only))</span></tt> attribute, only the external
version is generated, which simplifies the output and reduces code size
when ISPC-to-ISPC calls are not needed.</p>
</div>
<div class="section" id="how-can-i-more-easily-see-gathers-and-scatters-in-generated-assembly">
<h2>How can I more easily see gathers and scatters in generated assembly?</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Modern vector ISAs include native gather and scatter instructions: AVX2
added gather instructions, and AVX-512 added both gather and scatter.
The information below applies primarily to older targets (SSE2, SSE4)
that lack native support for these operations.</p>
</div>
<p>On older targets without native gather and scatter instructions, these
memory operations are turned into sequences of a series of instructions in
the code that <tt class="docutils literal">ispc</tt> generates. In some cases, it can be useful to see
where gathers and scatters actually happen in code; there is an otherwise
undocumented command-line flag that provides this information.</p>
<p>Consider this simple program:</p>
<pre class="literal-block">
void set(uniform int a[], int value, int index) {
    a[index] = value;
}
</pre>
<p>When compiled normally to the SSE4 target, this program generates this
extensive code sequence, which makes it more difficult to see what the
program is actually doing.</p>
<pre class="literal-block">
&quot;_set___uptr&lt;Ui&gt;ii&quot;:
        pmulld        LCPI0_0(%rip), %xmm1
        movmskps      %xmm2, %eax
        testb         $1, %al
        je            LBB0_2
        movd          %xmm1, %ecx
        movd          %xmm0, (%rcx,%rdi)
LBB0_2:
        testb         $2, %al
        je            LBB0_4
        pextrd        $1, %xmm1, %ecx
        pextrd        $1, %xmm0, (%rcx,%rdi)
LBB0_4:
        testb         $4, %al
        je            LBB0_6
        pextrd        $2, %xmm1, %ecx
        pextrd        $2, %xmm0, (%rcx,%rdi)
LBB0_6:
        testb        $8, %al
        je            LBB0_8
        pextrd        $3, %xmm1, %eax
        pextrd        $3, %xmm0, (%rax,%rdi)
LBB0_8:
        ret
</pre>
<p>If this program is compiled with the
<tt class="docutils literal"><span class="pre">--opt=disable-handle-pseudo-memory-ops</span></tt> command-line flag, then the
scatter is left as an unresolved function call.  The resulting program
won't link without unresolved symbols, but the assembly output is much
easier to understand:</p>
<pre class="literal-block">
&quot;_set___uptr&lt;Ui&gt;ii&quot;:
        movaps        %xmm0, %xmm3
        pmulld        LCPI0_0(%rip), %xmm1
        movdqa        %xmm1, %xmm0
        movaps        %xmm3, %xmm1
        jmp        ___pseudo_scatter_base_offsets32_32 ## TAILCALL
</pre>
</div>
</div>
<div class="section" id="language-details">
<h1>Language Details</h1>
<div class="section" id="what-is-the-difference-between-int-foo-and-int-foo">
<h2>What is the difference between &quot;int *foo&quot; and &quot;int foo[]&quot;?</h2>
<p>In C and C++, declaring a function to take a parameter <tt class="docutils literal">int *foo</tt> and
<tt class="docutils literal">int foo[]</tt> results in the same type for the parameter.  Both are
pointers to integers.  In <tt class="docutils literal">ispc</tt>, these are different types.  The first
one is a varying pointer to a uniform integer value in memory, while the
second results in a uniform pointer to the start of an array of varying
integer values in memory.</p>
<p>To understand why the first is a varying pointer to a uniform integer,
first recall that types without explicit rate qualifiers (<tt class="docutils literal">uniform</tt>,
<tt class="docutils literal">varying</tt>, or <tt class="docutils literal">soa&lt;&gt;</tt>) are <tt class="docutils literal">varying</tt> by default.  Second, recall from
the <a class="reference external" href="ispc.html#pointer-types">discussion of pointer types in the ispc User's Guide</a> that pointed-to
types without rate qualifiers are <tt class="docutils literal">uniform</tt> by default.  (This second
rule is discussed further below, in <a class="reference internal" href="#why-are-pointed-to-types-uniform-by-default">Why are pointed-to types &quot;uniform&quot; by
default?</a>.)  The type of <tt class="docutils literal">int *foo</tt> follows from these.</p>
<p>Conversely, in a function body, <tt class="docutils literal">int foo[10]</tt> represents a declaration of
a 10-element array of varying <tt class="docutils literal">int</tt> values.  In that we'd certainly like
to be able to pass such an array to a function that takes an <tt class="docutils literal">int []</tt>
parameter, the natural type for an <tt class="docutils literal">int []</tt> parameter is a uniform
pointer to varying integer values.</p>
<p>In terms of compatibility with C/C++, it's unfortunate that this
distinction exists, though any other set of rules seems to introduce more
awkwardness than this one.  (Though we're interested to hear ideas to
improve these rules!).</p>
</div>
<div class="section" id="why-are-pointed-to-types-uniform-by-default">
<h2>Why are pointed-to types &quot;uniform&quot; by default?</h2>
<p>In <tt class="docutils literal">ispc</tt>, types without rate qualifiers are &quot;varying&quot; by default, but
types pointed to by pointers without rate qualifiers are &quot;uniform&quot; by
default.  Why this difference?</p>
<pre class="literal-block">
int foo;  // no rate qualifier, &quot;varying int&quot;.
uniform int *foo;  // pointer type has no rate qualifier, pointed-to does.
                   // &quot;varying pointer to uniform int&quot;.
int *foo;  // neither pointer type nor pointed-to type (&quot;int&quot;) have
           // rate qualifiers. Pointer type is varying by default,
           // pointed-to is uniform. &quot;varying pointer to uniform int&quot;.
varying int *foo;   // varying pointer to varying int
</pre>
<p>The first rule, having types without rate qualifiers be varying by default,
is a default that keeps the number of &quot;uniform&quot; or &quot;varying&quot; qualifiers in
<tt class="docutils literal">ispc</tt> programs low.  Most <tt class="docutils literal">ispc</tt> programs use mostly &quot;varying&quot;
variables, so this rule allows most variables to be declared without also
requiring rate qualifiers.</p>
<p>On a related note, this rule allows many C/C++ functions to be used to
define equivalent functions in the SPMD execution model that <tt class="docutils literal">ispc</tt>
provides with little or no modification:</p>
<pre class="literal-block">
// scalar add in C/C++, SPMD/vector add in ispc
int add(int a, int b) { return a + b; }
</pre>
<p>This motivation also explains why <tt class="docutils literal">uniform int *foo</tt> represents a varying
pointer; having pointers be varying by default if they don't have rate
qualifiers similarly helps with porting code from C/C++ to <tt class="docutils literal">ispc</tt>.</p>
<p>The trickier issue is why pointed-to types are &quot;uniform&quot; by default.  In our
experience, data in memory that is accessed via pointers is most often
uniform; this generally includes all data that has been allocated and
initialized by the C/C++ application code. In practice, &quot;varying&quot; types are
more generally (but not exclusively) used for local data in <tt class="docutils literal">ispc</tt>
functions.  Thus, making the pointed-to type uniform by default leads to
more concise code for the most common cases.</p>
</div>
<div class="section" id="why-am-i-getting-an-error-about-assigning-a-varying-lvalue-to-a-reference-type">
<h2>Why am I getting an error about assigning a varying lvalue to a reference type?</h2>
<p>Given code like the following:</p>
<pre class="literal-block">
uniform float a[...];
int index = ...;
float &amp;r = a[index];
</pre>
<p><tt class="docutils literal">ispc</tt> issues the error &quot;Initializer for reference-type variable &quot;r&quot; must
have a uniform lvalue type.&quot;.  The underlying issue stems from how
references are represented in the code generated by <tt class="docutils literal">ispc</tt>.  Recall that
<tt class="docutils literal">ispc</tt> supports both uniform and varying pointer types--a uniform pointer
points to the same location in memory for all program instances in the
gang, while a varying pointer allows each program instance to have its own
pointer value.</p>
<p>References are represented as a pointer in the code generated by <tt class="docutils literal">ispc</tt>,
though this is generally opaque to the user; in <tt class="docutils literal">ispc</tt>, they are
specifically uniform pointers.  This design decision was made so that given
code like this:</p>
<pre class="literal-block">
extern void func(float &amp;val);
float foo = ...;
func(foo);
</pre>
<p>Then the reference would be handled efficiently as a single pointer, rather
than unnecessarily being turned into a gang-size of pointers.</p>
<p>However, an implication of this decision is that it's not possible for
references to refer to completely different things for each of the program
instances.  (And hence the error that is issued).  In cases where a unique
per-program-instance pointer is needed, a varying pointer should be used
instead of a reference.</p>
</div>
</div>
<div class="section" id="interoperability">
<h1>Interoperability</h1>
<div class="section" id="how-can-i-supply-an-initial-execution-mask-in-the-call-from-the-application">
<h2>How can I supply an initial execution mask in the call from the application?</h2>
<p>Recall that when execution transitions from the application code to an
<tt class="docutils literal">ispc</tt> function, all of the program instances are initially executing.
In some cases, it may be desired that only some of them are running, based on
a data-dependent condition computed in the application program.  This
situation can easily be handled via an additional parameter from the
application.</p>
<p>As a simple example, consider a case where the application code has an
array of <tt class="docutils literal">float</tt> values and we'd like the <tt class="docutils literal">ispc</tt> code to update
just specific values in that array, where which of those values to be
updated has been determined by the application.  In C++ code, we might
have:</p>
<pre class="literal-block">
int count = ...;
float *array = new float[count];
bool *shouldUpdate = new bool[count];
// initialize array and shouldUpdate
ispc_func(array, shouldUpdate, count);
</pre>
<p>Then, the <tt class="docutils literal">ispc</tt> code could process this update as:</p>
<pre class="literal-block">
export void ispc_func(uniform float array[], uniform bool update[],
                      uniform int count) {
    foreach (i = 0 ... count) {
        cif (update[i] == true) {
            // update array[i]...
        }
    }
}
</pre>
<p>(In this case a &quot;coherent&quot; if statement is likely to be worthwhile if the
<tt class="docutils literal">update</tt> array will tend to have sections that are either all-true or
all-false.)</p>
</div>
<div class="section" id="how-can-i-generate-a-single-binary-executable-with-support-for-multiple-instruction-sets">
<h2>How can I generate a single binary executable with support for multiple instruction sets?</h2>
<p><tt class="docutils literal">ispc</tt> can also generate output that supports multiple target instruction
sets, also generating code that chooses the most appropriate one at runtime
if multiple targets are specified with the <tt class="docutils literal"><span class="pre">--target</span></tt> command-line
argument.</p>
<p>For example, if you run the command:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.o --target=sse2,sse4-x2,avx-x2
</pre>
<p>Then four object files will be generated: <tt class="docutils literal">foo_sse2.o</tt>, <tt class="docutils literal">foo_sse4.o</tt>,
<tt class="docutils literal">foo_avx.o</tt>, and <tt class="docutils literal">foo.o</tt> <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>. Link all of these into your executable, and
when you call a function in <tt class="docutils literal">foo.ispc</tt> from your application code,
<tt class="docutils literal">ispc</tt> will determine which instruction sets are supported by the CPU the
code is running on and will call the most appropriate version of the
function available.</p>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Similarly, if you choose to generate assembly language output or
LLVM bitcode output, multiple versions of those files will be created.</td></tr>
</tbody>
</table>
<p>In general, the version of the function that runs will be the one in the
most general instruction set that is supported by the system.  If you only
compile SSE2 and SSE4 variants and run on a system that supports AVX, for
example, then the SSE4 variant will be executed.  If the system
is not able to run any of the available variants of the function (for
example, trying to run a function that only has SSE4 and AVX variants on a
system that only supports SSE2), then the standard library <tt class="docutils literal">abort()</tt>
function will be called.</p>
<p>One subtlety is that all non-static global variables (if any) must have the
same size and layout with all of the targets used.  For example, if you
have the global variables:</p>
<pre class="literal-block">
uniform int foo[2*programCount];
int bar;
</pre>
<p>and compile to both SSE2 and AVX targets, both of these variables will have
different sizes (the first due to program count having the value 4 for SSE2
and 8 for AVX, and the second due to <tt class="docutils literal">varying</tt> types having different
numbers of elements with the two targets--essentially the same issue as the
first.)  <tt class="docutils literal">ispc</tt> issues an error in this case.</p>
</div>
<div class="section" id="how-can-i-determine-at-run-time-which-vector-instruction-set-s-instructions-were-selected-to-execute">
<h2>How can I determine at run-time which vector instruction set's instructions were selected to execute?</h2>
<p><tt class="docutils literal">ispc</tt> doesn't provide any API that allows querying which vector ISA's
instructions are running when multi-target compilation was used.  However,
this can be solved in &quot;user space&quot; by writing a small helper function.
Specifically, if you implement a function like this</p>
<pre class="literal-block">
export uniform int isa() {
#if defined(ISPC_TARGET_SSE2)
    return 0;
#elif defined(ISPC_TARGET_SSE4)
    return 1;
#elif defined(ISPC_TARGET_AVX)
    return 2;
#else
    return -1;
#endif
}
</pre>
<p>And then call it from your application code at runtime, it will return 0,
1, or 2, depending on which target's instructions are running.</p>
<p>The way this works is a little surprising, but it's a useful trick.  Of
course the preprocessor <tt class="docutils literal">#if</tt> checks are all compile-time only
operations.  What's actually happening is that the function is compiled
multiple times, once for each target, with the appropriate <tt class="docutils literal">ISPC_TARGET</tt>
preprocessor symbol set.  Then, a small dispatch function is generated for
the application to actually call.  This dispatch function in turn calls the
appropriate version of the function based on the CPU of the system it's
executing on, which in turn returns the appropriate value.</p>
<p>In a similar fashion, it's possible to find out at run-time the value of
<tt class="docutils literal">programCount</tt> for the target that's actually being used.</p>
<pre class="literal-block">
export uniform int width() { return programCount; }
</pre>
</div>
<div class="section" id="is-it-possible-to-inline-ispc-functions-in-c-c-code">
<h2>Is it possible to inline ispc functions in C/C++ code?</h2>
<p>If you're willing to use the <tt class="docutils literal">clang</tt> C/C++ compiler that's part of the
LLVM tool suite, then it is possible to inline <tt class="docutils literal">ispc</tt> code with C/C++
(and conversely, to inline C/C++ calls in <tt class="docutils literal">ispc</tt>).  Doing so can provide
performance advantages when calling out to short functions written in the
&quot;other&quot; language.  Note that you don't need to use <tt class="docutils literal">clang</tt> to compile all
of your C/C++ code, but only for the files where you want to be able to
inline.  In order to do this, you must have a full installation of LLVM,
including the <tt class="docutils literal">clang</tt> compiler.</p>
<p>The basic approach is to have the various compilers emit LLVM intermediate
representation (IR) code and to then use tools from LLVM to link together
the IR from the compilers and then re-optimize it, which gives the LLVM
optimizer the opportunity to do additional inlining and cross-function
optimizations.  If you have source files <tt class="docutils literal">foo.ispc</tt> and <tt class="docutils literal">foo.cpp</tt>,
first emit LLVM IR:</p>
<pre class="literal-block">
ispc --emit-llvm -o foo_ispc.bc foo.ispc
clang -O2 -c -emit-llvm -o foo_cpp.bc foo.cpp
</pre>
<p>Next, link the two IR files into a single file and run the LLVM optimizer
on the result:</p>
<pre class="literal-block">
llvm-link foo_ispc.bc foo_cpp.bc -o - | opt -O3 -o foo_opt.bc
</pre>
<p>And finally, generate a native object file:</p>
<pre class="literal-block">
llc -filetype=obj foo_opt.bc -o foo.o
</pre>
<p>This file can then be linked with the rest of your object files when
linking your application.</p>
<p>(Note that if you're using the AVX instruction set, you must provide the
<tt class="docutils literal"><span class="pre">-mattr=+avx</span></tt> flag to <tt class="docutils literal">llc</tt>.)</p>
</div>
<div class="section" id="why-is-it-illegal-to-pass-varying-values-from-c-c-to-ispc-functions">
<h2>Why is it illegal to pass &quot;varying&quot; values from C/C++ to ispc functions?</h2>
<p>If any of the types in the parameter list to an exported function is
&quot;varying&quot; (including recursively, and members of structure types, etc.),
then <tt class="docutils literal">ispc</tt> will issue an error and refuse to compile the function:</p>
<pre class="literal-block">
% echo &quot;export int add(int x) { return ++x; }&quot; | ispc
&lt;stdin&gt;:1:12: Error: Illegal to return a &quot;varying&quot; or vector type from exported function &quot;add&quot;
&lt;stdin&gt;:1:20: Error: Varying parameter &quot;x&quot; is illegal in an exported function.
</pre>
<p>While there's no fundamental reason why this isn't possible, recall the
definition of &quot;varying&quot; variables: they have one value for each program
instance in the gang.  As such, the number of values and amount of storage
required to represent a varying variable depends on the gang size
(i.e. <tt class="docutils literal">programCount</tt>), which can have different values depending on the
compilation target.</p>
<p><tt class="docutils literal">ispc</tt> therefore prohibits passing &quot;varying&quot; values between the
application and the <tt class="docutils literal">ispc</tt> program in order to prevent the
application-side code from depending on a particular gang size, in order to
encourage portability to different gang sizes.  (A generally desirable
programming practice.)</p>
<p>For cases where the size of data is actually fixed from the application
side, the value can be passed via a pointer to a short <tt class="docutils literal">uniform</tt> array,
as follows:</p>
<pre class="literal-block">
export void add4(uniform int ptr[4]) {
    foreach (i = 0 ... 4)
        ptr[i]++;
}
</pre>
<p>On the 4-wide SSE instruction set, this compiles to a single vector add
instruction (and associated move instructions), while it still also
efficiently computes the correct result on 8-wide AVX targets.</p>
</div>
</div>
<div class="section" id="programming-techniques">
<h1>Programming Techniques</h1>
<div class="section" id="what-primitives-are-there-for-communicating-between-spmd-program-instances">
<h2>What primitives are there for communicating between SPMD program instances?</h2>
<p>The <tt class="docutils literal">broadcast()</tt>, <tt class="docutils literal">rotate()</tt>, and <tt class="docutils literal">shuffle()</tt> standard library
routines provide a variety of mechanisms for the running program instances
to communicate values to each other during execution.  Note that there's no
need to synchronize the program instances before communicating between
them, due to the synchronized execution model of gangs of program instances
in <tt class="docutils literal">ispc</tt>.</p>
</div>
<div class="section" id="how-can-a-gang-of-program-instances-generate-variable-amounts-of-output-efficiently">
<h2>How can a gang of program instances generate variable amounts of output efficiently?</h2>
<p>It's not unusual to have a gang of program instances where each program
instance generates a variable amount of output (perhaps some generate no
output, some generate one output value, some generate many output values
and so forth), and where one would like to have the output densely packed
in an output array.  The <tt class="docutils literal">exclusive_scan_add()</tt> function from the
standard library is quite useful in this situation.</p>
<p>Consider the following function:</p>
<pre class="literal-block">
uniform int func(uniform float outArray[], ...) {
   int numOut = ...;  // figure out how many to be output
   float outLocal[MAX_OUT]; // staging area

   // each program instance in the gang puts its results in
   //  outLocal[0], ..., outLocal[numOut-1]

   int startOffset = exclusive_scan_add(numOut);
   for (int i = 0; i &lt; numOut; ++i)
       outArray[startOffset + i] = outLocal[i];
   return reduce_add(numOut);
}
</pre>
<p>Here, each program instance has computed a number, <tt class="docutils literal">numOut</tt>, of values to
output, and has stored them in the <tt class="docutils literal">outLocal</tt> array.  Assume that four
program instances are running and that the first one wants to output one
value, the second two values, and the third and fourth three values each.
In this case, <tt class="docutils literal">exclusive_scan_add()</tt> will return the values (0, 1, 3, 6)
to the four program instances, respectively.</p>
<p>The first program instance will then write its one result to
<tt class="docutils literal">outArray[0]</tt>, the second will write its two values to <tt class="docutils literal">outArray[1]</tt>
and <tt class="docutils literal">outArray[2]</tt>, and so forth.  The <tt class="docutils literal">reduce_add()</tt> call at the end
returns the total number of values that all of the program instances have
written to the array.</p>
</div>
<div class="section" id="is-it-possible-to-use-ispc-for-explicit-vector-programming">
<h2>Is it possible to use ispc for explicit vector programming?</h2>
<p>The typical model for programming in <tt class="docutils literal">ispc</tt> is an <em>implicit</em> parallel
model, where one writes a program that is apparently doing scalar
computation on values and the program is then vectorized to run in parallel
across the SIMD lanes of a processor.  However, <tt class="docutils literal">ispc</tt> also has some
support for explicit vector unit programming, where the vectorization is
explicit.  Some computations may be more effectively described in the
explicit model rather than the implicit model.</p>
<p>This support is provided via <tt class="docutils literal">uniform</tt> instances of short vectors.
Specifically, if this short program</p>
<pre class="literal-block">
uniform float&lt;8&gt; madd(uniform float&lt;8&gt; a, uniform float&lt;8&gt; b,
                             uniform float&lt;8&gt; c) {
    return a + b * c;
}
</pre>
<p>is compiled with the AVX target, <tt class="docutils literal">ispc</tt> generates the following assembly:</p>
<pre class="literal-block">
_madd:
    vmulps  %ymm2, %ymm1, %ymm1
    vaddps  %ymm0, %ymm1, %ymm0
    ret
</pre>
<p>(And similarly, if compiled with a 4-wide SSE target, two <tt class="docutils literal">mulps</tt> and two
<tt class="docutils literal">addps</tt> instructions are generated, and so forth.)</p>
<p>Note that <tt class="docutils literal">ispc</tt> doesn't currently support control-flow based on
<tt class="docutils literal">uniform</tt> short vector types; it is thus not possible to write code like:</p>
<pre class="literal-block">
uniform int&lt;8&gt; count(uniform float&lt;8&gt; a, uniform float&lt;8&gt; b) {
    uniform int&lt;8&gt; sum = 0;
    while (a++ &lt; b)
        ++sum;
}
</pre>
</div>
<div class="section" id="how-can-i-debug-my-ispc-programs-using-valgrind">
<h2>How can I debug my ispc programs using Valgrind?</h2>
<p>The <a class="reference external" href="http://valgrind.org">valgrind</a> memory checker is an extremely useful memory checker for
Linux and macOS; it detects a range of memory errors, including accessing
memory after it has been freed, accessing memory beyond the end of an
array, accessing uninitialized stack variables, and so forth.
In general, applications that use <tt class="docutils literal">ispc</tt> code run with <tt class="docutils literal">valgrind</tt>
without modification and <tt class="docutils literal">valgrind</tt> will detect the same range of memory
errors in <tt class="docutils literal">ispc</tt> code that it does in C/C++ code.</p>
<p>Modern versions of <tt class="docutils literal">valgrind</tt> support SSE, AVX, AVX2, and AVX-512
instruction sets. If you encounter an error message like the following,
it indicates that your version of <tt class="docutils literal">valgrind</tt> doesn't support some
instructions used by your <tt class="docutils literal">ispc</tt> program:</p>
<pre class="literal-block">
vex amd64-&gt;IR: unhandled instruction bytes: ...
valgrind: Unrecognised instruction at address ...
</pre>
<p>In this case, either update <tt class="docutils literal">valgrind</tt> to a newer version or compile
your <tt class="docutils literal">ispc</tt> program with an older target (e.g., <tt class="docutils literal"><span class="pre">--target=sse4</span></tt>) for
debugging purposes.</p>
</div>
<div class="section" id="foreach-statements-generate-more-complex-assembly-than-i-d-expect-what-s-going-on">
<h2>foreach statements generate more complex assembly than I'd expect; what's going on?</h2>
<p>Given a simple <tt class="docutils literal">foreach</tt> loop like the following:</p>
<pre class="literal-block">
void foo(uniform float a[], uniform int count) {
    foreach (i = 0 ... count)
        a[i] *= 2;
}
</pre>
<p>the <tt class="docutils literal">ispc</tt> compiler generates approximately 40 instructions--why isn't
the generated code simpler?</p>
<p>There are two main components to the code: one handles
<tt class="docutils literal">programCount</tt>-sized chunks of elements of the array, and the other
handles any excess elements at the end of the array that don't completely
fill a gang.  The code for the main loop is essentially what one would
expect: a vector of values are loaded from the array, the multiply is done,
and the result is stored.</p>
<pre class="literal-block">
LBB0_2:                                 ## %foreach_full_body
    movslq  %edx, %rdx
    vmovups (%rdi,%rdx), %ymm1
    vmulps  %ymm0, %ymm1, %ymm1
    vmovups %ymm1, (%rdi,%rdx)
    addl    $32, %edx
    addl    $8, %eax
    cmpl    %ecx, %eax
    jl      LBB0_2
</pre>
<p>Then, there is a sequence of instructions that handles any additional
elements at the end of the array.  (These instructions don't execute if
there aren't any left-over values to process, but they do lengthen the
amount of generated code.)</p>
<pre class="literal-block">
## BB#4:                                ## %partial_inner_only
      vmovd   %eax, %xmm0
      vinsertf128     $1, %xmm0, %ymm0, %ymm0
      vpermilps       $0, %ymm0, %ymm0 ## ymm0 = ymm0[0,0,0,0,4,4,4,4]
      vextractf128    $1, %ymm0, %xmm3
      vmovd   %esi, %xmm2
      vmovaps LCPI0_1(%rip), %ymm1
      vextractf128    $1, %ymm1, %xmm4
      vpaddd  %xmm4, %xmm3, %xmm3
      # ....
      vmulps  LCPI0_0(%rip), %ymm1, %ymm1
      vmaskmovps      %ymm1, %ymm0, (%rdi,%rax)
</pre>
<p>If you know that the number of elements to be processed will always be an
exact multiple of the 8, 16, etc., then adding a simple assignment to
<tt class="docutils literal">count</tt> like the one below gives the compiler enough information to be
able to eliminate the code for the additional array elements.</p>
<pre class="literal-block">
void foo(uniform float a[], uniform int count) {
    // This assignment doesn't change the value of count
    // if it's a multiple of 16, but it gives the compiler
    // insight into this fact, allowing for simpler code to
    // be generated for the foreach loop.
    count = (count &amp; ~(16-1));
    foreach (i = 0 ... count)
        a[i] *= 2;
}
</pre>
<p>With this new version of <tt class="docutils literal">foo()</tt>, only the code for the first loop above
is generated.</p>
<div class="section" id="foreach-vs-for-loops-when-to-use-which">
<h3>foreach vs. for loops: when to use which?</h3>
<p>A common question is why <tt class="docutils literal">foreach</tt> generates different code than an
equivalent <tt class="docutils literal">for</tt> loop using <tt class="docutils literal">programIndex</tt> and <tt class="docutils literal">programCount</tt>.
Understanding this difference is important for writing efficient code.</p>
<p><strong>The key difference:</strong> <tt class="docutils literal">foreach</tt> begins each loop iteration with an
&quot;all on&quot; execution mask, meaning all program instances are active at the
start. In contrast, a <tt class="docutils literal">for</tt> loop using <tt class="docutils literal">programIndex</tt> and
<tt class="docutils literal">programCount</tt> respects the current execution mask, which may have some
instances disabled. This difference affects code generation significantly.</p>
<p>For example, this <tt class="docutils literal">foreach</tt> loop:</p>
<pre class="literal-block">
foreach (index = 0 ... 16) {
    values[index] = select(upd, newVal, values[index]);
}
</pre>
<p>generates efficient vectorized code (approximately 6 instructions), while
this seemingly equivalent <tt class="docutils literal">for</tt> loop:</p>
<pre class="literal-block">
for (int i = programIndex; i &lt; 16; i += programCount) {
    values[i] = select(upd, newVal, values[i]);
}
</pre>
<p>may generate significantly more complex code with branches because the
compiler must handle the possibility of partially-active masks.</p>
<p><strong>Solution:</strong> To achieve comparable performance with a <tt class="docutils literal">for</tt> loop, wrap
it in an <tt class="docutils literal">unmasked</tt> region:</p>
<pre class="literal-block">
unmasked {
    for (uniform int i = 0; i &lt; 16; i += programCount) {
        int index = i + programIndex;
        values[index] = select(upd, newVal, values[index]);
    }
}
</pre>
<p><strong>When to prefer for loops over foreach:</strong></p>
<p>For performance-critical code where the iteration count is known to be a
multiple of <tt class="docutils literal">programCount</tt>, using a <tt class="docutils literal">uniform</tt> loop counter with
explicit <tt class="docutils literal">programIndex</tt> management can be more efficient:</p>
<pre class="literal-block">
uniform int count_base = count &amp; ~(programCount-1);

// Main loop - processes programCount elements per iteration
for (uniform int i = 0; i &lt; count_base; i += programCount) {
    varying float temp = in[i + programIndex];
    out[i + programIndex] = temp * temp;
}

// Tail loop - handles remaining elements
for (uniform int i = count_base; i &lt; count; ++i) {
    uniform float temp = in[i];
    out[i] = temp * temp;
}
</pre>
<p>This pattern is particularly important when:</p>
<ul class="simple">
<li>The loop body involves index arithmetic (modulus, division) that could
trigger gather/scatter operations with <tt class="docutils literal">foreach</tt>'s varying index</li>
<li>Manual loop unrolling is desired (which works better with <tt class="docutils literal">uniform</tt>
loop counters)</li>
<li>Maximum control over vectorization is needed</li>
</ul>
<p>In summary:</p>
<ul class="simple">
<li>Use <tt class="docutils literal">foreach</tt> for convenience and automatic tail handling</li>
<li>Use <tt class="docutils literal">for</tt> with <tt class="docutils literal">unmasked</tt> when you need <tt class="docutils literal">foreach</tt>-like behavior
but with more control</li>
<li>Use <tt class="docutils literal">uniform for</tt> loops for performance-critical code where you
manage the iteration pattern explicitly</li>
</ul>
</div>
</div>
<div class="section" id="how-do-i-launch-an-individual-task-for-each-active-program-instance">
<h2>How do I launch an individual task for each active program instance?</h2>
<p>Recall from the <a class="reference external" href="ispc.html#task-parallelism-launch-and-sync-statements">discussion of &quot;launch&quot; in the ispc User's Guide</a> that a
<tt class="docutils literal">launch</tt> statement launches a single task corresponding to a single gang
of executing program instances, where the indices of the active program
instances are the same as were active when the <tt class="docutils literal">launch</tt> statement
executed.</p>
<p>In some situations, it's desirable to be able to launch an individual task
for each executing program instance.  For example, we might be performing
an iterative computation where a subset of the program instances determine
that an item they are responsible for requires additional processing.</p>
<pre class="literal-block">
bool itemNeedsMoreProcessing(int);
int itemNum = ...;
if (itemNeedsMoreProcessing(itemNum)) {
    // do additional work
}
</pre>
<p>For performance reasons, it may be desirable to apply an entire gang's
worth of computation to each item that needs additional processing;
there may be available parallelism in this computation such that we'd like
to process each of the items with SPMD computation.</p>
<p>In this case, the <tt class="docutils literal">foreach_active</tt> and <tt class="docutils literal">unmasked</tt> constructs can be
applied together to accomplish this goal.</p>
<pre class="literal-block">
// do additional work
task void doWork(uniform int index);
foreach_active (index) {
    unmasked {
        launch doWork(extract(itemNum, index));
    }
}
</pre>
<p>Recall that the body of the <tt class="docutils literal">foreach_active</tt> loop runs once for each
active program instance, with each active program instance's
<tt class="docutils literal">programIndex</tt> value available in <tt class="docutils literal">index</tt> in the above.  In the loop,
we can re-establish an &quot;all on&quot; execution mask, enabling execution in all
of the program instances in the gang, such that execution in <tt class="docutils literal">doWork()</tt>
starts with all instances running.  (Alternatively, the <tt class="docutils literal">unmasked</tt> block
could be in the definition of <tt class="docutils literal">doWork()</tt>.)</p>
</div>
</div>
      </article>

      <aside class="sidebar">
        <div class="sidebar-section">
          <h3>Resources</h3>
          <ul class="resource-links">
            <li><a href="http://github.com/ispc/ispc">GitHub Repository</a></li>
            <li><a href="https://github.com/ispc/ispc/discussions">Community Discussions</a></li>
            <li><a href="http://github.com/ispc/ispc/issues">Report Issues</a></li>
            <li><a href="https://github.com/orgs/ispc/projects/1">Release Planning</a></li>
            <li><a href="https://github.com/ispc/ispc/blob/main/CONTRIBUTING.md">Contributing Guide</a></li>
            <li><a href="http://github.com/ispc/ispc/wiki">Documentation Wiki</a></li>
          </ul>
        </div>
      </aside>
    </div>
  </main>

  <footer class="site-footer">
    <div class="footer-content">
      <p>&copy; <strong>Intel Corporation</strong> | <a href="http://validator.w3.org/check?uri=referer">Valid HTML</a> | <a href="http://jigsaw.w3.org/css-validator/check/referer">Valid CSS</a></p>
    </div>
  </footer>
</div>
</body>
</html>
